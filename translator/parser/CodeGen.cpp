//CodeGen.cpp
#include"CodeGen.h"
#include<cassert>
#include<sstream>
#include<antlr3treeparser.h>

	//Constructor
	CodeGen::CodeGen()
	{
		_globalDataPtr=NULL;
	};

	CodeGen::~CodeGen()
	{
		//std::cout<<"\nDestroying code Generator\n\n";
	};



	void CodeGen::setGlobalDataPtr(GlobalData * global_data)
	{
		_globalDataPtr=global_data;
	};

	std::string CodeGen::intToString(const int & i)
	{
		std::stringstream ss;
		ss<<i;
		return ss.str();
	};



	void CodeGen::parse()
	{
		
		//1. Check if Global data structure exists.
		//2. Check if Global data structure contains all necessary
		//	information, such as name of template file, name
		//	of output directory etc.
		//3. Check if the template file exists, and output directory
		//	exists.
		//
		//
		//4. create the parser object and initialize it.
		//5. parse the template, gnerate code
		//6. close everything: free parser, close files and return
		//
		
		

		
		//Check if Global data structure exists.

		assert(_globalDataPtr!=NULL);
		


		
		//Check if Global data structure contains all necessary
		//information, such as name of template file, name
		//of output directory .
		std::string template_file=_globalDataPtr->getAttribute("TEMPLATE_FILE");
		if(template_file=="")
		{
			std::cerr<<"\nCode Generator Error: Template file not specified";
			exit(1);
		}
		std::string output_dir=_globalDataPtr->getAttribute("OUTPUT_DIR");
		if(output_dir=="")
		{
			std::cerr<<"\nCode Generator Error: Output directory not specified";
			exit(1);
		}
		std::string design_unit_name=_globalDataPtr->getAttribute("design_unit_name");
		if(design_unit_name=="")
		{
			std::cerr<<"\nCode Generator Error: No design unit parsed";
			exit(1);
		}




		// Check if the template file exists, and outiput directory exists
		// --these checks are already in main.cpp

		finput=(pANTLR3_UINT8)(template_file.c_str());

		input = antlr3FileStreamNew ((pANTLR3_UINT8)finput, ANTLR3_ENC_8BIT);
		if ( input == NULL)
		{
			fprintf(stderr, "Failed to open file %s\n", (char *)finput);
			exit(1);
		}
		lxr        = output_templateLexerNew(input);     
		if ( lxr == NULL )
		{
			fprintf(stderr, "Unable to create the lexer due to malloc() failure1\n");
			exit(1);
		}

		tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));

		if (tstream == NULL)
		{
			fprintf(stderr, "Out of memory trying to allocate token stream\n");
			exit(1);
		}

		// Finally, now that we have our lexer constructed, we can create the parser
		//
		psr        = output_templateParserNew(tstream);  // CParserNew is generated by ANTLR3

		if (psr == NULL)
		{
			fprintf(stderr, "Out of memory trying to allocate token stream\n");
			exit(1);
		}

		//do some initializations
		assert(_globalDataPtr!=NULL);
		psr->setGlobalDataPtr(_globalDataPtr);


		//Now start parsing
		psr->top(psr);

		//Free up everything

		if(psr!=NULL) 	{psr->free(psr); 	psr  = NULL;}
		if(tstream!=NULL)	{tstream ->free  (tstream);  	tstream = NULL;}
		if(lxr!=NULL)	{lxr->free(lxr);	lxr = NULL;}
		if(input!=NULL)		{input ->close (input);    input   = NULL;}

	};




