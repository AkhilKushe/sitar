/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /home/project/sitarV2/translator/grammar/sitar.g
 *     -                            On : 2015-10-31 20:02:06
 *     -                for the parser : sitarParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "sitarParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   psitarParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  psitarParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->psitarParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->psitarParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_top scope set
 */
static psitarParser_top_SCOPE   psitarParser_topPush(psitarParser ctx);
static void ANTLR3_CDECL topFree(psitarParser_top_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL topFree(psitarParser_top_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser top scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_topTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_top_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_top_SCOPE
psitarParser_topPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_top_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_topStack->size(ctx->psitarParser_topStack) > ctx->psitarParser_topStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_top_SCOPE)ctx->psitarParser_topStack->get(ctx->psitarParser_topStack, ctx->psitarParser_topStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_top_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_top_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_topStack->push(ctx->psitarParser_topStack, newAttributes, (void (*)(void *))topFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_topStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_du scope set
 */
static psitarParser_du_SCOPE   psitarParser_duPush(psitarParser ctx);
static void ANTLR3_CDECL duFree(psitarParser_du_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL duFree(psitarParser_du_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser du scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_duTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_du_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_du_SCOPE
psitarParser_duPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_du_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_duStack->size(ctx->psitarParser_duStack) > ctx->psitarParser_duStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_du_SCOPE)ctx->psitarParser_duStack->get(ctx->psitarParser_duStack, ctx->psitarParser_duStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_du_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_du_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_duStack->push(ctx->psitarParser_duStack, newAttributes, (void (*)(void *))duFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_duStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_port_declaration scope set
 */
static psitarParser_port_declaration_SCOPE   psitarParser_port_declarationPush(psitarParser ctx);
static void ANTLR3_CDECL port_declarationFree(psitarParser_port_declaration_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL port_declarationFree(psitarParser_port_declaration_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser port_declaration scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_port_declarationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_port_declaration_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_port_declaration_SCOPE
psitarParser_port_declarationPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_port_declaration_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_port_declarationStack->size(ctx->psitarParser_port_declarationStack) > ctx->psitarParser_port_declarationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_port_declaration_SCOPE)ctx->psitarParser_port_declarationStack->get(ctx->psitarParser_port_declarationStack, ctx->psitarParser_port_declarationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_port_declaration_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_port_declaration_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_port_declarationStack->push(ctx->psitarParser_port_declarationStack, newAttributes, (void (*)(void *))port_declarationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_port_declarationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_net_declaration scope set
 */
static psitarParser_net_declaration_SCOPE   psitarParser_net_declarationPush(psitarParser ctx);
static void ANTLR3_CDECL net_declarationFree(psitarParser_net_declaration_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL net_declarationFree(psitarParser_net_declaration_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser net_declaration scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_net_declarationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_net_declaration_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_net_declaration_SCOPE
psitarParser_net_declarationPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_net_declaration_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_net_declarationStack->size(ctx->psitarParser_net_declarationStack) > ctx->psitarParser_net_declarationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_net_declaration_SCOPE)ctx->psitarParser_net_declarationStack->get(ctx->psitarParser_net_declarationStack, ctx->psitarParser_net_declarationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_net_declaration_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_net_declaration_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_net_declarationStack->push(ctx->psitarParser_net_declarationStack, newAttributes, (void (*)(void *))net_declarationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_net_declarationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_cf scope set
 */
static psitarParser_cf_SCOPE   psitarParser_cfPush(psitarParser ctx);
static void ANTLR3_CDECL cfFree(psitarParser_cf_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL cfFree(psitarParser_cf_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser cf scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_cfTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_cf_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_cf_SCOPE
psitarParser_cfPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_cf_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_cfStack->size(ctx->psitarParser_cfStack) > ctx->psitarParser_cfStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_cf_SCOPE)ctx->psitarParser_cfStack->get(ctx->psitarParser_cfStack, ctx->psitarParser_cfStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_cf_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_cf_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_cfStack->push(ctx->psitarParser_cfStack, newAttributes, (void (*)(void *))cfFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_cfStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_statement scope set
 */
static psitarParser_statement_SCOPE   psitarParser_statementPush(psitarParser ctx);
static void ANTLR3_CDECL statementFree(psitarParser_statement_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL statementFree(psitarParser_statement_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser statement scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_statementTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_statement_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_statement_SCOPE
psitarParser_statementPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_statement_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_statementStack->size(ctx->psitarParser_statementStack) > ctx->psitarParser_statementStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_statement_SCOPE)ctx->psitarParser_statementStack->get(ctx->psitarParser_statementStack, ctx->psitarParser_statementStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_statement_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_statement_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_statementStack->push(ctx->psitarParser_statementStack, newAttributes, (void (*)(void *))statementFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_statementStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}







/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   sitarParserTokenNames[81+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "BEGIN",
        (pANTLR3_UINT8) "BEHAVIOR",
        (pANTLR3_UINT8) "BOOL",
        (pANTLR3_UINT8) "CAPACITY",
        (pANTLR3_UINT8) "CHAR",
        (pANTLR3_UINT8) "CODE",
        (pANTLR3_UINT8) "CODE_BLOCK",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONNECT_LEFT",
        (pANTLR3_UINT8) "CONNECT_RIGHT",
        (pANTLR3_UINT8) "DECL",
        (pANTLR3_UINT8) "DO",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "ELSE",
        (pANTLR3_UINT8) "END",
        (pANTLR3_UINT8) "EQUALS",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "EXPR",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "IN",
        (pANTLR3_UINT8) "INCLUDE",
        (pANTLR3_UINT8) "INIT",
        (pANTLR3_UINT8) "INPORT",
        (pANTLR3_UINT8) "INPORT_ARRAY",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "KEYWORD_BOOL",
        (pANTLR3_UINT8) "KEYWORD_CHAR",
        (pANTLR3_UINT8) "KEYWORD_INT",
        (pANTLR3_UINT8) "LOG",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "MODULE",
        (pANTLR3_UINT8) "NET",
        (pANTLR3_UINT8) "NET_ARRAY",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "NOTHING",
        (pANTLR3_UINT8) "OCTAL_ESC",
        (pANTLR3_UINT8) "OR",
        (pANTLR3_UINT8) "OUTPORT",
        (pANTLR3_UINT8) "OUTPORT_ARRAY",
        (pANTLR3_UINT8) "PARAMETER",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "POINTER",
        (pANTLR3_UINT8) "PROCEDURE",
        (pANTLR3_UINT8) "RUN",
        (pANTLR3_UINT8) "SCOPE",
        (pANTLR3_UINT8) "SEND",
        (pANTLR3_UINT8) "SIMULATION",
        (pANTLR3_UINT8) "STOP",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SUBMODULE",
        (pANTLR3_UINT8) "SUBMODULE_ARRAY",
        (pANTLR3_UINT8) "THEN",
        (pANTLR3_UINT8) "THIS_CYCLE",
        (pANTLR3_UINT8) "THIS_PHASE",
        (pANTLR3_UINT8) "TO",
        (pANTLR3_UINT8) "UNICODE_ESC",
        (pANTLR3_UINT8) "UNTIL",
        (pANTLR3_UINT8) "WAIT",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WIDTH",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'||'"
       };


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_topStack
 */
void
psitarParser_topPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(top)->free != NULL)
	{
        SCOPE_TOP(top)->free(SCOPE_TOP(top));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_topStack_limit--;
    SCOPE_TOP(top) = (psitarParser_top_SCOPE)(ctx->psitarParser_topStack->get(ctx->psitarParser_topStack, ctx->psitarParser_topStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_duStack
 */
void
psitarParser_duPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(du)->free != NULL)
	{
        SCOPE_TOP(du)->free(SCOPE_TOP(du));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_duStack_limit--;
    SCOPE_TOP(du) = (psitarParser_du_SCOPE)(ctx->psitarParser_duStack->get(ctx->psitarParser_duStack, ctx->psitarParser_duStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_port_declarationStack
 */
void
psitarParser_port_declarationPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(port_declaration)->free != NULL)
	{
        SCOPE_TOP(port_declaration)->free(SCOPE_TOP(port_declaration));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_port_declarationStack_limit--;
    SCOPE_TOP(port_declaration) = (psitarParser_port_declaration_SCOPE)(ctx->psitarParser_port_declarationStack->get(ctx->psitarParser_port_declarationStack, ctx->psitarParser_port_declarationStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_net_declarationStack
 */
void
psitarParser_net_declarationPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(net_declaration)->free != NULL)
	{
        SCOPE_TOP(net_declaration)->free(SCOPE_TOP(net_declaration));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_net_declarationStack_limit--;
    SCOPE_TOP(net_declaration) = (psitarParser_net_declaration_SCOPE)(ctx->psitarParser_net_declarationStack->get(ctx->psitarParser_net_declarationStack, ctx->psitarParser_net_declarationStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_cfStack
 */
void
psitarParser_cfPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(cf)->free != NULL)
	{
        SCOPE_TOP(cf)->free(SCOPE_TOP(cf));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_cfStack_limit--;
    SCOPE_TOP(cf) = (psitarParser_cf_SCOPE)(ctx->psitarParser_cfStack->get(ctx->psitarParser_cfStack, ctx->psitarParser_cfStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_statementStack
 */
void
psitarParser_statementPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(statement)->free != NULL)
	{
        SCOPE_TOP(statement)->free(SCOPE_TOP(statement));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_statementStack_limit--;
    SCOPE_TOP(statement) = (psitarParser_statement_SCOPE)(ctx->psitarParser_statementStack->get(ctx->psitarParser_statementStack, ctx->psitarParser_statementStack_limit - 1));
}



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	top    (psitarParser ctx);
static 
 void
	design_unit    (psitarParser ctx);
static 
 void
	du    (psitarParser ctx);
static 
 void
	module_definition    (psitarParser ctx);
static 
 void
	procedure_definition    (psitarParser ctx);
static 
 void
	module_body    (psitarParser ctx);
static 
 void
	procedure_body    (psitarParser ctx);
static 
 void
	code_block_regions    (psitarParser ctx);
static 
 void
	include_block    (psitarParser ctx);
static 
 void
	declaration_block    (psitarParser ctx);
static 
 void
	initialization_block    (psitarParser ctx);
static 
 void
	structural_component_declaration    (psitarParser ctx);
static 
 void
	parameter_declaration_region    (psitarParser ctx);
static 
 void
	parameter_declaration    (psitarParser ctx);
static 
 sitarParser_param_type_return
	param_type    (psitarParser ctx);
static 
 sitarParser_default_value_return
	default_value    (psitarParser ctx);
static 
 void
	integer    (psitarParser ctx);
static 
 void
	port_declaration    (psitarParser ctx);
static 
 void
	inport_declaration    (psitarParser ctx);
static 
 void
	inport_array_declaration    (psitarParser ctx);
static 
 void
	outport_declaration    (psitarParser ctx);
static 
 void
	outport_array_declaration    (psitarParser ctx);
static 
 void
	net_declaration    (psitarParser ctx);
static 
 void
	simple_net_declaration    (psitarParser ctx);
static 
 void
	net_array_declaration    (psitarParser ctx);
static 
 void
	submodule_declaration    (psitarParser ctx);
static 
 void
	simple_submodule_declaration    (psitarParser ctx);
static 
 sitarParser_template_arguments_return
	template_arguments    (psitarParser ctx);
static 
 void
	argument    (psitarParser ctx);
static 
 void
	submodule_array_declaration    (psitarParser ctx);
static 
 void
	procedure_declaration    (psitarParser ctx);
static 
 void
	connection    (psitarParser ctx);
static 
 void
	simple_connect_statement    (psitarParser ctx);
static 
 sitarParser_port_instance_name_return
	port_instance_name    (psitarParser ctx);
static 
 sitarParser_net_instance_name_return
	net_instance_name    (psitarParser ctx);
static 
 void
	hierarchical_instance_name    (psitarParser ctx);
static 
 void
	object_name    (psitarParser ctx);
static 
 void
	for_loop_for_connections    (psitarParser ctx);
static 
 sitarParser_expression_return
	expression    (psitarParser ctx);
static 
 void
	term    (psitarParser ctx);
static 
 void
	signed_expression    (psitarParser ctx);
static 
 void
	atomic_expression    (psitarParser ctx);
static 
 void
	behavior_block    (psitarParser ctx);
static 
 void
	cf    (psitarParser ctx);
static 
 int
	sequence    (psitarParser ctx, int p);
static 
 int
	statement    (psitarParser ctx, int p_, int k_);
static 
 void
	atomic_statement    (psitarParser ctx);
static 
 void
	code_block_statement    (psitarParser ctx);
static 
 void
	behavior_code_block_statement    (psitarParser ctx);
static 
 void
	declaration_block_statement    (psitarParser ctx);
static 
 void
	initialization_block_statement    (psitarParser ctx);
static 
 void
	includes_block_statement    (psitarParser ctx);
static 
 void
	nothing_statement    (psitarParser ctx);
static 
 void
	wait_statement    (psitarParser ctx);
static 
 void
	wait_until    (psitarParser ctx);
static 
 void
	wait_for_time    (psitarParser ctx);
static 
 void
	single_wait    (psitarParser ctx);
static 
 void
	stop_statement    (psitarParser ctx);
static 
 void
	stop_behavior    (psitarParser ctx);
static 
 void
	stop_simulation    (psitarParser ctx);
static 
 void
	run_procedure_statement    (psitarParser ctx);
static 
 void
	compound_statement    (psitarParser ctx);
static 
 void
	if_statement    (psitarParser ctx);
static 
 void
	do_while_statement    (psitarParser ctx);
static 
 void
	parallel_statement    (psitarParser ctx);
static 
 std::string
	expression_cf    (psitarParser ctx);
static 
 std::string
	exp1    (psitarParser ctx);
static 
 std::string
	exp2    (psitarParser ctx);
static 
 std::string
	exp3    (psitarParser ctx);
static 
 std::string
	exp4    (psitarParser ctx);
static 
 std::string
	exp5    (psitarParser ctx);
static 
 std::string
	exp6    (psitarParser ctx);
static 
 sitarParser_comparison_operator_return
	comparison_operator    (psitarParser ctx);
static 
 sitarParser_add_operator_return
	add_operator    (psitarParser ctx);
static 
 sitarParser_mul_operator_return
	mul_operator    (psitarParser ctx);
static 
 std::string
	atomic_expression_cf    (psitarParser ctx);
static 
 sitarParser_expression_code_block_return
	expression_code_block    (psitarParser ctx);
static 
 sitarParser_function_call_return
	function_call    (psitarParser ctx);
static 
 std::string
	argument_list    (psitarParser ctx);
static 
 std::string
	this_cycle    (psitarParser ctx);
static 
 std::string
	this_phase    (psitarParser ctx);
static 
 sitarParser_code_block_with_info_return
	code_block_with_info    (psitarParser ctx);
static 
 sitarParser_code_block_return
	code_block    (psitarParser ctx);
static 
 sitarParser_identifier_return
	identifier    (psitarParser ctx);
static void	sitarParserFree(psitarParser ctx);
static void     sitarParserReset (psitarParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/project/sitarV2/translator/grammar/sitar.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new sitarParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API psitarParser
sitarParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return sitarParserNewSSD(instream, NULL);
}

/** \brief Create a new sitarParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API psitarParser
sitarParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    psitarParser ctx;	    /* Context structure we will build and return   */

    ctx	= (psitarParser) ANTLR3_CALLOC(1, sizeof(sitarParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in sitarParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our sitarParser interface
     */
    ctx->top	= top;
    ctx->design_unit	= design_unit;
    ctx->du	= du;
    ctx->module_definition	= module_definition;
    ctx->procedure_definition	= procedure_definition;
    ctx->module_body	= module_body;
    ctx->procedure_body	= procedure_body;
    ctx->code_block_regions	= code_block_regions;
    ctx->include_block	= include_block;
    ctx->declaration_block	= declaration_block;
    ctx->initialization_block	= initialization_block;
    ctx->structural_component_declaration	= structural_component_declaration;
    ctx->parameter_declaration_region	= parameter_declaration_region;
    ctx->parameter_declaration	= parameter_declaration;
    ctx->param_type	= param_type;
    ctx->default_value	= default_value;
    ctx->integer	= integer;
    ctx->port_declaration	= port_declaration;
    ctx->inport_declaration	= inport_declaration;
    ctx->inport_array_declaration	= inport_array_declaration;
    ctx->outport_declaration	= outport_declaration;
    ctx->outport_array_declaration	= outport_array_declaration;
    ctx->net_declaration	= net_declaration;
    ctx->simple_net_declaration	= simple_net_declaration;
    ctx->net_array_declaration	= net_array_declaration;
    ctx->submodule_declaration	= submodule_declaration;
    ctx->simple_submodule_declaration	= simple_submodule_declaration;
    ctx->template_arguments	= template_arguments;
    ctx->argument	= argument;
    ctx->submodule_array_declaration	= submodule_array_declaration;
    ctx->procedure_declaration	= procedure_declaration;
    ctx->connection	= connection;
    ctx->simple_connect_statement	= simple_connect_statement;
    ctx->port_instance_name	= port_instance_name;
    ctx->net_instance_name	= net_instance_name;
    ctx->hierarchical_instance_name	= hierarchical_instance_name;
    ctx->object_name	= object_name;
    ctx->for_loop_for_connections	= for_loop_for_connections;
    ctx->expression	= expression;
    ctx->term	= term;
    ctx->signed_expression	= signed_expression;
    ctx->atomic_expression	= atomic_expression;
    ctx->behavior_block	= behavior_block;
    ctx->cf	= cf;
    ctx->sequence	= sequence;
    ctx->statement	= statement;
    ctx->atomic_statement	= atomic_statement;
    ctx->code_block_statement	= code_block_statement;
    ctx->behavior_code_block_statement	= behavior_code_block_statement;
    ctx->declaration_block_statement	= declaration_block_statement;
    ctx->initialization_block_statement	= initialization_block_statement;
    ctx->includes_block_statement	= includes_block_statement;
    ctx->nothing_statement	= nothing_statement;
    ctx->wait_statement	= wait_statement;
    ctx->wait_until	= wait_until;
    ctx->wait_for_time	= wait_for_time;
    ctx->single_wait	= single_wait;
    ctx->stop_statement	= stop_statement;
    ctx->stop_behavior	= stop_behavior;
    ctx->stop_simulation	= stop_simulation;
    ctx->run_procedure_statement	= run_procedure_statement;
    ctx->compound_statement	= compound_statement;
    ctx->if_statement	= if_statement;
    ctx->do_while_statement	= do_while_statement;
    ctx->parallel_statement	= parallel_statement;
    ctx->expression_cf	= expression_cf;
    ctx->exp1	= exp1;
    ctx->exp2	= exp2;
    ctx->exp3	= exp3;
    ctx->exp4	= exp4;
    ctx->exp5	= exp5;
    ctx->exp6	= exp6;
    ctx->comparison_operator	= comparison_operator;
    ctx->add_operator	= add_operator;
    ctx->mul_operator	= mul_operator;
    ctx->atomic_expression_cf	= atomic_expression_cf;
    ctx->expression_code_block	= expression_code_block;
    ctx->function_call	= function_call;
    ctx->argument_list	= argument_list;
    ctx->this_cycle	= this_cycle;
    ctx->this_phase	= this_phase;
    ctx->code_block_with_info	= code_block_with_info;
    ctx->code_block	= code_block;
    ctx->identifier	= identifier;
    ctx->free			= sitarParserFree;
    ctx->reset			= sitarParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_topPush     = psitarParser_topPush;
    ctx->psitarParser_topStack    = antlr3StackNew(0);
    ctx->psitarParser_topStack_limit    = 0;
    ctx->psitarParser_topTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_duPush     = psitarParser_duPush;
    ctx->psitarParser_duStack    = antlr3StackNew(0);
    ctx->psitarParser_duStack_limit    = 0;
    ctx->psitarParser_duTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_port_declarationPush     = psitarParser_port_declarationPush;
    ctx->psitarParser_port_declarationStack    = antlr3StackNew(0);
    ctx->psitarParser_port_declarationStack_limit    = 0;
    ctx->psitarParser_port_declarationTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_net_declarationPush     = psitarParser_net_declarationPush;
    ctx->psitarParser_net_declarationStack    = antlr3StackNew(0);
    ctx->psitarParser_net_declarationStack_limit    = 0;
    ctx->psitarParser_net_declarationTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_cfPush     = psitarParser_cfPush;
    ctx->psitarParser_cfStack    = antlr3StackNew(0);
    ctx->psitarParser_cfStack_limit    = 0;
    ctx->psitarParser_cfTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_statementPush     = psitarParser_statementPush;
    ctx->psitarParser_statementStack    = antlr3StackNew(0);
    ctx->psitarParser_statementStack_limit    = 0;
    ctx->psitarParser_statementTop      = NULL;





    	ctx->_globalData= NULL;
    	ctx->_codeGen= NULL;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = sitarParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
sitarParserReset (psitarParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 sitarParserFree(psitarParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_topStack->free(ctx->psitarParser_topStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_duStack->free(ctx->psitarParser_duStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_port_declarationStack->free(ctx->psitarParser_port_declarationStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_net_declarationStack->free(ctx->psitarParser_net_declarationStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_cfStack->free(ctx->psitarParser_cfStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_statementStack->free(ctx->psitarParser_statementStack);



	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return sitarParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_design_unit_in_top578  */
static	ANTLR3_BITWORD FOLLOW_design_unit_in_top578_bits[]	= { ANTLR3_UINT64_LIT(0x0008008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_design_unit_in_top578	= { FOLLOW_design_unit_in_top578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_top599  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_top599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_top599	= { FOLLOW_EOF_in_top599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_du_in_design_unit619  */
static	ANTLR3_BITWORD FOLLOW_du_in_design_unit619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_du_in_design_unit619	= { FOLLOW_du_in_design_unit619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_module_definition_in_du657  */
static	ANTLR3_BITWORD FOLLOW_module_definition_in_du657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_module_definition_in_du657	= { FOLLOW_module_definition_in_du657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_definition_in_du673  */
static	ANTLR3_BITWORD FOLLOW_procedure_definition_in_du673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_definition_in_du673	= { FOLLOW_procedure_definition_in_du673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MODULE_in_module_definition705  */
static	ANTLR3_BITWORD FOLLOW_MODULE_in_module_definition705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MODULE_in_module_definition705	= { FOLLOW_MODULE_in_module_definition705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_module_definition710  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_module_definition710_bits[]	= { ANTLR3_UINT64_LIT(0x0C09C301E5110040) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_module_definition710	= { FOLLOW_IDENTIFIER_in_module_definition710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_module_body_in_module_definition721  */
static	ANTLR3_BITWORD FOLLOW_module_body_in_module_definition721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_module_body_in_module_definition721	= { FOLLOW_module_body_in_module_definition721_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_module_definition725  */
static	ANTLR3_BITWORD FOLLOW_END_in_module_definition725_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_module_definition725	= { FOLLOW_END_in_module_definition725_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MODULE_in_module_definition727  */
static	ANTLR3_BITWORD FOLLOW_MODULE_in_module_definition727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MODULE_in_module_definition727	= { FOLLOW_MODULE_in_module_definition727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROCEDURE_in_procedure_definition758  */
static	ANTLR3_BITWORD FOLLOW_PROCEDURE_in_procedure_definition758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PROCEDURE_in_procedure_definition758	= { FOLLOW_PROCEDURE_in_procedure_definition758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_definition763  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_definition763_bits[]	= { ANTLR3_UINT64_LIT(0x0009000060110040) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_definition763	= { FOLLOW_IDENTIFIER_in_procedure_definition763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_body_in_procedure_definition775  */
static	ANTLR3_BITWORD FOLLOW_procedure_body_in_procedure_definition775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_body_in_procedure_definition775	= { FOLLOW_procedure_body_in_procedure_definition775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_procedure_definition779  */
static	ANTLR3_BITWORD FOLLOW_END_in_procedure_definition779_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_procedure_definition779	= { FOLLOW_END_in_procedure_definition779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROCEDURE_in_procedure_definition781  */
static	ANTLR3_BITWORD FOLLOW_PROCEDURE_in_procedure_definition781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PROCEDURE_in_procedure_definition781	= { FOLLOW_PROCEDURE_in_procedure_definition781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_region_in_module_body833  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_region_in_module_body833_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_region_in_module_body833	= { FOLLOW_parameter_declaration_region_in_module_body833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_module_body868  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_module_body868_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_module_body868	= { FOLLOW_code_block_regions_in_module_body868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structural_component_declaration_in_module_body872  */
static	ANTLR3_BITWORD FOLLOW_structural_component_declaration_in_module_body872_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_structural_component_declaration_in_module_body872	= { FOLLOW_structural_component_declaration_in_module_body872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_declaration_in_module_body875  */
static	ANTLR3_BITWORD FOLLOW_procedure_declaration_in_module_body875_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_declaration_in_module_body875	= { FOLLOW_procedure_declaration_in_module_body875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_behavior_block_in_module_body886  */
static	ANTLR3_BITWORD FOLLOW_behavior_block_in_module_body886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_behavior_block_in_module_body886	= { FOLLOW_behavior_block_in_module_body886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_module_body890  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_module_body890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_module_body890	= { FOLLOW_code_block_regions_in_module_body890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_region_in_procedure_body934  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_region_in_procedure_body934_bits[]	= { ANTLR3_UINT64_LIT(0x0008000060010042) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_region_in_procedure_body934	= { FOLLOW_parameter_declaration_region_in_procedure_body934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_procedure_body953  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_procedure_body953_bits[]	= { ANTLR3_UINT64_LIT(0x0008000060010042) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_procedure_body953	= { FOLLOW_code_block_regions_in_procedure_body953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_declaration_in_procedure_body957  */
static	ANTLR3_BITWORD FOLLOW_procedure_declaration_in_procedure_body957_bits[]	= { ANTLR3_UINT64_LIT(0x0008000060010042) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_declaration_in_procedure_body957	= { FOLLOW_procedure_declaration_in_procedure_body957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_behavior_block_in_procedure_body988  */
static	ANTLR3_BITWORD FOLLOW_behavior_block_in_procedure_body988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_behavior_block_in_procedure_body988	= { FOLLOW_behavior_block_in_procedure_body988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_procedure_body992  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_procedure_body992_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_procedure_body992	= { FOLLOW_code_block_regions_in_procedure_body992_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_include_block_in_code_block_regions1014  */
static	ANTLR3_BITWORD FOLLOW_include_block_in_code_block_regions1014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_include_block_in_code_block_regions1014	= { FOLLOW_include_block_in_code_block_regions1014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_block_in_code_block_regions1019  */
static	ANTLR3_BITWORD FOLLOW_declaration_block_in_code_block_regions1019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_block_in_code_block_regions1019	= { FOLLOW_declaration_block_in_code_block_regions1019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initialization_block_in_code_block_regions1024  */
static	ANTLR3_BITWORD FOLLOW_initialization_block_in_code_block_regions1024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_initialization_block_in_code_block_regions1024	= { FOLLOW_initialization_block_in_code_block_regions1024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_in_include_block1034  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_in_include_block1034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_in_include_block1034	= { FOLLOW_INCLUDE_in_include_block1034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_include_block1038  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_include_block1038_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_include_block1038	= { FOLLOW_code_block_with_info_in_include_block1038_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECL_in_declaration_block1051  */
static	ANTLR3_BITWORD FOLLOW_DECL_in_declaration_block1051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECL_in_declaration_block1051	= { FOLLOW_DECL_in_declaration_block1051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_declaration_block1055  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_declaration_block1055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_declaration_block1055	= { FOLLOW_code_block_with_info_in_declaration_block1055_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INIT_in_initialization_block1068  */
static	ANTLR3_BITWORD FOLLOW_INIT_in_initialization_block1068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INIT_in_initialization_block1068	= { FOLLOW_INIT_in_initialization_block1068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_initialization_block1072  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_initialization_block1072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_initialization_block1072	= { FOLLOW_code_block_with_info_in_initialization_block1072_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_declaration_in_structural_component_declaration1100  */
static	ANTLR3_BITWORD FOLLOW_port_declaration_in_structural_component_declaration1100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_port_declaration_in_structural_component_declaration1100	= { FOLLOW_port_declaration_in_structural_component_declaration1100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_net_declaration_in_structural_component_declaration1106  */
static	ANTLR3_BITWORD FOLLOW_net_declaration_in_structural_component_declaration1106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_net_declaration_in_structural_component_declaration1106	= { FOLLOW_net_declaration_in_structural_component_declaration1106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_submodule_declaration_in_structural_component_declaration1112  */
static	ANTLR3_BITWORD FOLLOW_submodule_declaration_in_structural_component_declaration1112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_submodule_declaration_in_structural_component_declaration1112	= { FOLLOW_submodule_declaration_in_structural_component_declaration1112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connection_in_structural_component_declaration1118  */
static	ANTLR3_BITWORD FOLLOW_connection_in_structural_component_declaration1118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_connection_in_structural_component_declaration1118	= { FOLLOW_connection_in_structural_component_declaration1118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_in_parameter_declaration_region1146  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_in_parameter_declaration_region1146_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_in_parameter_declaration_region1146	= { FOLLOW_parameter_declaration_in_parameter_declaration_region1146_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_parameter_declaration_region1148  */
static	ANTLR3_BITWORD FOLLOW_77_in_parameter_declaration_region1148_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_parameter_declaration_region1148	= { FOLLOW_77_in_parameter_declaration_region1148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAMETER_in_parameter_declaration1168  */
static	ANTLR3_BITWORD FOLLOW_PARAMETER_in_parameter_declaration1168_bits[]	= { ANTLR3_UINT64_LIT(0x0000001C00000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAMETER_in_parameter_declaration1168	= { FOLLOW_PARAMETER_in_parameter_declaration1168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_type_in_parameter_declaration1172  */
static	ANTLR3_BITWORD FOLLOW_param_type_in_parameter_declaration1172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_type_in_parameter_declaration1172	= { FOLLOW_param_type_in_parameter_declaration1172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_parameter_declaration1176  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_parameter_declaration1176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_parameter_declaration1176	= { FOLLOW_IDENTIFIER_in_parameter_declaration1176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_parameter_declaration1179  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_parameter_declaration1179_bits[]	= { ANTLR3_UINT64_LIT(0x0000004200000280) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_parameter_declaration1179	= { FOLLOW_EQUALS_in_parameter_declaration1179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_default_value_in_parameter_declaration1183  */
static	ANTLR3_BITWORD FOLLOW_default_value_in_parameter_declaration1183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_default_value_in_parameter_declaration1183	= { FOLLOW_default_value_in_parameter_declaration1183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_default_value1227  */
static	ANTLR3_BITWORD FOLLOW_integer_in_default_value1227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_default_value1227	= { FOLLOW_integer_in_default_value1227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_in_default_value1231  */
static	ANTLR3_BITWORD FOLLOW_BOOL_in_default_value1231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOL_in_default_value1231	= { FOLLOW_BOOL_in_default_value1231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHAR_in_default_value1235  */
static	ANTLR3_BITWORD FOLLOW_CHAR_in_default_value1235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHAR_in_default_value1235	= { FOLLOW_CHAR_in_default_value1235_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_integer1247  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_integer1247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_integer1247	= { FOLLOW_MINUS_in_integer1247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_integer1250  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_integer1250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_integer1250	= { FOLLOW_INTEGER_in_integer1250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inport_declaration_in_port_declaration1278  */
static	ANTLR3_BITWORD FOLLOW_inport_declaration_in_port_declaration1278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_inport_declaration_in_port_declaration1278	= { FOLLOW_inport_declaration_in_port_declaration1278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inport_array_declaration_in_port_declaration1283  */
static	ANTLR3_BITWORD FOLLOW_inport_array_declaration_in_port_declaration1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_inport_array_declaration_in_port_declaration1283	= { FOLLOW_inport_array_declaration_in_port_declaration1283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_outport_declaration_in_port_declaration1288  */
static	ANTLR3_BITWORD FOLLOW_outport_declaration_in_port_declaration1288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_outport_declaration_in_port_declaration1288	= { FOLLOW_outport_declaration_in_port_declaration1288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_outport_array_declaration_in_port_declaration1293  */
static	ANTLR3_BITWORD FOLLOW_outport_array_declaration_in_port_declaration1293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_outport_array_declaration_in_port_declaration1293	= { FOLLOW_outport_array_declaration_in_port_declaration1293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INPORT_in_inport_declaration1318  */
static	ANTLR3_BITWORD FOLLOW_INPORT_in_inport_declaration1318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INPORT_in_inport_declaration1318	= { FOLLOW_INPORT_in_inport_declaration1318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_inport_declaration1322  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_inport_declaration1322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_inport_declaration1322	= { FOLLOW_IDENTIFIER_in_inport_declaration1322_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_inport_declaration1334  */
static	ANTLR3_BITWORD FOLLOW_75_in_inport_declaration1334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_inport_declaration1334	= { FOLLOW_75_in_inport_declaration1334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_inport_declaration1338  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_inport_declaration1338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_inport_declaration1338	= { FOLLOW_IDENTIFIER_in_inport_declaration1338_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_inport_declaration1352  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_inport_declaration1352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_inport_declaration1352	= { FOLLOW_COLON_in_inport_declaration1352_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_inport_declaration1354  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_inport_declaration1354_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_inport_declaration1354	= { FOLLOW_WIDTH_in_inport_declaration1354_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_declaration1358  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_declaration1358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_declaration1358	= { FOLLOW_expression_in_inport_declaration1358_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INPORT_ARRAY_in_inport_array_declaration1394  */
static	ANTLR3_BITWORD FOLLOW_INPORT_ARRAY_in_inport_array_declaration1394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INPORT_ARRAY_in_inport_array_declaration1394	= { FOLLOW_INPORT_ARRAY_in_inport_array_declaration1394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_inport_array_declaration1398  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_inport_array_declaration1398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_inport_array_declaration1398	= { FOLLOW_IDENTIFIER_in_inport_array_declaration1398_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_inport_array_declaration1400  */
static	ANTLR3_BITWORD FOLLOW_82_in_inport_array_declaration1400_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_inport_array_declaration1400	= { FOLLOW_82_in_inport_array_declaration1400_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_array_declaration1404  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_array_declaration1404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_array_declaration1404	= { FOLLOW_expression_in_inport_array_declaration1404_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_inport_array_declaration1407  */
static	ANTLR3_BITWORD FOLLOW_83_in_inport_array_declaration1407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_inport_array_declaration1407	= { FOLLOW_83_in_inport_array_declaration1407_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_inport_array_declaration1420  */
static	ANTLR3_BITWORD FOLLOW_82_in_inport_array_declaration1420_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_inport_array_declaration1420	= { FOLLOW_82_in_inport_array_declaration1420_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_array_declaration1424  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_array_declaration1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_array_declaration1424	= { FOLLOW_expression_in_inport_array_declaration1424_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_inport_array_declaration1428  */
static	ANTLR3_BITWORD FOLLOW_83_in_inport_array_declaration1428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_inport_array_declaration1428	= { FOLLOW_83_in_inport_array_declaration1428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_inport_array_declaration1434  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_inport_array_declaration1434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_inport_array_declaration1434	= { FOLLOW_COLON_in_inport_array_declaration1434_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_inport_array_declaration1436  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_inport_array_declaration1436_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_inport_array_declaration1436	= { FOLLOW_WIDTH_in_inport_array_declaration1436_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_array_declaration1440  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_array_declaration1440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_array_declaration1440	= { FOLLOW_expression_in_inport_array_declaration1440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OUTPORT_in_outport_declaration1472  */
static	ANTLR3_BITWORD FOLLOW_OUTPORT_in_outport_declaration1472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OUTPORT_in_outport_declaration1472	= { FOLLOW_OUTPORT_in_outport_declaration1472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_outport_declaration1476  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_outport_declaration1476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_outport_declaration1476	= { FOLLOW_IDENTIFIER_in_outport_declaration1476_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_outport_declaration1488  */
static	ANTLR3_BITWORD FOLLOW_75_in_outport_declaration1488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_outport_declaration1488	= { FOLLOW_75_in_outport_declaration1488_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_outport_declaration1492  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_outport_declaration1492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_outport_declaration1492	= { FOLLOW_IDENTIFIER_in_outport_declaration1492_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_outport_declaration1506  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_outport_declaration1506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_outport_declaration1506	= { FOLLOW_COLON_in_outport_declaration1506_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_outport_declaration1508  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_outport_declaration1508_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_outport_declaration1508	= { FOLLOW_WIDTH_in_outport_declaration1508_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_declaration1512  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_declaration1512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_declaration1512	= { FOLLOW_expression_in_outport_declaration1512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1546  */
static	ANTLR3_BITWORD FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1546	= { FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_outport_array_declaration1550  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_outport_array_declaration1550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_outport_array_declaration1550	= { FOLLOW_IDENTIFIER_in_outport_array_declaration1550_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_outport_array_declaration1552  */
static	ANTLR3_BITWORD FOLLOW_82_in_outport_array_declaration1552_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_outport_array_declaration1552	= { FOLLOW_82_in_outport_array_declaration1552_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_array_declaration1556  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_array_declaration1556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_array_declaration1556	= { FOLLOW_expression_in_outport_array_declaration1556_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_outport_array_declaration1559  */
static	ANTLR3_BITWORD FOLLOW_83_in_outport_array_declaration1559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_outport_array_declaration1559	= { FOLLOW_83_in_outport_array_declaration1559_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_outport_array_declaration1572  */
static	ANTLR3_BITWORD FOLLOW_82_in_outport_array_declaration1572_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_outport_array_declaration1572	= { FOLLOW_82_in_outport_array_declaration1572_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_array_declaration1576  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_array_declaration1576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_array_declaration1576	= { FOLLOW_expression_in_outport_array_declaration1576_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_outport_array_declaration1580  */
static	ANTLR3_BITWORD FOLLOW_83_in_outport_array_declaration1580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_outport_array_declaration1580	= { FOLLOW_83_in_outport_array_declaration1580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_outport_array_declaration1587  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_outport_array_declaration1587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_outport_array_declaration1587	= { FOLLOW_COLON_in_outport_array_declaration1587_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_outport_array_declaration1589  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_outport_array_declaration1589_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_outport_array_declaration1589	= { FOLLOW_WIDTH_in_outport_array_declaration1589_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_array_declaration1593  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_array_declaration1593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_array_declaration1593	= { FOLLOW_expression_in_outport_array_declaration1593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_net_declaration_in_net_declaration1632  */
static	ANTLR3_BITWORD FOLLOW_simple_net_declaration_in_net_declaration1632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_net_declaration_in_net_declaration1632	= { FOLLOW_simple_net_declaration_in_net_declaration1632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_net_array_declaration_in_net_declaration1637  */
static	ANTLR3_BITWORD FOLLOW_net_array_declaration_in_net_declaration1637_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_net_array_declaration_in_net_declaration1637	= { FOLLOW_net_array_declaration_in_net_declaration1637_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NET_in_simple_net_declaration1662  */
static	ANTLR3_BITWORD FOLLOW_NET_in_simple_net_declaration1662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NET_in_simple_net_declaration1662	= { FOLLOW_NET_in_simple_net_declaration1662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_net_declaration1667  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_net_declaration1667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_net_declaration1667	= { FOLLOW_IDENTIFIER_in_simple_net_declaration1667_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_simple_net_declaration1679  */
static	ANTLR3_BITWORD FOLLOW_75_in_simple_net_declaration1679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_simple_net_declaration1679	= { FOLLOW_75_in_simple_net_declaration1679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_net_declaration1683  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_net_declaration1683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_net_declaration1683	= { FOLLOW_IDENTIFIER_in_simple_net_declaration1683_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_simple_net_declaration1701  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_simple_net_declaration1701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_simple_net_declaration1701	= { FOLLOW_COLON_in_simple_net_declaration1701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CAPACITY_in_simple_net_declaration1703  */
static	ANTLR3_BITWORD FOLLOW_CAPACITY_in_simple_net_declaration1703_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_CAPACITY_in_simple_net_declaration1703	= { FOLLOW_CAPACITY_in_simple_net_declaration1703_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_simple_net_declaration1708  */
static	ANTLR3_BITWORD FOLLOW_expression_in_simple_net_declaration1708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_simple_net_declaration1708	= { FOLLOW_expression_in_simple_net_declaration1708_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_simple_net_declaration1715  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_simple_net_declaration1715_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_simple_net_declaration1715	= { FOLLOW_WIDTH_in_simple_net_declaration1715_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_simple_net_declaration1719  */
static	ANTLR3_BITWORD FOLLOW_expression_in_simple_net_declaration1719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_simple_net_declaration1719	= { FOLLOW_expression_in_simple_net_declaration1719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NET_ARRAY_in_net_array_declaration1752  */
static	ANTLR3_BITWORD FOLLOW_NET_ARRAY_in_net_array_declaration1752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NET_ARRAY_in_net_array_declaration1752	= { FOLLOW_NET_ARRAY_in_net_array_declaration1752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_net_array_declaration1756  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_net_array_declaration1756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_net_array_declaration1756	= { FOLLOW_IDENTIFIER_in_net_array_declaration1756_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_net_array_declaration1758  */
static	ANTLR3_BITWORD FOLLOW_82_in_net_array_declaration1758_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_net_array_declaration1758	= { FOLLOW_82_in_net_array_declaration1758_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1762  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1762	= { FOLLOW_expression_in_net_array_declaration1762_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_net_array_declaration1765  */
static	ANTLR3_BITWORD FOLLOW_83_in_net_array_declaration1765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_net_array_declaration1765	= { FOLLOW_83_in_net_array_declaration1765_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_net_array_declaration1778  */
static	ANTLR3_BITWORD FOLLOW_82_in_net_array_declaration1778_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_net_array_declaration1778	= { FOLLOW_82_in_net_array_declaration1778_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1782  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1782	= { FOLLOW_expression_in_net_array_declaration1782_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_net_array_declaration1786  */
static	ANTLR3_BITWORD FOLLOW_83_in_net_array_declaration1786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_net_array_declaration1786	= { FOLLOW_83_in_net_array_declaration1786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_net_array_declaration1790  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_net_array_declaration1790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_net_array_declaration1790	= { FOLLOW_COLON_in_net_array_declaration1790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CAPACITY_in_net_array_declaration1792  */
static	ANTLR3_BITWORD FOLLOW_CAPACITY_in_net_array_declaration1792_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_CAPACITY_in_net_array_declaration1792	= { FOLLOW_CAPACITY_in_net_array_declaration1792_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1796  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1796_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1796	= { FOLLOW_expression_in_net_array_declaration1796_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_net_array_declaration1808  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_net_array_declaration1808_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_net_array_declaration1808	= { FOLLOW_WIDTH_in_net_array_declaration1808_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1812  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1812	= { FOLLOW_expression_in_net_array_declaration1812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_submodule_declaration_in_submodule_declaration1834  */
static	ANTLR3_BITWORD FOLLOW_simple_submodule_declaration_in_submodule_declaration1834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_submodule_declaration_in_submodule_declaration1834	= { FOLLOW_simple_submodule_declaration_in_submodule_declaration1834_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_submodule_array_declaration_in_submodule_declaration1839  */
static	ANTLR3_BITWORD FOLLOW_submodule_array_declaration_in_submodule_declaration1839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_submodule_array_declaration_in_submodule_declaration1839	= { FOLLOW_submodule_array_declaration_in_submodule_declaration1839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SUBMODULE_in_simple_submodule_declaration1863  */
static	ANTLR3_BITWORD FOLLOW_SUBMODULE_in_simple_submodule_declaration1863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SUBMODULE_in_simple_submodule_declaration1863	= { FOLLOW_SUBMODULE_in_simple_submodule_declaration1863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_submodule_declaration1867  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_submodule_declaration1867_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_submodule_declaration1867	= { FOLLOW_IDENTIFIER_in_simple_submodule_declaration1867_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_simple_submodule_declaration1879  */
static	ANTLR3_BITWORD FOLLOW_75_in_simple_submodule_declaration1879_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_simple_submodule_declaration1879	= { FOLLOW_75_in_simple_submodule_declaration1879_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_submodule_declaration1883  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_submodule_declaration1883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_submodule_declaration1883	= { FOLLOW_IDENTIFIER_in_simple_submodule_declaration1883_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_simple_submodule_declaration1901  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_simple_submodule_declaration1901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_simple_submodule_declaration1901	= { FOLLOW_COLON_in_simple_submodule_declaration1901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_submodule_declaration1905  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_submodule_declaration1905_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_submodule_declaration1905	= { FOLLOW_IDENTIFIER_in_simple_submodule_declaration1905_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_simple_submodule_declaration1908  */
static	ANTLR3_BITWORD FOLLOW_78_in_simple_submodule_declaration1908_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000010100) };
static  ANTLR3_BITSET_LIST FOLLOW_78_in_simple_submodule_declaration1908	= { FOLLOW_78_in_simple_submodule_declaration1908_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_template_arguments_in_simple_submodule_declaration1911  */
static	ANTLR3_BITWORD FOLLOW_template_arguments_in_simple_submodule_declaration1911_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_template_arguments_in_simple_submodule_declaration1911	= { FOLLOW_template_arguments_in_simple_submodule_declaration1911_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_simple_submodule_declaration1916  */
static	ANTLR3_BITWORD FOLLOW_80_in_simple_submodule_declaration1916_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_80_in_simple_submodule_declaration1916	= { FOLLOW_80_in_simple_submodule_declaration1916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_template_arguments1937  */
static	ANTLR3_BITWORD FOLLOW_argument_in_template_arguments1937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_template_arguments1937	= { FOLLOW_argument_in_template_arguments1937_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_template_arguments1940  */
static	ANTLR3_BITWORD FOLLOW_75_in_template_arguments1940_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_template_arguments1940	= { FOLLOW_75_in_template_arguments1940_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_template_arguments1942  */
static	ANTLR3_BITWORD FOLLOW_argument_in_template_arguments1942_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_template_arguments1942	= { FOLLOW_argument_in_template_arguments1942_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_in_argument1956  */
static	ANTLR3_BITWORD FOLLOW_BOOL_in_argument1956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOL_in_argument1956	= { FOLLOW_BOOL_in_argument1956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHAR_in_argument1960  */
static	ANTLR3_BITWORD FOLLOW_CHAR_in_argument1960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHAR_in_argument1960	= { FOLLOW_CHAR_in_argument1960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_argument1964  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_argument1964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_argument1964	= { FOLLOW_STRING_in_argument1964_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_argument1968  */
static	ANTLR3_BITWORD FOLLOW_expression_in_argument1968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_argument1968	= { FOLLOW_expression_in_argument1968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1996  */
static	ANTLR3_BITWORD FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1996	= { FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_submodule_array_declaration2000  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_submodule_array_declaration2000_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_submodule_array_declaration2000	= { FOLLOW_IDENTIFIER_in_submodule_array_declaration2000_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_submodule_array_declaration2002  */
static	ANTLR3_BITWORD FOLLOW_82_in_submodule_array_declaration2002_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_submodule_array_declaration2002	= { FOLLOW_82_in_submodule_array_declaration2002_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_submodule_array_declaration2006  */
static	ANTLR3_BITWORD FOLLOW_expression_in_submodule_array_declaration2006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_submodule_array_declaration2006	= { FOLLOW_expression_in_submodule_array_declaration2006_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_submodule_array_declaration2009  */
static	ANTLR3_BITWORD FOLLOW_83_in_submodule_array_declaration2009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_submodule_array_declaration2009	= { FOLLOW_83_in_submodule_array_declaration2009_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_submodule_array_declaration2022  */
static	ANTLR3_BITWORD FOLLOW_82_in_submodule_array_declaration2022_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_submodule_array_declaration2022	= { FOLLOW_82_in_submodule_array_declaration2022_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_submodule_array_declaration2026  */
static	ANTLR3_BITWORD FOLLOW_expression_in_submodule_array_declaration2026_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_submodule_array_declaration2026	= { FOLLOW_expression_in_submodule_array_declaration2026_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_submodule_array_declaration2030  */
static	ANTLR3_BITWORD FOLLOW_83_in_submodule_array_declaration2030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_submodule_array_declaration2030	= { FOLLOW_83_in_submodule_array_declaration2030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_submodule_array_declaration2052  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_submodule_array_declaration2052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_submodule_array_declaration2052	= { FOLLOW_COLON_in_submodule_array_declaration2052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_submodule_array_declaration2056  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_submodule_array_declaration2056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_submodule_array_declaration2056	= { FOLLOW_IDENTIFIER_in_submodule_array_declaration2056_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_submodule_array_declaration2060  */
static	ANTLR3_BITWORD FOLLOW_78_in_submodule_array_declaration2060_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000010100) };
static  ANTLR3_BITSET_LIST FOLLOW_78_in_submodule_array_declaration2060	= { FOLLOW_78_in_submodule_array_declaration2060_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_template_arguments_in_submodule_array_declaration2065  */
static	ANTLR3_BITWORD FOLLOW_template_arguments_in_submodule_array_declaration2065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_template_arguments_in_submodule_array_declaration2065	= { FOLLOW_template_arguments_in_submodule_array_declaration2065_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_submodule_array_declaration2071  */
static	ANTLR3_BITWORD FOLLOW_80_in_submodule_array_declaration2071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_80_in_submodule_array_declaration2071	= { FOLLOW_80_in_submodule_array_declaration2071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROCEDURE_in_procedure_declaration2104  */
static	ANTLR3_BITWORD FOLLOW_PROCEDURE_in_procedure_declaration2104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PROCEDURE_in_procedure_declaration2104	= { FOLLOW_PROCEDURE_in_procedure_declaration2104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_declaration2111  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_declaration2111_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_declaration2111	= { FOLLOW_IDENTIFIER_in_procedure_declaration2111_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_procedure_declaration2123  */
static	ANTLR3_BITWORD FOLLOW_75_in_procedure_declaration2123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_procedure_declaration2123	= { FOLLOW_75_in_procedure_declaration2123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_declaration2127  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_declaration2127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_declaration2127	= { FOLLOW_IDENTIFIER_in_procedure_declaration2127_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_procedure_declaration2145  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_procedure_declaration2145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_procedure_declaration2145	= { FOLLOW_COLON_in_procedure_declaration2145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_declaration2149  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_declaration2149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_declaration2149	= { FOLLOW_IDENTIFIER_in_procedure_declaration2149_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_procedure_declaration2152  */
static	ANTLR3_BITWORD FOLLOW_78_in_procedure_declaration2152_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000010100) };
static  ANTLR3_BITSET_LIST FOLLOW_78_in_procedure_declaration2152	= { FOLLOW_78_in_procedure_declaration2152_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_template_arguments_in_procedure_declaration2155  */
static	ANTLR3_BITWORD FOLLOW_template_arguments_in_procedure_declaration2155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_template_arguments_in_procedure_declaration2155	= { FOLLOW_template_arguments_in_procedure_declaration2155_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_procedure_declaration2160  */
static	ANTLR3_BITWORD FOLLOW_80_in_procedure_declaration2160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_80_in_procedure_declaration2160	= { FOLLOW_80_in_procedure_declaration2160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_connect_statement_in_connection2188  */
static	ANTLR3_BITWORD FOLLOW_simple_connect_statement_in_connection2188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_connect_statement_in_connection2188	= { FOLLOW_simple_connect_statement_in_connection2188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_for_loop_for_connections_in_connection2194  */
static	ANTLR3_BITWORD FOLLOW_for_loop_for_connections_in_connection2194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_for_loop_for_connections_in_connection2194	= { FOLLOW_for_loop_for_connections_in_connection2194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_instance_name_in_simple_connect_statement2224  */
static	ANTLR3_BITWORD FOLLOW_port_instance_name_in_simple_connect_statement2224_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000C000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_port_instance_name_in_simple_connect_statement2224	= { FOLLOW_port_instance_name_in_simple_connect_statement2224_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_simple_connect_statement2238  */
static	ANTLR3_BITWORD FOLLOW_75_in_simple_connect_statement2238_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_simple_connect_statement2238	= { FOLLOW_75_in_simple_connect_statement2238_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_instance_name_in_simple_connect_statement2242  */
static	ANTLR3_BITWORD FOLLOW_port_instance_name_in_simple_connect_statement2242_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000C000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_port_instance_name_in_simple_connect_statement2242	= { FOLLOW_port_instance_name_in_simple_connect_statement2242_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_simple_connect_statement2259  */
static	ANTLR3_BITWORD FOLLOW_set_in_simple_connect_statement2259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_simple_connect_statement2259	= { FOLLOW_set_in_simple_connect_statement2259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_net_instance_name_in_simple_connect_statement2269  */
static	ANTLR3_BITWORD FOLLOW_net_instance_name_in_simple_connect_statement2269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_net_instance_name_in_simple_connect_statement2269	= { FOLLOW_net_instance_name_in_simple_connect_statement2269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hierarchical_instance_name_in_port_instance_name2291  */
static	ANTLR3_BITWORD FOLLOW_hierarchical_instance_name_in_port_instance_name2291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hierarchical_instance_name_in_port_instance_name2291	= { FOLLOW_hierarchical_instance_name_in_port_instance_name2291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hierarchical_instance_name_in_net_instance_name2306  */
static	ANTLR3_BITWORD FOLLOW_hierarchical_instance_name_in_net_instance_name2306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hierarchical_instance_name_in_net_instance_name2306	= { FOLLOW_hierarchical_instance_name_in_net_instance_name2306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_name_in_hierarchical_instance_name2319  */
static	ANTLR3_BITWORD FOLLOW_object_name_in_hierarchical_instance_name2319_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_name_in_hierarchical_instance_name2319	= { FOLLOW_object_name_in_hierarchical_instance_name2319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_hierarchical_instance_name2321  */
static	ANTLR3_BITWORD FOLLOW_set_in_hierarchical_instance_name2321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_hierarchical_instance_name2321	= { FOLLOW_set_in_hierarchical_instance_name2321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_name_in_hierarchical_instance_name2329  */
static	ANTLR3_BITWORD FOLLOW_object_name_in_hierarchical_instance_name2329_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_name_in_hierarchical_instance_name2329	= { FOLLOW_object_name_in_hierarchical_instance_name2329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_object_name2343  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_object_name2343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_object_name2343	= { FOLLOW_IDENTIFIER_in_object_name2343_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_object_name2346  */
static	ANTLR3_BITWORD FOLLOW_82_in_object_name2346_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_object_name2346	= { FOLLOW_82_in_object_name2346_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_object_name2347  */
static	ANTLR3_BITWORD FOLLOW_expression_in_object_name2347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_object_name2347	= { FOLLOW_expression_in_object_name2347_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_object_name2349  */
static	ANTLR3_BITWORD FOLLOW_83_in_object_name2349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_object_name2349	= { FOLLOW_83_in_object_name2349_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_object_name2352  */
static	ANTLR3_BITWORD FOLLOW_82_in_object_name2352_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_object_name2352	= { FOLLOW_82_in_object_name2352_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_object_name2353  */
static	ANTLR3_BITWORD FOLLOW_expression_in_object_name2353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_object_name2353	= { FOLLOW_expression_in_object_name2353_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_object_name2355  */
static	ANTLR3_BITWORD FOLLOW_83_in_object_name2355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_object_name2355	= { FOLLOW_83_in_object_name2355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_for_loop_for_connections2387  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_for_loop_for_connections2387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_for_loop_for_connections2387	= { FOLLOW_FOR_in_for_loop_for_connections2387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_for_loop_for_connections2391  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_for_loop_for_connections2391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_for_loop_for_connections2391	= { FOLLOW_IDENTIFIER_in_for_loop_for_connections2391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IN_in_for_loop_for_connections2393  */
static	ANTLR3_BITWORD FOLLOW_IN_in_for_loop_for_connections2393_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_IN_in_for_loop_for_connections2393	= { FOLLOW_IN_in_for_loop_for_connections2393_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_for_loop_for_connections2397  */
static	ANTLR3_BITWORD FOLLOW_expression_in_for_loop_for_connections2397_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_for_loop_for_connections2397	= { FOLLOW_expression_in_for_loop_for_connections2397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TO_in_for_loop_for_connections2399  */
static	ANTLR3_BITWORD FOLLOW_TO_in_for_loop_for_connections2399_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_TO_in_for_loop_for_connections2399	= { FOLLOW_TO_in_for_loop_for_connections2399_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_for_loop_for_connections2403  */
static	ANTLR3_BITWORD FOLLOW_expression_in_for_loop_for_connections2403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_for_loop_for_connections2403	= { FOLLOW_expression_in_for_loop_for_connections2403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connection_in_for_loop_for_connections2410  */
static	ANTLR3_BITWORD FOLLOW_connection_in_for_loop_for_connections2410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005100000) };
static  ANTLR3_BITSET_LIST FOLLOW_connection_in_for_loop_for_connections2410	= { FOLLOW_connection_in_for_loop_for_connections2410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_for_loop_for_connections2417  */
static	ANTLR3_BITWORD FOLLOW_END_in_for_loop_for_connections2417_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_for_loop_for_connections2417	= { FOLLOW_END_in_for_loop_for_connections2417_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_for_loop_for_connections2419  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_for_loop_for_connections2419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_for_loop_for_connections2419	= { FOLLOW_FOR_in_for_loop_for_connections2419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expression2462  */
static	ANTLR3_BITWORD FOLLOW_term_in_expression2462_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expression2462	= { FOLLOW_term_in_expression2462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression2465  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression2465_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression2465	= { FOLLOW_set_in_expression2465_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expression2471  */
static	ANTLR3_BITWORD FOLLOW_term_in_expression2471_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expression2471	= { FOLLOW_term_in_expression2471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signed_expression_in_term2482  */
static	ANTLR3_BITWORD FOLLOW_signed_expression_in_term2482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_signed_expression_in_term2482	= { FOLLOW_signed_expression_in_term2482_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_term2485  */
static	ANTLR3_BITWORD FOLLOW_set_in_term2485_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_term2485	= { FOLLOW_set_in_term2485_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signed_expression_in_term2493  */
static	ANTLR3_BITWORD FOLLOW_signed_expression_in_term2493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_signed_expression_in_term2493	= { FOLLOW_signed_expression_in_term2493_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_signed_expression2505  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_signed_expression2505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_signed_expression2505	= { FOLLOW_MINUS_in_signed_expression2505_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomic_expression_in_signed_expression2508  */
static	ANTLR3_BITWORD FOLLOW_atomic_expression_in_signed_expression2508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomic_expression_in_signed_expression2508	= { FOLLOW_atomic_expression_in_signed_expression2508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_atomic_expression2525  */
static	ANTLR3_BITWORD FOLLOW_72_in_atomic_expression2525_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_atomic_expression2525	= { FOLLOW_72_in_atomic_expression2525_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_atomic_expression2526  */
static	ANTLR3_BITWORD FOLLOW_expression_in_atomic_expression2526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_atomic_expression2526	= { FOLLOW_expression_in_atomic_expression2526_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_atomic_expression2527  */
static	ANTLR3_BITWORD FOLLOW_73_in_atomic_expression2527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_atomic_expression2527	= { FOLLOW_73_in_atomic_expression2527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atomic_expression2532  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atomic_expression2532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atomic_expression2532	= { FOLLOW_INTEGER_in_atomic_expression2532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_atomic_expression2537  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_atomic_expression2537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_atomic_expression2537	= { FOLLOW_IDENTIFIER_in_atomic_expression2537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cf_in_behavior_block2563  */
static	ANTLR3_BITWORD FOLLOW_cf_in_behavior_block2563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cf_in_behavior_block2563	= { FOLLOW_cf_in_behavior_block2563_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEHAVIOR_in_cf2592  */
static	ANTLR3_BITWORD FOLLOW_BEHAVIOR_in_cf2592_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_BEHAVIOR_in_cf2592	= { FOLLOW_BEHAVIOR_in_cf2592_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_cf2602  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_cf2602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_cf2602	= { FOLLOW_sequence_in_cf2602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_cf2606  */
static	ANTLR3_BITWORD FOLLOW_END_in_cf2606_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_cf2606	= { FOLLOW_END_in_cf2606_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEHAVIOR_in_cf2608  */
static	ANTLR3_BITWORD FOLLOW_BEHAVIOR_in_cf2608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BEHAVIOR_in_cf2608	= { FOLLOW_BEHAVIOR_in_cf2608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2689  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2689	= { FOLLOW_statement_in_sequence2689_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2696  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2696_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040004) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2696	= { FOLLOW_77_in_sequence2696_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2700  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2700	= { FOLLOW_statement_in_sequence2700_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2707  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2707	= { FOLLOW_77_in_sequence2707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_sequence2712  */
static	ANTLR3_BITWORD FOLLOW_72_in_sequence2712_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040004) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_sequence2712	= { FOLLOW_72_in_sequence2712_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2717  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002200) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2717	= { FOLLOW_statement_in_sequence2717_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2731  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2731_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040004) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2731	= { FOLLOW_77_in_sequence2731_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2735  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002200) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2735	= { FOLLOW_statement_in_sequence2735_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2743  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2743	= { FOLLOW_77_in_sequence2743_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_sequence2746  */
static	ANTLR3_BITWORD FOLLOW_73_in_sequence2746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_sequence2746	= { FOLLOW_73_in_sequence2746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomic_statement_in_statement2792  */
static	ANTLR3_BITWORD FOLLOW_atomic_statement_in_statement2792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomic_statement_in_statement2792	= { FOLLOW_atomic_statement_in_statement2792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_statement_in_statement2798  */
static	ANTLR3_BITWORD FOLLOW_compound_statement_in_statement2798_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_statement_in_statement2798	= { FOLLOW_compound_statement_in_statement2798_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nothing_statement_in_atomic_statement2813  */
static	ANTLR3_BITWORD FOLLOW_nothing_statement_in_atomic_statement2813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nothing_statement_in_atomic_statement2813	= { FOLLOW_nothing_statement_in_atomic_statement2813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wait_statement_in_atomic_statement2818  */
static	ANTLR3_BITWORD FOLLOW_wait_statement_in_atomic_statement2818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wait_statement_in_atomic_statement2818	= { FOLLOW_wait_statement_in_atomic_statement2818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stop_statement_in_atomic_statement2823  */
static	ANTLR3_BITWORD FOLLOW_stop_statement_in_atomic_statement2823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stop_statement_in_atomic_statement2823	= { FOLLOW_stop_statement_in_atomic_statement2823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_run_procedure_statement_in_atomic_statement2828  */
static	ANTLR3_BITWORD FOLLOW_run_procedure_statement_in_atomic_statement2828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_run_procedure_statement_in_atomic_statement2828	= { FOLLOW_run_procedure_statement_in_atomic_statement2828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_statement_in_atomic_statement2833  */
static	ANTLR3_BITWORD FOLLOW_code_block_statement_in_atomic_statement2833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_statement_in_atomic_statement2833	= { FOLLOW_code_block_statement_in_atomic_statement2833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_behavior_code_block_statement_in_code_block_statement2859  */
static	ANTLR3_BITWORD FOLLOW_behavior_code_block_statement_in_code_block_statement2859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_behavior_code_block_statement_in_code_block_statement2859	= { FOLLOW_behavior_code_block_statement_in_code_block_statement2859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_block_statement_in_code_block_statement2864  */
static	ANTLR3_BITWORD FOLLOW_declaration_block_statement_in_code_block_statement2864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_block_statement_in_code_block_statement2864	= { FOLLOW_declaration_block_statement_in_code_block_statement2864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initialization_block_statement_in_code_block_statement2869  */
static	ANTLR3_BITWORD FOLLOW_initialization_block_statement_in_code_block_statement2869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_initialization_block_statement_in_code_block_statement2869	= { FOLLOW_initialization_block_statement_in_code_block_statement2869_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_includes_block_statement_in_code_block_statement2874  */
static	ANTLR3_BITWORD FOLLOW_includes_block_statement_in_code_block_statement2874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_includes_block_statement_in_code_block_statement2874	= { FOLLOW_includes_block_statement_in_code_block_statement2874_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_behavior_code_block_statement2893  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_behavior_code_block_statement2893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_behavior_code_block_statement2893	= { FOLLOW_code_block_with_info_in_behavior_code_block_statement2893_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECL_in_declaration_block_statement2913  */
static	ANTLR3_BITWORD FOLLOW_DECL_in_declaration_block_statement2913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECL_in_declaration_block_statement2913	= { FOLLOW_DECL_in_declaration_block_statement2913_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_declaration_block_statement2917  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_declaration_block_statement2917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_declaration_block_statement2917	= { FOLLOW_code_block_with_info_in_declaration_block_statement2917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INIT_in_initialization_block_statement2937  */
static	ANTLR3_BITWORD FOLLOW_INIT_in_initialization_block_statement2937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INIT_in_initialization_block_statement2937	= { FOLLOW_INIT_in_initialization_block_statement2937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_initialization_block_statement2941  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_initialization_block_statement2941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_initialization_block_statement2941	= { FOLLOW_code_block_with_info_in_initialization_block_statement2941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_in_includes_block_statement2959  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_in_includes_block_statement2959_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_in_includes_block_statement2959	= { FOLLOW_INCLUDE_in_includes_block_statement2959_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_includes_block_statement2963  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_includes_block_statement2963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_includes_block_statement2963	= { FOLLOW_code_block_with_info_in_includes_block_statement2963_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOTHING_in_nothing_statement2982  */
static	ANTLR3_BITWORD FOLLOW_NOTHING_in_nothing_statement2982_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOTHING_in_nothing_statement2982	= { FOLLOW_NOTHING_in_nothing_statement2982_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wait_until_in_wait_statement3009  */
static	ANTLR3_BITWORD FOLLOW_wait_until_in_wait_statement3009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wait_until_in_wait_statement3009	= { FOLLOW_wait_until_in_wait_statement3009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wait_for_time_in_wait_statement3017  */
static	ANTLR3_BITWORD FOLLOW_wait_for_time_in_wait_statement3017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wait_for_time_in_wait_statement3017	= { FOLLOW_wait_for_time_in_wait_statement3017_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_single_wait_in_wait_statement3025  */
static	ANTLR3_BITWORD FOLLOW_single_wait_in_wait_statement3025_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_single_wait_in_wait_statement3025	= { FOLLOW_single_wait_in_wait_statement3025_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAIT_in_wait_until3050  */
static	ANTLR3_BITWORD FOLLOW_WAIT_in_wait_until3050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WAIT_in_wait_until3050	= { FOLLOW_WAIT_in_wait_until3050_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNTIL_in_wait_until3052  */
static	ANTLR3_BITWORD FOLLOW_UNTIL_in_wait_until3052_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_UNTIL_in_wait_until3052	= { FOLLOW_UNTIL_in_wait_until3052_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_wait_until3056  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_wait_until3056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_wait_until3056	= { FOLLOW_expression_cf_in_wait_until3056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAIT_in_wait_for_time3093  */
static	ANTLR3_BITWORD FOLLOW_WAIT_in_wait_for_time3093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WAIT_in_wait_for_time3093	= { FOLLOW_WAIT_in_wait_for_time3093_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_wait_for_time3096  */
static	ANTLR3_BITWORD FOLLOW_72_in_wait_for_time3096_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_wait_for_time3096	= { FOLLOW_72_in_wait_for_time3096_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_wait_for_time3100  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_wait_for_time3100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_wait_for_time3100	= { FOLLOW_expression_cf_in_wait_for_time3100_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_wait_for_time3102  */
static	ANTLR3_BITWORD FOLLOW_75_in_wait_for_time3102_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_wait_for_time3102	= { FOLLOW_75_in_wait_for_time3102_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_wait_for_time3106  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_wait_for_time3106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_wait_for_time3106	= { FOLLOW_expression_cf_in_wait_for_time3106_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_wait_for_time3108  */
static	ANTLR3_BITWORD FOLLOW_73_in_wait_for_time3108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_wait_for_time3108	= { FOLLOW_73_in_wait_for_time3108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAIT_in_single_wait3139  */
static	ANTLR3_BITWORD FOLLOW_WAIT_in_single_wait3139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WAIT_in_single_wait3139	= { FOLLOW_WAIT_in_single_wait3139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stop_behavior_in_stop_statement3165  */
static	ANTLR3_BITWORD FOLLOW_stop_behavior_in_stop_statement3165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stop_behavior_in_stop_statement3165	= { FOLLOW_stop_behavior_in_stop_statement3165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stop_simulation_in_stop_statement3171  */
static	ANTLR3_BITWORD FOLLOW_stop_simulation_in_stop_statement3171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stop_simulation_in_stop_statement3171	= { FOLLOW_stop_simulation_in_stop_statement3171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STOP_in_stop_behavior3184  */
static	ANTLR3_BITWORD FOLLOW_STOP_in_stop_behavior3184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_STOP_in_stop_behavior3184	= { FOLLOW_STOP_in_stop_behavior3184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEHAVIOR_in_stop_behavior3186  */
static	ANTLR3_BITWORD FOLLOW_BEHAVIOR_in_stop_behavior3186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BEHAVIOR_in_stop_behavior3186	= { FOLLOW_BEHAVIOR_in_stop_behavior3186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STOP_in_stop_simulation3206  */
static	ANTLR3_BITWORD FOLLOW_STOP_in_stop_simulation3206_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STOP_in_stop_simulation3206	= { FOLLOW_STOP_in_stop_simulation3206_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMULATION_in_stop_simulation3208  */
static	ANTLR3_BITWORD FOLLOW_SIMULATION_in_stop_simulation3208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMULATION_in_stop_simulation3208	= { FOLLOW_SIMULATION_in_stop_simulation3208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RUN_in_run_procedure_statement3228  */
static	ANTLR3_BITWORD FOLLOW_RUN_in_run_procedure_statement3228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RUN_in_run_procedure_statement3228	= { FOLLOW_RUN_in_run_procedure_statement3228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_run_procedure_statement3232  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_run_procedure_statement3232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_run_procedure_statement3232	= { FOLLOW_IDENTIFIER_in_run_procedure_statement3232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_if_statement_in_compound_statement3253  */
static	ANTLR3_BITWORD FOLLOW_if_statement_in_compound_statement3253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_if_statement_in_compound_statement3253	= { FOLLOW_if_statement_in_compound_statement3253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_do_while_statement_in_compound_statement3258  */
static	ANTLR3_BITWORD FOLLOW_do_while_statement_in_compound_statement3258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_do_while_statement_in_compound_statement3258	= { FOLLOW_do_while_statement_in_compound_statement3258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parallel_statement_in_compound_statement3263  */
static	ANTLR3_BITWORD FOLLOW_parallel_statement_in_compound_statement3263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parallel_statement_in_compound_statement3263	= { FOLLOW_parallel_statement_in_compound_statement3263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_if_statement3290  */
static	ANTLR3_BITWORD FOLLOW_IF_in_if_statement3290_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_if_statement3290	= { FOLLOW_IF_in_if_statement3290_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_if_statement3296  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_if_statement3296_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_if_statement3296	= { FOLLOW_expression_cf_in_if_statement3296_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THEN_in_if_statement3300  */
static	ANTLR3_BITWORD FOLLOW_THEN_in_if_statement3300_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_THEN_in_if_statement3300	= { FOLLOW_THEN_in_if_statement3300_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_if_statement3310  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_if_statement3310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000180000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_if_statement3310	= { FOLLOW_sequence_in_if_statement3310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELSE_in_if_statement3328  */
static	ANTLR3_BITWORD FOLLOW_ELSE_in_if_statement3328_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_ELSE_in_if_statement3328	= { FOLLOW_ELSE_in_if_statement3328_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_if_statement3352  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_if_statement3352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_if_statement3352	= { FOLLOW_sequence_in_if_statement3352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_if_statement3384  */
static	ANTLR3_BITWORD FOLLOW_END_in_if_statement3384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_if_statement3384	= { FOLLOW_END_in_if_statement3384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_if_statement3386  */
static	ANTLR3_BITWORD FOLLOW_IF_in_if_statement3386_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_if_statement3386	= { FOLLOW_IF_in_if_statement3386_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DO_in_do_while_statement3426  */
static	ANTLR3_BITWORD FOLLOW_DO_in_do_while_statement3426_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_DO_in_do_while_statement3426	= { FOLLOW_DO_in_do_while_statement3426_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_do_while_statement3516  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_do_while_statement3516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_do_while_statement3516	= { FOLLOW_sequence_in_do_while_statement3516_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHILE_in_do_while_statement3580  */
static	ANTLR3_BITWORD FOLLOW_WHILE_in_do_while_statement3580_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WHILE_in_do_while_statement3580	= { FOLLOW_WHILE_in_do_while_statement3580_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_do_while_statement3584  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_do_while_statement3584_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_do_while_statement3584	= { FOLLOW_expression_cf_in_do_while_statement3584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_do_while_statement3586  */
static	ANTLR3_BITWORD FOLLOW_END_in_do_while_statement3586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_do_while_statement3586	= { FOLLOW_END_in_do_while_statement3586_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DO_in_do_while_statement3588  */
static	ANTLR3_BITWORD FOLLOW_DO_in_do_while_statement3588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DO_in_do_while_statement3588	= { FOLLOW_DO_in_do_while_statement3588_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_parallel_statement3632  */
static	ANTLR3_BITWORD FOLLOW_82_in_parallel_statement3632_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_parallel_statement3632	= { FOLLOW_82_in_parallel_statement3632_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_parallel_statement3692  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_parallel_statement3692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_parallel_statement3692	= { FOLLOW_sequence_in_parallel_statement3692_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_84_in_parallel_statement3735  */
static	ANTLR3_BITWORD FOLLOW_84_in_parallel_statement3735_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_84_in_parallel_statement3735	= { FOLLOW_84_in_parallel_statement3735_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_parallel_statement3792  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_parallel_statement3792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_parallel_statement3792	= { FOLLOW_sequence_in_parallel_statement3792_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_parallel_statement3826  */
static	ANTLR3_BITWORD FOLLOW_83_in_parallel_statement3826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_parallel_statement3826	= { FOLLOW_83_in_parallel_statement3826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp1_in_expression_cf3985  */
static	ANTLR3_BITWORD FOLLOW_exp1_in_expression_cf3985_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp1_in_expression_cf3985	= { FOLLOW_exp1_in_expression_cf3985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_in_expression_cf3998  */
static	ANTLR3_BITWORD FOLLOW_OR_in_expression_cf3998_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_in_expression_cf3998	= { FOLLOW_OR_in_expression_cf3998_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp1_in_expression_cf4003  */
static	ANTLR3_BITWORD FOLLOW_exp1_in_expression_cf4003_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp1_in_expression_cf4003	= { FOLLOW_exp1_in_expression_cf4003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp2_in_exp14047  */
static	ANTLR3_BITWORD FOLLOW_exp2_in_exp14047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_exp2_in_exp14047	= { FOLLOW_exp2_in_exp14047_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_exp14059  */
static	ANTLR3_BITWORD FOLLOW_AND_in_exp14059_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_exp14059	= { FOLLOW_AND_in_exp14059_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp2_in_exp14067  */
static	ANTLR3_BITWORD FOLLOW_exp2_in_exp14067_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_exp2_in_exp14067	= { FOLLOW_exp2_in_exp14067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_exp24117  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_exp24117_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_exp24117	= { FOLLOW_NOT_in_exp24117_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp3_in_exp24132  */
static	ANTLR3_BITWORD FOLLOW_exp3_in_exp24132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp3_in_exp24132	= { FOLLOW_exp3_in_exp24132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp4_in_exp34162  */
static	ANTLR3_BITWORD FOLLOW_exp4_in_exp34162_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002), ANTLR3_UINT64_LIT(0x000000000003C040) };
static  ANTLR3_BITSET_LIST FOLLOW_exp4_in_exp34162	= { FOLLOW_exp4_in_exp34162_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparison_operator_in_exp34177  */
static	ANTLR3_BITWORD FOLLOW_comparison_operator_in_exp34177_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_comparison_operator_in_exp34177	= { FOLLOW_comparison_operator_in_exp34177_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp4_in_exp34193  */
static	ANTLR3_BITWORD FOLLOW_exp4_in_exp34193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002), ANTLR3_UINT64_LIT(0x000000000003C040) };
static  ANTLR3_BITSET_LIST FOLLOW_exp4_in_exp34193	= { FOLLOW_exp4_in_exp34193_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp5_in_exp44238  */
static	ANTLR3_BITWORD FOLLOW_exp5_in_exp44238_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp5_in_exp44238	= { FOLLOW_exp5_in_exp44238_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_add_operator_in_exp44253  */
static	ANTLR3_BITWORD FOLLOW_add_operator_in_exp44253_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_add_operator_in_exp44253	= { FOLLOW_add_operator_in_exp44253_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp5_in_exp44269  */
static	ANTLR3_BITWORD FOLLOW_exp5_in_exp44269_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp5_in_exp44269	= { FOLLOW_exp5_in_exp44269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp6_in_exp54313  */
static	ANTLR3_BITWORD FOLLOW_exp6_in_exp54313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_exp6_in_exp54313	= { FOLLOW_exp6_in_exp54313_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mul_operator_in_exp54328  */
static	ANTLR3_BITWORD FOLLOW_mul_operator_in_exp54328_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_mul_operator_in_exp54328	= { FOLLOW_mul_operator_in_exp54328_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp6_in_exp54344  */
static	ANTLR3_BITWORD FOLLOW_exp6_in_exp54344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_exp6_in_exp54344	= { FOLLOW_exp6_in_exp54344_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_exp64394  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_exp64394_bits[]	= { ANTLR3_UINT64_LIT(0x6200000204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_exp64394	= { FOLLOW_MINUS_in_exp64394_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomic_expression_cf_in_exp64412  */
static	ANTLR3_BITWORD FOLLOW_atomic_expression_cf_in_exp64412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomic_expression_cf_in_exp64412	= { FOLLOW_atomic_expression_cf_in_exp64412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_atomic_expression_cf4545  */
static	ANTLR3_BITWORD FOLLOW_72_in_atomic_expression_cf4545_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_atomic_expression_cf4545	= { FOLLOW_72_in_atomic_expression_cf4545_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_atomic_expression_cf4548  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_atomic_expression_cf4548_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_atomic_expression_cf4548	= { FOLLOW_expression_cf_in_atomic_expression_cf4548_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_atomic_expression_cf4549  */
static	ANTLR3_BITWORD FOLLOW_73_in_atomic_expression_cf4549_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_atomic_expression_cf4549	= { FOLLOW_73_in_atomic_expression_cf4549_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_atomic_expression_cf4574  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_atomic_expression_cf4574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_atomic_expression_cf4574	= { FOLLOW_function_call_in_atomic_expression_cf4574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_this_cycle_in_atomic_expression_cf4591  */
static	ANTLR3_BITWORD FOLLOW_this_cycle_in_atomic_expression_cf4591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_this_cycle_in_atomic_expression_cf4591	= { FOLLOW_this_cycle_in_atomic_expression_cf4591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_this_phase_in_atomic_expression_cf4610  */
static	ANTLR3_BITWORD FOLLOW_this_phase_in_atomic_expression_cf4610_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_this_phase_in_atomic_expression_cf4610	= { FOLLOW_this_phase_in_atomic_expression_cf4610_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atomic_expression_cf4629  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atomic_expression_cf4629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atomic_expression_cf4629	= { FOLLOW_INTEGER_in_atomic_expression_cf4629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_atomic_expression_cf4649  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_atomic_expression_cf4649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_atomic_expression_cf4649	= { FOLLOW_STRING_in_atomic_expression_cf4649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_atomic_expression_cf4672  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_atomic_expression_cf4672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_atomic_expression_cf4672	= { FOLLOW_identifier_in_atomic_expression_cf4672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_code_block_in_atomic_expression_cf4691  */
static	ANTLR3_BITWORD FOLLOW_expression_code_block_in_atomic_expression_cf4691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_code_block_in_atomic_expression_cf4691	= { FOLLOW_expression_code_block_in_atomic_expression_cf4691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_in_expression_code_block4754  */
static	ANTLR3_BITWORD FOLLOW_code_block_in_expression_code_block4754_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_in_expression_code_block4754	= { FOLLOW_code_block_in_expression_code_block4754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_function_call4839  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_function_call4839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_function_call4839	= { FOLLOW_identifier_in_function_call4839_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_function_call4841  */
static	ANTLR3_BITWORD FOLLOW_72_in_function_call4841_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000300) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_function_call4841	= { FOLLOW_72_in_function_call4841_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_list_in_function_call4870  */
static	ANTLR3_BITWORD FOLLOW_argument_list_in_function_call4870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_list_in_function_call4870	= { FOLLOW_argument_list_in_function_call4870_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_function_call4894  */
static	ANTLR3_BITWORD FOLLOW_73_in_function_call4894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_function_call4894	= { FOLLOW_73_in_function_call4894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_argument_list4929  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_argument_list4929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_argument_list4929	= { FOLLOW_expression_cf_in_argument_list4929_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_argument_list4950  */
static	ANTLR3_BITWORD FOLLOW_75_in_argument_list4950_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_argument_list4950	= { FOLLOW_75_in_argument_list4950_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_argument_list4985  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_argument_list4985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_argument_list4985	= { FOLLOW_expression_cf_in_argument_list4985_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THIS_CYCLE_in_this_cycle5039  */
static	ANTLR3_BITWORD FOLLOW_THIS_CYCLE_in_this_cycle5039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_THIS_CYCLE_in_this_cycle5039	= { FOLLOW_THIS_CYCLE_in_this_cycle5039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THIS_PHASE_in_this_phase5092  */
static	ANTLR3_BITWORD FOLLOW_THIS_PHASE_in_this_phase5092_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_THIS_PHASE_in_this_phase5092	= { FOLLOW_THIS_PHASE_in_this_phase5092_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_in_code_block_with_info5150  */
static	ANTLR3_BITWORD FOLLOW_code_block_in_code_block_with_info5150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_in_code_block_with_info5150	= { FOLLOW_code_block_in_code_block_with_info5150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CODE_BLOCK_in_code_block5217  */
static	ANTLR3_BITWORD FOLLOW_CODE_BLOCK_in_code_block5217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CODE_BLOCK_in_code_block5217	= { FOLLOW_CODE_BLOCK_in_code_block5217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_identifier5273  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_identifier5273_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_identifier5273	= { FOLLOW_IDENTIFIER_in_identifier5273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_identifier5275  */
static	ANTLR3_BITWORD FOLLOW_set_in_identifier5275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_identifier5275	= { FOLLOW_set_in_identifier5275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_identifier5282  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_identifier5282_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_identifier5282	= { FOLLOW_IDENTIFIER_in_identifier5282_bits, 1	};



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    2317:1: atomic_expression_cf returns [std::string text] : ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block );
 */
static const ANTLR3_INT32 dfa75_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa75_eof[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa75_min[12] =
    {
	11, -1, 4, -1, -1, -1, -1, -1, 26, -1, -1, 4
    };
static const ANTLR3_INT32 dfa75_max[12] =
    {
	72, -1, 84, -1, -1, -1, -1, -1, 26, -1, -1, 84
    };
static const ANTLR3_INT32 dfa75_accept[12] =
    {
	-1, 1, -1, 3, 4, 5, 6, 8, -1, 2, 7, -1
    };
static const ANTLR3_INT32 dfa75_special[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa75_T_empty	    NULL

static const ANTLR3_INT32 dfa75_T0[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 
	-1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, 3, 4, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1
    };

static const ANTLR3_INT32 dfa75_T1[] =
    {
	11
    };

static const ANTLR3_INT32 dfa75_T2[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, 8, 10, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, 10, -1, -1, -1, 10, 8, -1, -1, 8, -1, -1, -1, -1, -1, 
	-1, 10, -1, -1, -1, -1, -1, -1, 10, -1, -1, 10, 10, 9, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, -1, 10, 10
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa75_transitions[] =
{
    dfa75_T0, NULL, dfa75_T2, NULL, NULL, NULL, NULL, NULL, dfa75_T1, NULL, 
    NULL, dfa75_T2
};


/* Declare tracking structure for Cyclic DFA 75
 */
static
ANTLR3_CYCLIC_DFA cdfa75
    =	{
	    75,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"2317:1: atomic_expression_cf returns [std::string text] : ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa75_eot,	    /* EOT table			    */
	    dfa75_eof,	    /* EOF table			    */
	    dfa75_min,	    /* Minimum tokens for each state    */
	    dfa75_max,	    /* Maximum tokens for each state    */
	    dfa75_accept,	/* Accept table			    */
	    dfa75_special,	/* Special transition states	    */
	    dfa75_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 75
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start top
 * /home/project/sitarV2/translator/grammar/sitar.g:192:1: top : ( design_unit )+ EOF ;
 */
static void
top(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_topTop = psitarParser_topPush(ctx);
     (SCOPE_TOP(top))->design_unit_names_list=new std::set<std::string>;
    {
        // /home/project/sitarV2/translator/grammar/sitar.g:197:2: ( ( design_unit )+ EOF )
        // /home/project/sitarV2/translator/grammar/sitar.g:197:4: ( design_unit )+ EOF
        {
            {

                			//check if all initializations have occured correctly
                			assert(CODEGEN!=NULL); 
                			assert(GDATA!=NULL);
                			
                			
                		
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:206:3: ( design_unit )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) )
            	{
            	case MODULE:
            	case PROCEDURE:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // /home/project/sitarV2/translator/grammar/sitar.g:207:4: design_unit
            	        {
            	            {
            	                //Ready the data structure:
            	                			//open files for writing and clear
            	                			//the data from previous module description
            	                			if(!(GDATA->openFilesForWriting())) 
            	                			 {std::cout<<"\nERROR: sitar translator couldn't open temporary files for code generation"; exit(1);}
            	                			 D_file<<" ";
            	                			 C_file<<" ";
            	                			 I_file<<" ";
            	                			 E_file<<" ";
            	                			
            	            }


            	            FOLLOWPUSH(FOLLOW_design_unit_in_top578);
            	            design_unit(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletopEx;
            	            }


            	            {

            	                		 	 // after parsing a design unit, close temp files. 
            	                			 //They will be opened by CodeGen for reading
            	                			 GDATA->closeFiles();
            	                			 
            	                			 //Ask codeGen to dump code for the module description just parsed.
            	                			 CODEGEN->parse();
            	                		 	
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletopEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(EOF, &FOLLOW_EOF_in_top599);
            if  (HASEXCEPTION())
            {
                goto ruletopEx;
            }


            {

                		GDATA->closeFiles();
                		GDATA->deleteTemporaryFiles();
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletopEx; /* Prevent compiler warnings */
    ruletopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     delete (SCOPE_TOP(top))->design_unit_names_list;
                }
            }


    psitarParser_topPop(ctx);

    return ;
}
/* $ANTLR end top */

/**
 * $ANTLR start design_unit
 * /home/project/sitarV2/translator/grammar/sitar.g:241:1: design_unit : du ;
 */
static void
design_unit(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:241:13: ( du )
        // /home/project/sitarV2/translator/grammar/sitar.g:241:15: du
        {
            FOLLOWPUSH(FOLLOW_du_in_design_unit619);
            du(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledesign_unitEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledesign_unitEx; /* Prevent compiler warnings */
    ruledesign_unitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end design_unit */

/**
 * $ANTLR start du
 * /home/project/sitarV2/translator/grammar/sitar.g:243:1: du : ( ( module_definition ) | ( procedure_definition ) ) ;
 */
static void
du(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_duTop = psitarParser_duPush(ctx);

    	//initialize aatributes
    	(SCOPE_TOP(du))->design_unit_name=new std::string("");
    	
    	(SCOPE_TOP(du))->is_module=true;
    	(SCOPE_TOP(du))->has_parameters=false;
    	(SCOPE_TOP(du))->has_behavior=false;
    	
    	(SCOPE_TOP(du))->num_pointers=0;
    	(SCOPE_TOP(du))->num_timers=0;
    	(SCOPE_TOP(du))->num_if_flags=0;
    	
    	(SCOPE_TOP(du))->filename_h=new std::string("");
    	(SCOPE_TOP(du))->filename_cpp=new std::string("");;
    	(SCOPE_TOP(du))->header_guard=new std::string("");
    	(SCOPE_TOP(du))->template_class=new std::string("");;
    	(SCOPE_TOP(du))->template_member=new std::string("");
    	(SCOPE_TOP(du))->template_args=new std::string("");
    	
    	(SCOPE_TOP(du))->param_name=new std::list<std::string>;
    	(SCOPE_TOP(du))->param_type=new std::list<std::string>;
    	(SCOPE_TOP(du))->param_value=new std::list<std::string>;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:336:3: ( ( ( module_definition ) | ( procedure_definition ) ) )
        // /home/project/sitarV2/translator/grammar/sitar.g:336:3: ( ( module_definition ) | ( procedure_definition ) )
        {
            // /home/project/sitarV2/translator/grammar/sitar.g:336:3: ( ( module_definition ) | ( procedure_definition ) )
            {
                int alt2=2;
                switch ( LA(1) )
                {
                case MODULE:
                	{
                		alt2=1;
                	}
                    break;
                case PROCEDURE:
                	{
                		alt2=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 2;
                    EXCEPTION->state        = 0;


                    goto ruleduEx;

                }

                switch (alt2)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:336:6: ( module_definition )
            	    {
            	        // /home/project/sitarV2/translator/grammar/sitar.g:336:6: ( module_definition )
            	        // /home/project/sitarV2/translator/grammar/sitar.g:336:10: module_definition
            	        {
            	            FOLLOWPUSH(FOLLOW_module_definition_in_du657);
            	            module_definition(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleduEx;
            	            }


            	            {
            	                (SCOPE_TOP(du))->is_module=true;
            	            }


            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:337:5: ( procedure_definition )
            	    {
            	        // /home/project/sitarV2/translator/grammar/sitar.g:337:5: ( procedure_definition )
            	        // /home/project/sitarV2/translator/grammar/sitar.g:337:9: procedure_definition
            	        {
            	            FOLLOWPUSH(FOLLOW_procedure_definition_in_du673);
            	            procedure_definition(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleduEx;
            	            }


            	            {
            	                (SCOPE_TOP(du))->is_module=false;
            	            }


            	        }


            	    }
            	    break;

                }
            }

            {

                	//ready attributes for storing in Global Data structure
                	std::string is_module="";
                	std::string has_parameters="";
                	std::string has_behavior="";

                	if((SCOPE_TOP(du))->is_module) {is_module="y";};
                	if((SCOPE_TOP(du))->has_parameters) {has_parameters="y";};
                	if((SCOPE_TOP(du))->has_behavior) {has_behavior="y";};
                	
                	//determine output file names
                	*(SCOPE_TOP(du))->filename_h=std::string(OUTPUT_FILE_PREFIX_STR+ *(SCOPE_TOP(du))->design_unit_name + ".h");
                	*(SCOPE_TOP(du))->filename_cpp=std::string(OUTPUT_FILE_PREFIX_STR+ *(SCOPE_TOP(du))->design_unit_name + ".cpp");


                	//Generate a string for header guard
                	std::string h=OUTPUT_FILE_PREFIX_STR + *(SCOPE_TOP(du))->design_unit_name;
                	std::transform(h.begin(), h.end(),h.begin(), ::toupper);
                	*(SCOPE_TOP(du))->header_guard=h+"_H";



                	//Generate strings for declaration of template
                	//parameters at various places in the generated code
                	 *(SCOPE_TOP(du))->template_class="";
                	 *(SCOPE_TOP(du))->template_member="";
                	 *(SCOPE_TOP(du))->template_args="";

                		
                	if((SCOPE_TOP(du))->has_parameters==true)
                	{
                		bool flag_first =true;
                	
                		*(SCOPE_TOP(du))->template_class= "template<";
                		*(SCOPE_TOP(du))->template_member="template<";
                		*(SCOPE_TOP(du))->template_args=  "<";

                		while(!(SCOPE_TOP(du))->param_name->empty())
                		{
                			if(!flag_first)
                			{
                				//put a comma
                				(SCOPE_TOP(du))->template_class->append(","); 
                				(SCOPE_TOP(du))->template_member->append(",");
                				(SCOPE_TOP(du))->template_args->append(",");
                			}
                			(SCOPE_TOP(du))->template_class->append((SCOPE_TOP(du))->param_type->front()+" ");
                			(SCOPE_TOP(du))->template_member->append((SCOPE_TOP(du))->param_type->front()+" ");

                			(SCOPE_TOP(du))->template_class->append( (SCOPE_TOP(du))->param_name->front());
                			(SCOPE_TOP(du))->template_member->append((SCOPE_TOP(du))->param_name->front());
                			(SCOPE_TOP(du))->template_args->append(  (SCOPE_TOP(du))->param_name->front());

                			(SCOPE_TOP(du))->template_class->append("=");
                			(SCOPE_TOP(du))->template_class->append((SCOPE_TOP(du))->param_value->front());

                			(SCOPE_TOP(du))->param_name->pop_front();
                			(SCOPE_TOP(du))->param_type->pop_front();
                			(SCOPE_TOP(du))->param_value->pop_front();

                			//the 3 lists should be in sync
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_value->size());
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_type->size());

                			flag_first=false;
                		}
                		(SCOPE_TOP(du))->template_class->append(">"); 
                		(SCOPE_TOP(du))->template_member->append(">");
                		(SCOPE_TOP(du))->template_args->append(">");
                	};


                	//Now store all the attributes in GDATA

                	GDATA->storeAttrib("design_unit_name",*(SCOPE_TOP(du))->design_unit_name);
                	GDATA->storeAttrib("is_module",is_module);
                	GDATA->storeAttrib("has_parameters",has_parameters);
                	GDATA->storeAttrib("has_behavior",has_behavior);

                	GDATA->storeAttrib("num_pointers",CODEGEN->intToString((SCOPE_TOP(du))->num_pointers)); 
                	GDATA->storeAttrib("num_timers",CODEGEN->intToString((SCOPE_TOP(du))->num_timers)); 
                	GDATA->storeAttrib("num_if_flags",CODEGEN->intToString((SCOPE_TOP(du))->num_if_flags)); 
                	
                	GDATA->storeAttrib("filename_h",*(SCOPE_TOP(du))->filename_h);
                	GDATA->storeAttrib("filename_cpp",*(SCOPE_TOP(du))->filename_cpp);
                	GDATA->storeAttrib("header_guard",*(SCOPE_TOP(du))->header_guard);
                	
                	
                	GDATA->storeAttrib("template_class",*(SCOPE_TOP(du))->template_class);
                	GDATA->storeAttrib("template_member",*(SCOPE_TOP(du))->template_member);
                	GDATA->storeAttrib("template_args",*(SCOPE_TOP(du))->template_args); 
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleduEx; /* Prevent compiler warnings */
    ruleduEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	
                    	
                    	
                    	
                    	
                    	//deallocate memory
                    	delete (SCOPE_TOP(du))->design_unit_name;
                    	delete (SCOPE_TOP(du))->filename_h;
                    	delete (SCOPE_TOP(du))->filename_cpp;
                    	delete (SCOPE_TOP(du))->header_guard;
                    	delete (SCOPE_TOP(du))->template_class;
                    	delete (SCOPE_TOP(du))->template_member;
                    	delete (SCOPE_TOP(du))->template_args;

                    	delete (SCOPE_TOP(du))->param_name;
                    	delete (SCOPE_TOP(du))->param_type;
                    	delete (SCOPE_TOP(du))->param_value;

                }
            }


    psitarParser_duPop(ctx);

    return ;
}
/* $ANTLR end du */

/**
 * $ANTLR start module_definition
 * /home/project/sitarV2/translator/grammar/sitar.g:443:1: module_definition : MODULE id= IDENTIFIER module_body END MODULE ;
 */
static void
module_definition(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:444:2: ( MODULE id= IDENTIFIER module_body END MODULE )
        // /home/project/sitarV2/translator/grammar/sitar.g:444:4: MODULE id= IDENTIFIER module_body END MODULE
        {
             MATCHT(MODULE, &FOLLOW_MODULE_in_module_definition705);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


            {
                (SCOPE_TOP(du))->is_module=true;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_module_definition710);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


            {

                		    //check for duplicate design unit names
                		    *(SCOPE_TOP(du))->design_unit_name=(const char*)((id->getText(id))->chars);
                		    std::string mname=*(SCOPE_TOP(du))->design_unit_name;
                		    		    
                		    if((SCOPE_TOP(top))->design_unit_names_list->count(mname)>0)
                		    {
                			    std::cout<<"\nDuplicate definition of module ";
                			    std::cout<<mname<<" on line ";
                			    std::cout<<(id->getLine(id));
                		    }
                		    else{(SCOPE_TOP(top))->design_unit_names_list->insert(mname);}
                		
                		
            }


            FOLLOWPUSH(FOLLOW_module_body_in_module_definition721);
            module_body(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


             MATCHT(END, &FOLLOW_END_in_module_definition725);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


             MATCHT(MODULE, &FOLLOW_MODULE_in_module_definition727);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


            {

                			
                			//Write msg to screen
                			std::cout<<"\nParsed module "<<*(SCOPE_TOP(du))->design_unit_name; 
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemodule_definitionEx; /* Prevent compiler warnings */
    rulemodule_definitionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end module_definition */

/**
 * $ANTLR start procedure_definition
 * /home/project/sitarV2/translator/grammar/sitar.g:472:1: procedure_definition : PROCEDURE id= IDENTIFIER procedure_body END PROCEDURE ;
 */
static void
procedure_definition(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:473:2: ( PROCEDURE id= IDENTIFIER procedure_body END PROCEDURE )
        // /home/project/sitarV2/translator/grammar/sitar.g:473:4: PROCEDURE id= IDENTIFIER procedure_body END PROCEDURE
        {
             MATCHT(PROCEDURE, &FOLLOW_PROCEDURE_in_procedure_definition758);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


            {
                (SCOPE_TOP(du))->is_module=false;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_definition763);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


            {

                		    //check for duplicate design unit names
                		    *(SCOPE_TOP(du))->design_unit_name=(const char*)((id->getText(id))->chars);
                		    std::string mname=*(SCOPE_TOP(du))->design_unit_name;
                		    		    
                		    if((SCOPE_TOP(top))->design_unit_names_list->count(mname)>0)
                		    {
                			    std::cout<<"\nDuplicate definition of procedure ";
                			    std::cout<<mname<<"on line ";
                			    std::cout<<(id->getLine(id));
                		    }
                		    else{(SCOPE_TOP(top))->design_unit_names_list->insert(mname);}
                		
                		
            }


            FOLLOWPUSH(FOLLOW_procedure_body_in_procedure_definition775);
            procedure_body(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


             MATCHT(END, &FOLLOW_END_in_procedure_definition779);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


             MATCHT(PROCEDURE, &FOLLOW_PROCEDURE_in_procedure_definition781);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


            {

                			
                			//Write msg to screen
                			std::cout<<"\nParsed procedure "<<*(SCOPE_TOP(du))->design_unit_name; 
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprocedure_definitionEx; /* Prevent compiler warnings */
    ruleprocedure_definitionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end procedure_definition */

/**
 * $ANTLR start module_body
 * /home/project/sitarV2/translator/grammar/sitar.g:514:1: module_body : ( parameter_declaration_region )? ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )? ;
 */
static void
module_body(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:515:2: ( ( parameter_declaration_region )? ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:517:3: ( parameter_declaration_region )? ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )?
        {
            // /home/project/sitarV2/translator/grammar/sitar.g:517:3: ( parameter_declaration_region )?
            {
                int alt3=2;
                switch ( LA(1) )
                {
                    case PARAMETER:
                    	{
                    		alt3=1;
                    	}
                        break;
                }

                switch (alt3)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:517:5: parameter_declaration_region
            	    {
            	        FOLLOWPUSH(FOLLOW_parameter_declaration_region_in_module_body833);
            	        parameter_declaration_region(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemodule_bodyEx;
            	        }


            	        {
            	            (SCOPE_TOP(du))->has_parameters=true;
            	        }


            	    }
            	    break;

                }
            }

            // /home/project/sitarV2/translator/grammar/sitar.g:518:3: ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case DECL:
                case FOR:
                case IDENTIFIER:
                case INCLUDE:
                case INIT:
                case INPORT:
                case INPORT_ARRAY:
                case NET:
                case NET_ARRAY:
                case OUTPORT:
                case OUTPORT_ARRAY:
                case PROCEDURE:
                case SUBMODULE:
                case SUBMODULE_ARRAY:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:518:5: ( code_block_regions | structural_component_declaration | procedure_declaration )
            	    {
            	        // /home/project/sitarV2/translator/grammar/sitar.g:518:5: ( code_block_regions | structural_component_declaration | procedure_declaration )
            	        {
            	            int alt4=3;
            	            switch ( LA(1) )
            	            {
            	            case DECL:
            	            case INCLUDE:
            	            case INIT:
            	            	{
            	            		alt4=1;
            	            	}
            	                break;
            	            case FOR:
            	            case IDENTIFIER:
            	            case INPORT:
            	            case INPORT_ARRAY:
            	            case NET:
            	            case NET_ARRAY:
            	            case OUTPORT:
            	            case OUTPORT_ARRAY:
            	            case SUBMODULE:
            	            case SUBMODULE_ARRAY:
            	            	{
            	            		alt4=2;
            	            	}
            	                break;
            	            case PROCEDURE:
            	            	{
            	            		alt4=3;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 4;
            	                EXCEPTION->state        = 0;


            	                goto rulemodule_bodyEx;

            	            }

            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:518:6: code_block_regions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_code_block_regions_in_module_body868);
            	        	        code_block_regions(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:518:27: structural_component_declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_structural_component_declaration_in_module_body872);
            	        	        structural_component_declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:518:61: procedure_declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_procedure_declaration_in_module_body875);
            	        	        procedure_declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            // /home/project/sitarV2/translator/grammar/sitar.g:519:3: ( behavior_block ( code_block_regions )* )?
            {
                int alt7=2;
                switch ( LA(1) )
                {
                    case BEHAVIOR:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:519:5: behavior_block ( code_block_regions )*
            	    {
            	        FOLLOWPUSH(FOLLOW_behavior_block_in_module_body886);
            	        behavior_block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemodule_bodyEx;
            	        }


            	        {
            	            (SCOPE_TOP(du))->has_behavior=true;
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:519:45: ( code_block_regions )*

            	        for (;;)
            	        {
            	            int alt6=2;
            	            switch ( LA(1) )
            	            {
            	            case DECL:
            	            case INCLUDE:
            	            case INIT:
            	            	{
            	            		alt6=1;
            	            	}
            	                break;

            	            }

            	            switch (alt6)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:519:46: code_block_regions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_code_block_regions_in_module_body890);
            	        	        code_block_regions(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop6;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop6: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulemodule_bodyEx; /* Prevent compiler warnings */
    rulemodule_bodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end module_body */

/**
 * $ANTLR start procedure_body
 * /home/project/sitarV2/translator/grammar/sitar.g:523:1: procedure_body : ( parameter_declaration_region )? ( ( code_block_regions | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )? ;
 */
static void
procedure_body(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:524:2: ( ( parameter_declaration_region )? ( ( code_block_regions | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:526:3: ( parameter_declaration_region )? ( ( code_block_regions | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )?
        {
            // /home/project/sitarV2/translator/grammar/sitar.g:526:3: ( parameter_declaration_region )?
            {
                int alt8=2;
                switch ( LA(1) )
                {
                    case PARAMETER:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:526:5: parameter_declaration_region
            	    {
            	        FOLLOWPUSH(FOLLOW_parameter_declaration_region_in_procedure_body934);
            	        parameter_declaration_region(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_bodyEx;
            	        }


            	        {
            	            (SCOPE_TOP(du))->has_parameters=true;
            	        }


            	    }
            	    break;

                }
            }

            // /home/project/sitarV2/translator/grammar/sitar.g:527:3: ( ( code_block_regions | procedure_declaration ) )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) )
                {
                case DECL:
                case INCLUDE:
                case INIT:
                case PROCEDURE:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:527:5: ( code_block_regions | procedure_declaration )
            	    {
            	        // /home/project/sitarV2/translator/grammar/sitar.g:527:5: ( code_block_regions | procedure_declaration )
            	        {
            	            int alt9=2;
            	            switch ( LA(1) )
            	            {
            	            case DECL:
            	            case INCLUDE:
            	            case INIT:
            	            	{
            	            		alt9=1;
            	            	}
            	                break;
            	            case PROCEDURE:
            	            	{
            	            		alt9=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 9;
            	                EXCEPTION->state        = 0;


            	                goto ruleprocedure_bodyEx;

            	            }

            	            switch (alt9)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:527:6: code_block_regions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_code_block_regions_in_procedure_body953);
            	        	        code_block_regions(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprocedure_bodyEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:527:27: procedure_declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_procedure_declaration_in_procedure_body957);
            	        	        procedure_declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprocedure_bodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


            // /home/project/sitarV2/translator/grammar/sitar.g:528:3: ( behavior_block ( code_block_regions )* )?
            {
                int alt12=2;
                switch ( LA(1) )
                {
                    case BEHAVIOR:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:528:5: behavior_block ( code_block_regions )*
            	    {
            	        FOLLOWPUSH(FOLLOW_behavior_block_in_procedure_body988);
            	        behavior_block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_bodyEx;
            	        }


            	        {
            	            (SCOPE_TOP(du))->has_behavior=true;
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:528:45: ( code_block_regions )*

            	        for (;;)
            	        {
            	            int alt11=2;
            	            switch ( LA(1) )
            	            {
            	            case DECL:
            	            case INCLUDE:
            	            case INIT:
            	            	{
            	            		alt11=1;
            	            	}
            	                break;

            	            }

            	            switch (alt11)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:528:46: code_block_regions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_code_block_regions_in_procedure_body992);
            	        	        code_block_regions(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprocedure_bodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop11;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop11: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprocedure_bodyEx; /* Prevent compiler warnings */
    ruleprocedure_bodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end procedure_body */

/**
 * $ANTLR start code_block_regions
 * /home/project/sitarV2/translator/grammar/sitar.g:535:1: code_block_regions : ( include_block | declaration_block | initialization_block );
 */
static void
code_block_regions(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:536:2: ( include_block | declaration_block | initialization_block )

            ANTLR3_UINT32 alt13;

            alt13=3;

            switch ( LA(1) )
            {
            case INCLUDE:
            	{
            		alt13=1;
            	}
                break;
            case DECL:
            	{
            		alt13=2;
            	}
                break;
            case INIT:
            	{
            		alt13=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto rulecode_block_regionsEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:536:4: include_block
        	    {
        	        FOLLOWPUSH(FOLLOW_include_block_in_code_block_regions1014);
        	        include_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_regionsEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:537:4: declaration_block
        	    {
        	        FOLLOWPUSH(FOLLOW_declaration_block_in_code_block_regions1019);
        	        declaration_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_regionsEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:538:4: initialization_block
        	    {
        	        FOLLOWPUSH(FOLLOW_initialization_block_in_code_block_regions1024);
        	        initialization_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_regionsEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecode_block_regionsEx; /* Prevent compiler warnings */
    rulecode_block_regionsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end code_block_regions */

/**
 * $ANTLR start include_block
 * /home/project/sitarV2/translator/grammar/sitar.g:540:1: include_block : INCLUDE c= code_block_with_info ;
 */
static void
include_block(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:541:2: ( INCLUDE c= code_block_with_info )
        // /home/project/sitarV2/translator/grammar/sitar.g:541:4: INCLUDE c= code_block_with_info
        {
             MATCHT(INCLUDE, &FOLLOW_INCLUDE_in_include_block1034);
            if  (HASEXCEPTION())
            {
                goto ruleinclude_blockEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_include_block1038);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinclude_blockEx;
            }


            {
                	I_file<<c.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinclude_blockEx; /* Prevent compiler warnings */
    ruleinclude_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end include_block */

/**
 * $ANTLR start declaration_block
 * /home/project/sitarV2/translator/grammar/sitar.g:545:1: declaration_block : DECL c= code_block_with_info ;
 */
static void
declaration_block(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:546:2: ( DECL c= code_block_with_info )
        // /home/project/sitarV2/translator/grammar/sitar.g:546:4: DECL c= code_block_with_info
        {
             MATCHT(DECL, &FOLLOW_DECL_in_declaration_block1051);
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_blockEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_declaration_block1055);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_blockEx;
            }


            {
                	D_file<<c.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_blockEx; /* Prevent compiler warnings */
    ruledeclaration_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration_block */

/**
 * $ANTLR start initialization_block
 * /home/project/sitarV2/translator/grammar/sitar.g:550:1: initialization_block : INIT c= code_block_with_info ;
 */
static void
initialization_block(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:551:2: ( INIT c= code_block_with_info )
        // /home/project/sitarV2/translator/grammar/sitar.g:551:4: INIT c= code_block_with_info
        {
             MATCHT(INIT, &FOLLOW_INIT_in_initialization_block1068);
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_blockEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_initialization_block1072);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_blockEx;
            }


            {
                	C_file<<c.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinitialization_blockEx; /* Prevent compiler warnings */
    ruleinitialization_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end initialization_block */

/**
 * $ANTLR start structural_component_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:559:1: structural_component_declaration : ( port_declaration | net_declaration | submodule_declaration | connection ) ;
 */
static void
structural_component_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:560:2: ( ( port_declaration | net_declaration | submodule_declaration | connection ) )
        // /home/project/sitarV2/translator/grammar/sitar.g:564:3: ( port_declaration | net_declaration | submodule_declaration | connection )
        {
            // /home/project/sitarV2/translator/grammar/sitar.g:564:3: ( port_declaration | net_declaration | submodule_declaration | connection )
            {
                int alt14=4;
                switch ( LA(1) )
                {
                case INPORT:
                case INPORT_ARRAY:
                case OUTPORT:
                case OUTPORT_ARRAY:
                	{
                		alt14=1;
                	}
                    break;
                case NET:
                case NET_ARRAY:
                	{
                		alt14=2;
                	}
                    break;
                case SUBMODULE:
                case SUBMODULE_ARRAY:
                	{
                		alt14=3;
                	}
                    break;
                case FOR:
                case IDENTIFIER:
                	{
                		alt14=4;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulestructural_component_declarationEx;

                }

                switch (alt14)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:564:5: port_declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_port_declaration_in_structural_component_declaration1100);
            	        port_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:565:5: net_declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_net_declaration_in_structural_component_declaration1106);
            	        net_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:566:5: submodule_declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_submodule_declaration_in_structural_component_declaration1112);
            	        submodule_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:567:5: connection
            	    {
            	        FOLLOWPUSH(FOLLOW_connection_in_structural_component_declaration1118);
            	        connection(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestructural_component_declarationEx; /* Prevent compiler warnings */
    rulestructural_component_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end structural_component_declaration */

/**
 * $ANTLR start parameter_declaration_region
 * /home/project/sitarV2/translator/grammar/sitar.g:577:1: parameter_declaration_region : ( parameter_declaration ( ';' )? )+ ;
 */
static void
parameter_declaration_region(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:578:2: ( ( parameter_declaration ( ';' )? )+ )
        // /home/project/sitarV2/translator/grammar/sitar.g:578:5: ( parameter_declaration ( ';' )? )+
        {
            // /home/project/sitarV2/translator/grammar/sitar.g:578:5: ( parameter_declaration ( ';' )? )+
            {
                int cnt16=0;

                for (;;)
                {
                    int alt16=2;
            	switch ( LA(1) )
            	{
            	case PARAMETER:
            		{
            			alt16=1;
            		}
            	    break;

            	}

            	switch (alt16)
            	{
            	    case 1:
            	        // /home/project/sitarV2/translator/grammar/sitar.g:578:6: parameter_declaration ( ';' )?
            	        {
            	            FOLLOWPUSH(FOLLOW_parameter_declaration_in_parameter_declaration_region1146);
            	            parameter_declaration(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparameter_declaration_regionEx;
            	            }


            	            // /home/project/sitarV2/translator/grammar/sitar.g:578:28: ( ';' )?
            	            {
            	                int alt15=2;
            	                switch ( LA(1) )
            	                {
            	                    case 77:
            	                    	{
            	                    		alt15=1;
            	                    	}
            	                        break;
            	                }

            	                switch (alt15)
            	                {
            	            	case 1:
            	            	    // /home/project/sitarV2/translator/grammar/sitar.g:578:28: ';'
            	            	    {
            	            	         MATCHT(77, &FOLLOW_77_in_parameter_declaration_region1148);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleparameter_declaration_regionEx;
            	            	        }


            	            	    }
            	            	    break;

            	                }
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt16 >= 1 )
            		{
            		    goto loop16;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleparameter_declaration_regionEx;
            	}
            	cnt16++;
                }
                loop16: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparameter_declaration_regionEx; /* Prevent compiler warnings */
    ruleparameter_declaration_regionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parameter_declaration_region */

/**
 * $ANTLR start parameter_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:583:1: parameter_declaration : PARAMETER pt= param_type id= IDENTIFIER EQUALS val= default_value ;
 */
static void
parameter_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;
    sitarParser_param_type_return pt;
    #undef	RETURN_TYPE_pt
    #define	RETURN_TYPE_pt sitarParser_param_type_return

    sitarParser_default_value_return val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val sitarParser_default_value_return

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:584:2: ( PARAMETER pt= param_type id= IDENTIFIER EQUALS val= default_value )
        // /home/project/sitarV2/translator/grammar/sitar.g:584:5: PARAMETER pt= param_type id= IDENTIFIER EQUALS val= default_value
        {
             MATCHT(PARAMETER, &FOLLOW_PARAMETER_in_parameter_declaration1168);
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_param_type_in_parameter_declaration1172);
            pt=param_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_parameter_declaration1176);
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


             MATCHT(EQUALS, &FOLLOW_EQUALS_in_parameter_declaration1179);
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_default_value_in_parameter_declaration1183);
            val=default_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            {

                			//store this information into lists maintained 
                			//per module_description
                			(SCOPE_TOP(du))->has_parameters=true;
                			assert((SCOPE_TOP(du))->param_name!=NULL);
                			assert((SCOPE_TOP(du))->param_type!=NULL);
                			assert((SCOPE_TOP(du))->param_value!=NULL);

                			(SCOPE_TOP(du))->param_type->push_back(std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, pt.start, pt.stop))
                ->chars)));
                			(SCOPE_TOP(du))->param_name->push_back(std::string((const char*)((id->getText(id))->chars)));
                			(SCOPE_TOP(du))->param_value->push_back(std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, val.start, val.stop))
                ->chars)));
                			
                			//the 3 lists should be in sync
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_value->size());
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_type->size());

                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparameter_declarationEx; /* Prevent compiler warnings */
    ruleparameter_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parameter_declaration */

/**
 * $ANTLR start param_type
 * /home/project/sitarV2/translator/grammar/sitar.g:605:1: param_type : ( KEYWORD_INT | KEYWORD_BOOL | KEYWORD_CHAR );
 */
static sitarParser_param_type_return
param_type(psitarParser ctx)
{
    sitarParser_param_type_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:606:2: ( KEYWORD_INT | KEYWORD_BOOL | KEYWORD_CHAR )
        // /home/project/sitarV2/translator/grammar/sitar.g:
        {
            if ( ((LA(1) >= KEYWORD_BOOL) && (LA(1) <= KEYWORD_INT)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleparam_typeEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparam_typeEx; /* Prevent compiler warnings */
    ruleparam_typeEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end param_type */

/**
 * $ANTLR start default_value
 * /home/project/sitarV2/translator/grammar/sitar.g:612:1: default_value : ( integer | BOOL | CHAR );
 */
static sitarParser_default_value_return
default_value(psitarParser ctx)
{
    sitarParser_default_value_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:613:2: ( integer | BOOL | CHAR )

            ANTLR3_UINT32 alt17;

            alt17=3;

            switch ( LA(1) )
            {
            case INTEGER:
            case MINUS:
            	{
            		alt17=1;
            	}
                break;
            case BOOL:
            	{
            		alt17=2;
            	}
                break;
            case CHAR:
            	{
            		alt17=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto ruledefault_valueEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:613:6: integer
        	    {
        	        FOLLOWPUSH(FOLLOW_integer_in_default_value1227);
        	        integer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_valueEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:613:16: BOOL
        	    {
        	         MATCHT(BOOL, &FOLLOW_BOOL_in_default_value1231);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_valueEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:613:23: CHAR
        	    {
        	         MATCHT(CHAR, &FOLLOW_CHAR_in_default_value1235);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_valueEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledefault_valueEx; /* Prevent compiler warnings */
    ruledefault_valueEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end default_value */

/**
 * $ANTLR start integer
 * /home/project/sitarV2/translator/grammar/sitar.g:615:1: integer : ( '-' )? INTEGER ;
 */
static void
integer(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:616:2: ( ( '-' )? INTEGER )
        // /home/project/sitarV2/translator/grammar/sitar.g:617:2: ( '-' )? INTEGER
        {
            // /home/project/sitarV2/translator/grammar/sitar.g:617:2: ( '-' )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case MINUS:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:617:2: '-'
            	    {
            	         MATCHT(MINUS, &FOLLOW_MINUS_in_integer1247);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintegerEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(INTEGER, &FOLLOW_INTEGER_in_integer1250);
            if  (HASEXCEPTION())
            {
                goto ruleintegerEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleintegerEx; /* Prevent compiler warnings */
    ruleintegerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end integer */

/**
 * $ANTLR start port_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:628:1: port_declaration : ( inport_declaration | inport_array_declaration | outport_declaration | outport_array_declaration );
 */
static void
port_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_port_declarationTop = psitarParser_port_declarationPush(ctx);

    (SCOPE_TOP(port_declaration))->has_width=false;

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:637:2: ( inport_declaration | inport_array_declaration | outport_declaration | outport_array_declaration )

            ANTLR3_UINT32 alt19;

            alt19=4;

            switch ( LA(1) )
            {
            case INPORT:
            	{
            		alt19=1;
            	}
                break;
            case INPORT_ARRAY:
            	{
            		alt19=2;
            	}
                break;
            case OUTPORT:
            	{
            		alt19=3;
            	}
                break;
            case OUTPORT_ARRAY:
            	{
            		alt19=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto ruleport_declarationEx;

            }

            switch (alt19)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:637:4: inport_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_inport_declaration_in_port_declaration1278);
        	        inport_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:638:4: inport_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_inport_array_declaration_in_port_declaration1283);
        	        inport_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:639:4: outport_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_outport_declaration_in_port_declaration1288);
        	        outport_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:640:4: outport_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_outport_array_declaration_in_port_declaration1293);
        	        outport_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleport_declarationEx; /* Prevent compiler warnings */
    ruleport_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    psitarParser_port_declarationPop(ctx);

    return ;
}
/* $ANTLR end port_declaration */

/**
 * $ANTLR start inport_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:645:1: inport_declaration : INPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? ;
 */
static void
inport_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;
    		

    id1       = NULL;
    id2       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:659:2: ( INPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:659:4: INPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )?
        {
             MATCHT(INPORT, &FOLLOW_INPORT_in_inport_declaration1318);
            if  (HASEXCEPTION())
            {
                goto ruleinport_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_inport_declaration1322);
            if  (HASEXCEPTION())
            {
                goto ruleinport_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:665:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt20=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:665:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_inport_declaration1334);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_inport_declaration1338);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


            // /home/project/sitarV2/translator/grammar/sitar.g:670:7: ( COLON WIDTH e1= expression )?
            {
                int alt21=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:670:8: COLON WIDTH e1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_inport_declaration1352);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_inport_declaration1354);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_inport_declaration1358);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars));
                		else w = "0";
                					
                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                	 		
                			
                			//Add port as data member of module class
                			D_file<<"\ninport<"<<w<<"> "<<s<<";";
                	 		
                			//Initialize port attributes in the contructor
                			C_file<<"\n//---Initializing inport "<<s<<"---";
                			C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                			C_file<<"\naddInport(&"<<s<<",\""<<s<<"\");\n";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinport_declarationEx; /* Prevent compiler warnings */
    ruleinport_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//empty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end inport_declaration */

/**
 * $ANTLR start inport_array_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:694:1: inport_array_declaration : INPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? ;
 */
static void
inport_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_expression_return w1;
    #undef	RETURN_TYPE_w1
    #define	RETURN_TYPE_w1 sitarParser_expression_return

    /* Initialize rule variables
     */

     
    	int flag_2D=0;
    	std::string port;
    	std::string portij;
    	std::string pname;

    id1       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:709:2: ( INPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:709:4: INPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )?
        {
             MATCHT(INPORT_ARRAY, &FOLLOW_INPORT_ARRAY_in_inport_array_declaration1394);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_inport_array_declaration1398);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_inport_array_declaration1400);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_inport_array_declaration1404);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_inport_array_declaration1407);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:710:9: ( '[' e2= expression ']' )?
            {
                int alt22=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt22=1;
                    	}
                        break;
                }

                switch (alt22)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:710:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_inport_array_declaration1420);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_inport_array_declaration1424);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_inport_array_declaration1428);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

            // /home/project/sitarV2/translator/grammar/sitar.g:710:48: ( COLON WIDTH w1= expression )?
            {
                int alt23=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:710:49: COLON WIDTH w1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_inport_array_declaration1434);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_inport_array_declaration1436);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_inport_array_declaration1440);
            	        w1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width) 
                		  w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, w1.start, w1.stop))
                ->chars));
                		else w = "0";
                		
                		port=(std::string((const char*)((id1->getText(id1))->chars)));
                		
                		if(flag_2D==0)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"";
                			portij= port + "[i]";
                			
                			//Add port as data member to module class
                			D_file<<"\ninport<"<<w<<"> "<<port<<"["<<
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"];";


                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing inport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddInport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n";

                		}
                		else if(flag_2D==1)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                			portij= port + "[i][j]";
                				
                			//Add port as data member to module class
                			D_file<<"\ninport<"<<w<<"> "<<port<<"["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"];";

                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing inport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddInport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n}\n";
                		}

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinport_array_declarationEx; /* Prevent compiler warnings */
    ruleinport_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;

                }
            }


    return ;
}
/* $ANTLR end inport_array_declaration */

/**
 * $ANTLR start outport_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:758:1: outport_declaration : OUTPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? ;
 */
static void
outport_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;

    id1       = NULL;
    id2       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:771:2: ( OUTPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:771:4: OUTPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )?
        {
             MATCHT(OUTPORT, &FOLLOW_OUTPORT_in_outport_declaration1472);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_outport_declaration1476);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:777:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt24=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt24=1;
                	}
                    break;

                }

                switch (alt24)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:777:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_outport_declaration1488);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_outport_declaration1492);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop24;	/* break out of the loop */
            	    break;
                }
            }
            loop24: ; /* Jump out to here if this rule does not match */


            // /home/project/sitarV2/translator/grammar/sitar.g:782:7: ( COLON WIDTH e1= expression )?
            {
                int alt25=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt25=1;
                    	}
                        break;
                }

                switch (alt25)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:782:8: COLON WIDTH e1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_outport_declaration1506);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_outport_declaration1508);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_outport_declaration1512);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars));
                		else w = "0";
                			
                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                	 		
                			
                			//Add port as data member to module class
                			D_file<<"\noutport<"<<w<<"> "<<s<<";";
                	 		
                			//Initialize port attributes in the contructor
                			C_file<<"\n//---Initializing outport "<<s<<"---";
                			C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                			C_file<<"\naddOutport(&"<<s<<",\""<<s<<"\");\n";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoutport_declarationEx; /* Prevent compiler warnings */
    ruleoutport_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//Empty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end outport_declaration */

/**
 * $ANTLR start outport_array_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:806:1: outport_array_declaration : OUTPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? ;
 */
static void
outport_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_expression_return w1;
    #undef	RETURN_TYPE_w1
    #define	RETURN_TYPE_w1 sitarParser_expression_return

    /* Initialize rule variables
     */

     
    	int flag_2D=0;
    	std::string port;
    	std::string portij;
    	std::string pname;

    id1       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:821:2: ( OUTPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:821:4: OUTPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )?
        {
             MATCHT(OUTPORT_ARRAY, &FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1546);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_outport_array_declaration1550);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_outport_array_declaration1552);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_outport_array_declaration1556);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_outport_array_declaration1559);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:822:9: ( '[' e2= expression ']' )?
            {
                int alt26=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt26=1;
                    	}
                        break;
                }

                switch (alt26)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:822:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_outport_array_declaration1572);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_outport_array_declaration1576);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_outport_array_declaration1580);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

            // /home/project/sitarV2/translator/grammar/sitar.g:822:49: ( COLON WIDTH w1= expression )?
            {
                int alt27=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt27=1;
                    	}
                        break;
                }

                switch (alt27)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:822:50: COLON WIDTH w1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_outport_array_declaration1587);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_outport_array_declaration1589);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_outport_array_declaration1593);
            	        w1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width==true) 
                		 w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, w1.start, w1.stop))
                ->chars));
                		else w = "0";
                		port=(std::string((const char*)((id1->getText(id1))->chars)));
                		
                		if(flag_2D==0)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"";
                			portij= port + "[i]";
                			
                			//Add port as data member to module class
                			D_file<<"\noutport<"<<w<<"> "<<port<<"["<<
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"];";

                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing outport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddOutport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n";

                		}
                		else if(flag_2D==1)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                			portij= port + "[i][j]";
                				
                			//Add port as data member to module class
                			D_file<<"\noutport<"<<w<<"> "<<port<<"["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"];";

                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing outport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddOutport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n}\n";
                		}

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoutport_array_declarationEx; /* Prevent compiler warnings */
    ruleoutport_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;

                }
            }


    return ;
}
/* $ANTLR end outport_array_declaration */

/**
 * $ANTLR start net_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:880:1: net_declaration : ( simple_net_declaration | net_array_declaration );
 */
static void
net_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_net_declarationTop = psitarParser_net_declarationPush(ctx);

    (SCOPE_TOP(net_declaration))->has_width=false;

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:889:2: ( simple_net_declaration | net_array_declaration )

            ANTLR3_UINT32 alt28;

            alt28=2;

            switch ( LA(1) )
            {
            case NET:
            	{
            		alt28=1;
            	}
                break;
            case NET_ARRAY:
            	{
            		alt28=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto rulenet_declarationEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:889:4: simple_net_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_simple_net_declaration_in_net_declaration1632);
        	        simple_net_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenet_declarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:890:4: net_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_net_array_declaration_in_net_declaration1637);
        	        net_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenet_declarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulenet_declarationEx; /* Prevent compiler warnings */
    rulenet_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    psitarParser_net_declarationPop(ctx);

    return ;
}
/* $ANTLR end net_declaration */

/**
 * $ANTLR start simple_net_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:894:1: simple_net_declaration : NET id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON CAPACITY c= expression ( WIDTH e1= expression )? ;
 */
static void
simple_net_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    sitarParser_expression_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_expression_return

    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;

    id1       = NULL;
    id2       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:908:2: ( NET id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON CAPACITY c= expression ( WIDTH e1= expression )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:908:4: NET id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON CAPACITY c= expression ( WIDTH e1= expression )?
        {
             MATCHT(NET, &FOLLOW_NET_in_simple_net_declaration1662);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_net_declaration1667);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:914:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt29=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt29=1;
                	}
                    break;

                }

                switch (alt29)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:914:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_simple_net_declaration1679);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_net_declaration1683);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop29;	/* break out of the loop */
            	    break;
                }
            }
            loop29: ; /* Jump out to here if this rule does not match */


             MATCHT(COLON, &FOLLOW_COLON_in_simple_net_declaration1701);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


             MATCHT(CAPACITY, &FOLLOW_CAPACITY_in_simple_net_declaration1703);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_simple_net_declaration1708);
            c=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:922:3: ( WIDTH e1= expression )?
            {
                int alt30=2;
                switch ( LA(1) )
                {
                    case WIDTH:
                    	{
                    		alt30=1;
                    	}
                        break;
                }

                switch (alt30)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:922:4: WIDTH e1= expression
            	    {
            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_simple_net_declaration1715);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_simple_net_declaration1719);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(net_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(net_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars));
                		else w = "0";
                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                	 		
                			
                			//Add net as data member to module class
                			D_file<<"\nnet<"<<w<<"> "<<s<<";"; 					//net
                			D_file<<"\ntoken<"<<w<<"> "<<s<<"_buffer["<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<"];";	//token buffer for net
                	 		
                			//Initialize port attributes in the contructor
                			C_file<<"\n//---Initializing net "<<s<<"---";
                			C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                			C_file<<"\n"<<s<<".setBuffer("<<s<<"_buffer,"<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<");";
                			C_file<<"\naddNet(&"<<s<<",\""<<s<<"\");\n";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimple_net_declarationEx; /* Prevent compiler warnings */
    rulesimple_net_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end simple_net_declaration */

/**
 * $ANTLR start net_array_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:947:1: net_array_declaration : NET_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON CAPACITY c= expression ( WIDTH e11= expression )? ;
 */
static void
net_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_expression_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_expression_return

    sitarParser_expression_return e11;
    #undef	RETURN_TYPE_e11
    #define	RETURN_TYPE_e11 sitarParser_expression_return

    /* Initialize rule variables
     */

     
    	int flag_2D=0; //0 implies net array is 1 dimensional, else 2-dimensional
    	std::string net;
    	std::string netij;
    	std::string nname;

    id1       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:961:2: ( NET_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON CAPACITY c= expression ( WIDTH e11= expression )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:961:4: NET_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON CAPACITY c= expression ( WIDTH e11= expression )?
        {
             MATCHT(NET_ARRAY, &FOLLOW_NET_ARRAY_in_net_array_declaration1752);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_net_array_declaration1756);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_net_array_declaration1758);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1762);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_net_array_declaration1765);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:962:9: ( '[' e2= expression ']' )?
            {
                int alt31=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt31=1;
                    	}
                        break;
                }

                switch (alt31)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:962:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_net_array_declaration1778);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1782);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_net_array_declaration1786);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(COLON, &FOLLOW_COLON_in_net_array_declaration1790);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


             MATCHT(CAPACITY, &FOLLOW_CAPACITY_in_net_array_declaration1792);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1796);
            c=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:963:9: ( WIDTH e11= expression )?
            {
                int alt32=2;
                switch ( LA(1) )
                {
                    case WIDTH:
                    	{
                    		alt32=1;
                    	}
                        break;
                }

                switch (alt32)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:963:10: WIDTH e11= expression
            	    {
            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_net_array_declaration1808);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1812);
            	        e11=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(net_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(net_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e11.start, e11.stop))
                ->chars));
                		else w = "0";
                		net=(std::string((const char*)((id1->getText(id1))->chars)));
                		
                		if(flag_2D==0)
                		{
                			nname="\""+net+"[\"+sitar::toString(i)+\"]\"";
                			netij= net + "[i]";
                			
                			//Add net as data member to module class
                			D_file<<"\nnet<"<<w<<"> "<<net<<"["<<
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"];";
                			D_file<<"\ntoken<"<<w<<"> "<<net<<"_buffer["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<"];";	//token buffer for net

                			//Initialize net attributes in the contructor
                			C_file<<"\n//----Initializing net-array "<<net<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nstd::string nname="<<nname<<";";
                			C_file<<"\n"<<netij<<".setInstanceId(nname);";
                			C_file<<"\n"<<netij<<".setBuffer("<<net<<"_buffer[i],"<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<");";
                			C_file<<"\naddNet(&"<<netij<<","<<nname<<");\n";
                			C_file<<"\n}\n";

                		}
                		else if(flag_2D==1)
                		{
                			nname="\""+net+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                			netij= net + "[i][j]";
                				
                			//Add net as data member to module class
                			D_file<<"\nnet<"<<w<<"> "<<net<<"["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"];";
                			D_file<<"\ntoken<"<<w<<"> "<<net<<"_buffer["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<"];";	//token buffer for net

                			//Initialize net attributes in the contructor
                			C_file<<"\n//----Initializing net-array "<<net<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			C_file<<"\nstd::string nname="<<nname<<";";
                			C_file<<"\n"<<netij<<".setInstanceId(nname);";
                			C_file<<"\n"<<netij<<".setBuffer("<<net<<"_buffer[i][j],"<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<");";
                			C_file<<"\naddNet(&"<<netij<<","<<nname<<");\n";
                			C_file<<"\n}\n}\n";
                		}

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenet_array_declarationEx; /* Prevent compiler warnings */
    rulenet_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;

                }
            }


    return ;
}
/* $ANTLR end net_array_declaration */

/**
 * $ANTLR start submodule_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:1016:1: submodule_declaration : ( simple_submodule_declaration | submodule_array_declaration );
 */
static void
submodule_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1017:2: ( simple_submodule_declaration | submodule_array_declaration )

            ANTLR3_UINT32 alt33;

            alt33=2;

            switch ( LA(1) )
            {
            case SUBMODULE:
            	{
            		alt33=1;
            	}
                break;
            case SUBMODULE_ARRAY:
            	{
            		alt33=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 33;
                EXCEPTION->state        = 0;


                goto rulesubmodule_declarationEx;

            }

            switch (alt33)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1017:4: simple_submodule_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_simple_submodule_declaration_in_submodule_declaration1834);
        	        simple_submodule_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesubmodule_declarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1018:4: submodule_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_submodule_array_declaration_in_submodule_declaration1839);
        	        submodule_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesubmodule_declarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesubmodule_declarationEx; /* Prevent compiler warnings */
    rulesubmodule_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end submodule_declaration */

/**
 * $ANTLR start simple_submodule_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:1023:1: simple_submodule_declaration : SUBMODULE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? ;
 */
static void
simple_submodule_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    pANTLR3_COMMON_TOKEN    mod_type;
    sitarParser_template_arguments_return template_arguments1;
    #undef	RETURN_TYPE_template_arguments1
    #define	RETURN_TYPE_template_arguments1 sitarParser_template_arguments_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;
    	std::string mname; //name/type of the submodule
    	std::string fname; //name of file that contains submodule description
    	bool flag1=0;	   //flag1==1 indicates the submodule has template arguments.
    	bool flag2=0;

    id1       = NULL;
    id2       = NULL;
    mod_type       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1041:2: ( SUBMODULE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:1041:4: SUBMODULE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )?
        {
             MATCHT(SUBMODULE, &FOLLOW_SUBMODULE_in_simple_submodule_declaration1863);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_submodule_declaration1867);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1047:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt34=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt34=1;
                	}
                    break;

                }

                switch (alt34)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1047:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_simple_submodule_declaration1879);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_submodule_declaration1883);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop34;	/* break out of the loop */
            	    break;
                }
            }
            loop34: ; /* Jump out to here if this rule does not match */


             MATCHT(COLON, &FOLLOW_COLON_in_simple_submodule_declaration1901);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            mod_type = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_submodule_declaration1905);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1054:29: ( '<' ( template_arguments )? '>' )?
            {
                int alt36=2;
                switch ( LA(1) )
                {
                    case 78:
                    	{
                    		alt36=1;
                    	}
                        break;
                }

                switch (alt36)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1054:30: '<' ( template_arguments )? '>'
            	    {
            	         MATCHT(78, &FOLLOW_78_in_simple_submodule_declaration1908);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1054:34: ( template_arguments )?
            	        {
            	            int alt35=2;
            	            switch ( LA(1) )
            	            {
            	                case BOOL:
            	                case CHAR:
            	                case IDENTIFIER:
            	                case INTEGER:
            	                case MINUS:
            	                case STRING:
            	                case 72:
            	                	{
            	                		alt35=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt35)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1054:35: template_arguments
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_template_arguments_in_simple_submodule_declaration1911);
            	        	        template_arguments1=template_arguments(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesimple_submodule_declarationEx;
            	        	        }


            	        	        {
            	        	            flag2=1;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(80, &FOLLOW_80_in_simple_submodule_declaration1916);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        {
            	            flag1=1;
            	        }


            	    }
            	    break;

                }
            }

            {

                			//Generate type-name of the module
                			fname= (const char*)((mod_type->getText(mod_type))->chars);
                			mname=fname;
                			if(flag1==1)
                			{
                			  mname=mname+"<" ;
                			  if(flag2==1)
                			  	mname=mname +(const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, template_arguments1.start, template_arguments1.stop))
                ->chars);
                			  mname=mname+">";
                			  }
                			
                                                                                         //Include the header that contains description of
                			//Submodule
                			I_file<<"\n#include\""<<OUTPUT_FILE_PREFIX_STR<<fname<<".h\"";
                			
                	        	while(!list1.empty())
                	 	 	{
                				s = list1.front();
                				list1.pop_front();

                								
                				//Add Submodule as data member of module class
                				D_file<<"\n"<<mname<<" "<<s<<";";
                				
                				
                				
                				//Initialize Submodule instance in the contructor
                				C_file<<"\n//---Initializing submodule "<<s<<"---";
                				C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                				C_file<<"\naddSubmodule(&"<<s<<",\""<<s<<"\");\n";
                	 	 	}
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimple_submodule_declarationEx; /* Prevent compiler warnings */
    rulesimple_submodule_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();
                    	flag1=0;
                    	flag2=0;

                }
            }


    return ;
}
/* $ANTLR end simple_submodule_declaration */

/**
 * $ANTLR start template_arguments
 * /home/project/sitarV2/translator/grammar/sitar.g:1090:1: template_arguments : argument ( ',' argument )* ;
 */
static sitarParser_template_arguments_return
template_arguments(psitarParser ctx)
{
    sitarParser_template_arguments_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1091:2: ( argument ( ',' argument )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:1091:4: argument ( ',' argument )*
        {
            FOLLOWPUSH(FOLLOW_argument_in_template_arguments1937);
            argument(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletemplate_argumentsEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1091:13: ( ',' argument )*

            for (;;)
            {
                int alt37=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt37=1;
                	}
                    break;

                }

                switch (alt37)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1091:14: ',' argument
            	    {
            	         MATCHT(75, &FOLLOW_75_in_template_arguments1940);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletemplate_argumentsEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_argument_in_template_arguments1942);
            	        argument(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletemplate_argumentsEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletemplate_argumentsEx; /* Prevent compiler warnings */
    ruletemplate_argumentsEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end template_arguments */

/**
 * $ANTLR start argument
 * /home/project/sitarV2/translator/grammar/sitar.g:1093:1: argument : ( BOOL | CHAR | STRING | expression );
 */
static void
argument(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1094:2: ( BOOL | CHAR | STRING | expression )

            ANTLR3_UINT32 alt38;

            alt38=4;

            switch ( LA(1) )
            {
            case BOOL:
            	{
            		alt38=1;
            	}
                break;
            case CHAR:
            	{
            		alt38=2;
            	}
                break;
            case STRING:
            	{
            		alt38=3;
            	}
                break;
            case IDENTIFIER:
            case INTEGER:
            case MINUS:
            case 72:
            	{
            		alt38=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 38;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;

            }

            switch (alt38)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1094:5: BOOL
        	    {
        	         MATCHT(BOOL, &FOLLOW_BOOL_in_argument1956);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1094:12: CHAR
        	    {
        	         MATCHT(CHAR, &FOLLOW_CHAR_in_argument1960);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1094:19: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_argument1964);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1094:28: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_argument1968);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end argument */

/**
 * $ANTLR start submodule_array_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:1100:1: submodule_array_declaration : SUBMODULE_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON mod_type= IDENTIFIER ( '<' (t= template_arguments )? '>' )? ;
 */
static void
submodule_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    mod_type;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_template_arguments_return t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t sitarParser_template_arguments_return

    /* Initialize rule variables
     */

     
    	bool flag_2D=0; //1 implies array is 2-dimensional, else 1D
    	bool flag1=0; //1 implies submodule takes template arguments
    	bool flag2=0;


    	
    	//generate some handy strings for translation
    	//Eg. for input
    	//sr[2][3] :ShiftRegister<4>


    	//iname=sr[2][3]        instance name -goes into declaration
    	//inameij=sr[i][j]      for initilalizing the array inside a for loop
    	//inamestring="sr[" + "sitar::toString(i)" +"]".... ->for creating
    	//			an instance name at elaboration time
    	//tname=ShiftRegister<4> type name
    	//fname=ShiftRegister   Goes into the includes region as
    	//			#include"sitar_ShiftRegister.h"


    	std::string iname0;
    	std::string iname;
    	std::string inameij;
    	std::string inamestring;
    	std::string tname;
    	std::string fname;

    id1       = NULL;
    mod_type       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1140:2: ( SUBMODULE_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON mod_type= IDENTIFIER ( '<' (t= template_arguments )? '>' )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:1140:4: SUBMODULE_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON mod_type= IDENTIFIER ( '<' (t= template_arguments )? '>' )?
        {
             MATCHT(SUBMODULE_ARRAY, &FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1996);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_submodule_array_declaration2000);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_submodule_array_declaration2002);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_submodule_array_declaration2006);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_submodule_array_declaration2009);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1141:9: ( '[' e2= expression ']' )?
            {
                int alt39=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt39=1;
                    	}
                        break;
                }

                switch (alt39)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1141:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_submodule_array_declaration2022);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_submodule_array_declaration2026);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_submodule_array_declaration2030);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(COLON, &FOLLOW_COLON_in_submodule_array_declaration2052);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            mod_type = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_submodule_array_declaration2056);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1143:36: ( '<' (t= template_arguments )? '>' )?
            {
                int alt41=2;
                switch ( LA(1) )
                {
                    case 78:
                    	{
                    		alt41=1;
                    	}
                        break;
                }

                switch (alt41)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1143:37: '<' (t= template_arguments )? '>'
            	    {
            	         MATCHT(78, &FOLLOW_78_in_submodule_array_declaration2060);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1143:41: (t= template_arguments )?
            	        {
            	            int alt40=2;
            	            switch ( LA(1) )
            	            {
            	                case BOOL:
            	                case CHAR:
            	                case IDENTIFIER:
            	                case INTEGER:
            	                case MINUS:
            	                case STRING:
            	                case 72:
            	                	{
            	                		alt40=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt40)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1143:42: t= template_arguments
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_template_arguments_in_submodule_array_declaration2065);
            	        	        t=template_arguments(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesubmodule_array_declarationEx;
            	        	        }


            	        	        {
            	        	            flag2=1;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(80, &FOLLOW_80_in_submodule_array_declaration2071);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        {
            	            flag1=1;
            	        }


            	    }
            	    break;

                }
            }

            {

                		fname=(const char*)((mod_type->getText(mod_type))->chars);
                		tname=fname;
                		if(flag1==1)
                		{
                			tname=tname+"<";
                			if(flag2==1)
                			 tname+=(const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, t.start, t.stop))
                ->chars);
                			tname+=">";
                		}
                		
                		//Include the header that contains description of
                		//Submodule
                		I_file<<"\n#include\""<<OUTPUT_FILE_PREFIX_STR<<fname<<".h\"";


                		
                		
                		if(flag_2D==1)
                		{
                			iname0=std::string((const char*)((id1->getText(id1))->chars) );
                			iname=iname0+ "[" + (const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars) + "][" + (const char *) ((STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars) + "]";
                			inameij=iname0+"[i][j]";
                			inamestring="\""+iname0+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                				
                			//Add module as data member to module class
                			D_file<<"\n"<<tname<<" "<<iname<<";"; 

                			//Initialize module attributes in the contructor
                			C_file<<"\n//----Initializing module-array "<<fname<<"------";

                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			
                			C_file<<"\n"<<inameij<<".setInstanceId("<<inamestring<<");";
                			C_file<<"\naddSubmodule(&"<<inameij<<","<<inamestring<<");\n";
                			C_file<<"\n}\n}\n";
                		}
                		else if(flag_2D==0)
                		{
                			iname0=std::string((const char*)((id1->getText(id1))->chars) );
                			iname=iname0+"[" + (const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars) + "]";
                			inameij=iname0+"[i]";
                			inamestring="\""+iname0+"[\"+sitar::toString(i)+\"]\"";
                				
                			
                				
                			//Add module as data member to module class
                			D_file<<"\n"<<tname<<" "<<iname<<";"; 

                			//Initialize module attributes in the contructor
                			C_file<<"\n//----Initializing module-array "<<fname<<"------";

                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			
                			C_file<<"\n"<<inameij<<".setInstanceId("<<inamestring<<");";
                			C_file<<"\naddSubmodule(&"<<inameij<<","<<inamestring<<");\n";
                			C_file<<"\n}\n";
                		}
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubmodule_array_declarationEx; /* Prevent compiler warnings */
    rulesubmodule_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;
                    	flag1=0;
                    	flag2=0;

                }
            }


    return ;
}
/* $ANTLR end submodule_array_declaration */

/**
 * $ANTLR start procedure_declaration
 * /home/project/sitarV2/translator/grammar/sitar.g:1208:1: procedure_declaration : PROCEDURE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? ;
 */
static void
procedure_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    pANTLR3_COMMON_TOKEN    mod_type;
    sitarParser_template_arguments_return template_arguments2;
    #undef	RETURN_TYPE_template_arguments2
    #define	RETURN_TYPE_template_arguments2 sitarParser_template_arguments_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;
    	std::string mname; //name/type of the  procedure
    	std::string fname; //name of file that contains procedure description
    	bool flag1=0;	   //flag1==1 indicates the procedure has template arguments.
    	bool flag2=0;

    id1       = NULL;
    id2       = NULL;
    mod_type       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1226:2: ( PROCEDURE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:1226:4: PROCEDURE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )?
        {
             MATCHT(PROCEDURE, &FOLLOW_PROCEDURE_in_procedure_declaration2104);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_declaration2111);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1232:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt42=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt42=1;
                	}
                    break;

                }

                switch (alt42)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1232:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_procedure_declaration2123);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_declaration2127);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


             MATCHT(COLON, &FOLLOW_COLON_in_procedure_declaration2145);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            mod_type = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_declaration2149);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1239:29: ( '<' ( template_arguments )? '>' )?
            {
                int alt44=2;
                switch ( LA(1) )
                {
                    case 78:
                    	{
                    		alt44=1;
                    	}
                        break;
                }

                switch (alt44)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1239:30: '<' ( template_arguments )? '>'
            	    {
            	         MATCHT(78, &FOLLOW_78_in_procedure_declaration2152);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1239:34: ( template_arguments )?
            	        {
            	            int alt43=2;
            	            switch ( LA(1) )
            	            {
            	                case BOOL:
            	                case CHAR:
            	                case IDENTIFIER:
            	                case INTEGER:
            	                case MINUS:
            	                case STRING:
            	                case 72:
            	                	{
            	                		alt43=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt43)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1239:35: template_arguments
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_template_arguments_in_procedure_declaration2155);
            	        	        template_arguments2=template_arguments(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprocedure_declarationEx;
            	        	        }


            	        	        {
            	        	            flag2=1;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(80, &FOLLOW_80_in_procedure_declaration2160);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        {
            	            flag1=1;
            	        }


            	    }
            	    break;

                }
            }

            {

                			//Generate type-name of the module
                			fname= (const char*)((mod_type->getText(mod_type))->chars);
                			mname=fname;
                			if(flag1==1)
                			{
                			  mname=mname+"<" ;
                			  if(flag2==1)
                			  	mname=mname +(const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, template_arguments2.start, template_arguments2.stop))
                ->chars);
                			  mname=mname+">";
                			  }
                			

                			
                	        	while(!list1.empty())
                	 	 	{
                				s = list1.front();
                				list1.pop_front();

                				//Include the header that contains description of
                				//procedure
                				I_file<<"\n#include\""<<OUTPUT_FILE_PREFIX_STR<<fname<<".h\"";
                				
                				
                				//Add Submodule as data member of module class
                				D_file<<"\n"<<mname<<" "<<s<<";";
                				
                				
                				
                				//Initialize Submodule instance in the contructor
                				C_file<<"\n//---Initializing procedure instance "<<s<<"---";
                				C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                				C_file<<"\naddProcedure(&"<<s<<",\""<<s<<"\");\n";
                	 	 	}
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprocedure_declarationEx; /* Prevent compiler warnings */
    ruleprocedure_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();
                    	flag1=0;
                    	flag2=0;

                }
            }


    return ;
}
/* $ANTLR end procedure_declaration */

/**
 * $ANTLR start connection
 * /home/project/sitarV2/translator/grammar/sitar.g:1284:1: connection : ( simple_connect_statement | for_loop_for_connections );
 */
static void
connection(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1285:2: ( simple_connect_statement | for_loop_for_connections )

            ANTLR3_UINT32 alt45;

            alt45=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt45=1;
            	}
                break;
            case FOR:
            	{
            		alt45=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 45;
                EXCEPTION->state        = 0;


                goto ruleconnectionEx;

            }

            switch (alt45)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1285:4: simple_connect_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_simple_connect_statement_in_connection2188);
        	        simple_connect_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconnectionEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1286:4: for_loop_for_connections
        	    {
        	        FOLLOWPUSH(FOLLOW_for_loop_for_connections_in_connection2194);
        	        for_loop_for_connections(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconnectionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleconnectionEx; /* Prevent compiler warnings */
    ruleconnectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end connection */

/**
 * $ANTLR start simple_connect_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1293:1: simple_connect_statement : id1= port_instance_name ( ',' id2= port_instance_name )* ( CONNECT_LEFT | CONNECT_RIGHT ) n1= net_instance_name ;
 */
static void
simple_connect_statement(psitarParser ctx)
{
    sitarParser_port_instance_name_return id1;
    #undef	RETURN_TYPE_id1
    #define	RETURN_TYPE_id1 sitarParser_port_instance_name_return

    sitarParser_port_instance_name_return id2;
    #undef	RETURN_TYPE_id2
    #define	RETURN_TYPE_id2 sitarParser_port_instance_name_return

    sitarParser_net_instance_name_return n1;
    #undef	RETURN_TYPE_n1
    #define	RETURN_TYPE_n1 sitarParser_net_instance_name_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1306:2: (id1= port_instance_name ( ',' id2= port_instance_name )* ( CONNECT_LEFT | CONNECT_RIGHT ) n1= net_instance_name )
        // /home/project/sitarV2/translator/grammar/sitar.g:1306:4: id1= port_instance_name ( ',' id2= port_instance_name )* ( CONNECT_LEFT | CONNECT_RIGHT ) n1= net_instance_name
        {
            FOLLOWPUSH(FOLLOW_port_instance_name_in_simple_connect_statement2224);
            id1=port_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimple_connect_statementEx;
            }


            {

                			s=std::string((const char*)((STRSTREAM->toStringTT(STRSTREAM, id1.start, id1.stop))
                ->chars));  
                			list1.push_back(s);
                		
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1312:3: ( ',' id2= port_instance_name )*

            for (;;)
            {
                int alt46=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt46=1;
                	}
                    break;

                }

                switch (alt46)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1312:4: ',' id2= port_instance_name
            	    {
            	         MATCHT(75, &FOLLOW_75_in_simple_connect_statement2238);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_connect_statementEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_port_instance_name_in_simple_connect_statement2242);
            	        id2=port_instance_name(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_connect_statementEx;
            	        }


            	        {

            	            			s=std::string((const char*)((STRSTREAM->toStringTT(STRSTREAM, id2.start, id2.stop))
            	            ->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop46;	/* break out of the loop */
            	    break;
                }
            }
            loop46: ; /* Jump out to here if this rule does not match */


            if ( ((LA(1) >= CONNECT_LEFT) && (LA(1) <= CONNECT_RIGHT)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulesimple_connect_statementEx;
            }


            FOLLOWPUSH(FOLLOW_net_instance_name_in_simple_connect_statement2269);
            n1=net_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimple_connect_statementEx;
            }


            {

                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                			
                			//Connect port to net, inside the constructor.
                			C_file<<"\n"<<s<<".setNet(&";
                			C_file<<((STRSTREAM->toStringTT(STRSTREAM, n1.start, n1.stop))
                ->chars)<<");";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimple_connect_statementEx; /* Prevent compiler warnings */
    rulesimple_connect_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end simple_connect_statement */

/**
 * $ANTLR start port_instance_name
 * /home/project/sitarV2/translator/grammar/sitar.g:1335:1: port_instance_name : hierarchical_instance_name ;
 */
static sitarParser_port_instance_name_return
port_instance_name(psitarParser ctx)
{
    sitarParser_port_instance_name_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1336:2: ( hierarchical_instance_name )
        // /home/project/sitarV2/translator/grammar/sitar.g:1336:5: hierarchical_instance_name
        {
            FOLLOWPUSH(FOLLOW_hierarchical_instance_name_in_port_instance_name2291);
            hierarchical_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleport_instance_nameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleport_instance_nameEx; /* Prevent compiler warnings */
    ruleport_instance_nameEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end port_instance_name */

/**
 * $ANTLR start net_instance_name
 * /home/project/sitarV2/translator/grammar/sitar.g:1338:1: net_instance_name : hierarchical_instance_name ;
 */
static sitarParser_net_instance_name_return
net_instance_name(psitarParser ctx)
{
    sitarParser_net_instance_name_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1339:2: ( hierarchical_instance_name )
        // /home/project/sitarV2/translator/grammar/sitar.g:1339:5: hierarchical_instance_name
        {
            FOLLOWPUSH(FOLLOW_hierarchical_instance_name_in_net_instance_name2306);
            hierarchical_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenet_instance_nameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenet_instance_nameEx; /* Prevent compiler warnings */
    rulenet_instance_nameEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end net_instance_name */

/**
 * $ANTLR start hierarchical_instance_name
 * /home/project/sitarV2/translator/grammar/sitar.g:1342:1: hierarchical_instance_name : object_name ( ( DOT | SCOPE | POINTER ) object_name )* ;
 */
static void
hierarchical_instance_name(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1343:2: ( object_name ( ( DOT | SCOPE | POINTER ) object_name )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:1343:4: object_name ( ( DOT | SCOPE | POINTER ) object_name )*
        {
            FOLLOWPUSH(FOLLOW_object_name_in_hierarchical_instance_name2319);
            object_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehierarchical_instance_nameEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1343:15: ( ( DOT | SCOPE | POINTER ) object_name )*

            for (;;)
            {
                int alt47=2;
                switch ( LA(1) )
                {
                case DOT:
                case POINTER:
                case SCOPE:
                	{
                		alt47=1;
                	}
                    break;

                }

                switch (alt47)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1343:16: ( DOT | SCOPE | POINTER ) object_name
            	    {
            	        if ( LA(1) == DOT || LA(1) == POINTER || LA(1) == SCOPE )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto rulehierarchical_instance_nameEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_object_name_in_hierarchical_instance_name2329);
            	        object_name(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehierarchical_instance_nameEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop47;	/* break out of the loop */
            	    break;
                }
            }
            loop47: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulehierarchical_instance_nameEx; /* Prevent compiler warnings */
    rulehierarchical_instance_nameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end hierarchical_instance_name */

/**
 * $ANTLR start object_name
 * /home/project/sitarV2/translator/grammar/sitar.g:1345:1: object_name : IDENTIFIER ( '[' expression ']' ( '[' expression ']' )? )? ;
 */
static void
object_name(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1346:2: ( IDENTIFIER ( '[' expression ']' ( '[' expression ']' )? )? )
        // /home/project/sitarV2/translator/grammar/sitar.g:1346:4: IDENTIFIER ( '[' expression ']' ( '[' expression ']' )? )?
        {
             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_object_name2343);
            if  (HASEXCEPTION())
            {
                goto ruleobject_nameEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1346:15: ( '[' expression ']' ( '[' expression ']' )? )?
            {
                int alt49=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt49=1;
                    	}
                        break;
                }

                switch (alt49)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1346:16: '[' expression ']' ( '[' expression ']' )?
            	    {
            	         MATCHT(82, &FOLLOW_82_in_object_name2346);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobject_nameEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_object_name2347);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobject_nameEx;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_object_name2349);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobject_nameEx;
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1346:34: ( '[' expression ']' )?
            	        {
            	            int alt48=2;
            	            switch ( LA(1) )
            	            {
            	                case 82:
            	                	{
            	                		alt48=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt48)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1346:35: '[' expression ']'
            	        	    {
            	        	         MATCHT(82, &FOLLOW_82_in_object_name2352);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleobject_nameEx;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_expression_in_object_name2353);
            	        	        expression(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleobject_nameEx;
            	        	        }


            	        	         MATCHT(83, &FOLLOW_83_in_object_name2355);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleobject_nameEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleobject_nameEx; /* Prevent compiler warnings */
    ruleobject_nameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end object_name */

/**
 * $ANTLR start for_loop_for_connections
 * /home/project/sitarV2/translator/grammar/sitar.g:1357:1: for_loop_for_connections : FOR id= IDENTIFIER IN e1= expression TO e2= expression ( connection )+ END FOR ;
 */
static void
for_loop_for_connections(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1358:2: ( FOR id= IDENTIFIER IN e1= expression TO e2= expression ( connection )+ END FOR )
        // /home/project/sitarV2/translator/grammar/sitar.g:1358:4: FOR id= IDENTIFIER IN e1= expression TO e2= expression ( connection )+ END FOR
        {
             MATCHT(FOR, &FOLLOW_FOR_in_for_loop_for_connections2387);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_for_loop_for_connections2391);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


             MATCHT(IN, &FOLLOW_IN_in_for_loop_for_connections2393);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_for_loop_for_connections2397);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


             MATCHT(TO, &FOLLOW_TO_in_for_loop_for_connections2399);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_for_loop_for_connections2403);
            e2=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            {

                	C_file<<"\n//---connecting ports to nets----";
                	C_file<<"\nfor(int "<<((id->getText(id))->chars)<<"=("<<(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars)<<");";
                	C_file<<((id->getText(id))->chars)<<"<=("<<
                (STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");";
                	C_file<<((id->getText(id))->chars)<<"++)\n{\n\n";
                	
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1365:3: ( connection )+
            {
                int cnt50=0;

                for (;;)
                {
                    int alt50=2;
            	switch ( LA(1) )
            	{
            	case FOR:
            	case IDENTIFIER:
            		{
            			alt50=1;
            		}
            	    break;

            	}

            	switch (alt50)
            	{
            	    case 1:
            	        // /home/project/sitarV2/translator/grammar/sitar.g:1365:3: connection
            	        {
            	            FOLLOWPUSH(FOLLOW_connection_in_for_loop_for_connections2410);
            	            connection(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulefor_loop_for_connectionsEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt50 >= 1 )
            		{
            		    goto loop50;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulefor_loop_for_connectionsEx;
            	}
            	cnt50++;
                }
                loop50: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(END, &FOLLOW_END_in_for_loop_for_connections2417);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


             MATCHT(FOR, &FOLLOW_FOR_in_for_loop_for_connections2419);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            {

                	C_file<<"\n\n};\n";
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefor_loop_for_connectionsEx; /* Prevent compiler warnings */
    rulefor_loop_for_connectionsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end for_loop_for_connections */

/**
 * $ANTLR start expression
 * /home/project/sitarV2/translator/grammar/sitar.g:1400:1: expression : term ( ( PLUS | MINUS ) term )* ;
 */
static sitarParser_expression_return
expression(psitarParser ctx)
{
    sitarParser_expression_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1400:13: ( term ( ( PLUS | MINUS ) term )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:1400:16: term ( ( PLUS | MINUS ) term )*
        {
            FOLLOWPUSH(FOLLOW_term_in_expression2462);
            term(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1400:21: ( ( PLUS | MINUS ) term )*

            for (;;)
            {
                int alt51=2;
                switch ( LA(1) )
                {
                case MINUS:
                case PLUS:
                	{
                		alt51=1;
                	}
                    break;

                }

                switch (alt51)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1400:22: ( PLUS | MINUS ) term
            	    {
            	        if ( LA(1) == MINUS || LA(1) == PLUS )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleexpressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_term_in_expression2471);
            	        term(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop51;	/* break out of the loop */
            	    break;
                }
            }
            loop51: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end expression */

/**
 * $ANTLR start term
 * /home/project/sitarV2/translator/grammar/sitar.g:1402:1: term : signed_expression ( ( '*' | '/' | '%' ) signed_expression )* ;
 */
static void
term(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1402:7: ( signed_expression ( ( '*' | '/' | '%' ) signed_expression )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:1402:9: signed_expression ( ( '*' | '/' | '%' ) signed_expression )*
        {
            FOLLOWPUSH(FOLLOW_signed_expression_in_term2482);
            signed_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletermEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1402:27: ( ( '*' | '/' | '%' ) signed_expression )*

            for (;;)
            {
                int alt52=2;
                switch ( LA(1) )
                {
                case 71:
                case 74:
                case 76:
                	{
                		alt52=1;
                	}
                    break;

                }

                switch (alt52)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1402:28: ( '*' | '/' | '%' ) signed_expression
            	    {
            	        if ( LA(1) == 71 || LA(1) == 74 || LA(1) == 76 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruletermEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_signed_expression_in_term2493);
            	        signed_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletermEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop52;	/* break out of the loop */
            	    break;
                }
            }
            loop52: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start signed_expression
 * /home/project/sitarV2/translator/grammar/sitar.g:1404:1: signed_expression : ( MINUS )? atomic_expression ;
 */
static void
signed_expression(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1405:2: ( ( MINUS )? atomic_expression )
        // /home/project/sitarV2/translator/grammar/sitar.g:1405:4: ( MINUS )? atomic_expression
        {
            // /home/project/sitarV2/translator/grammar/sitar.g:1405:4: ( MINUS )?
            {
                int alt53=2;
                switch ( LA(1) )
                {
                    case MINUS:
                    	{
                    		alt53=1;
                    	}
                        break;
                }

                switch (alt53)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1405:4: MINUS
            	    {
            	         MATCHT(MINUS, &FOLLOW_MINUS_in_signed_expression2505);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesigned_expressionEx;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_atomic_expression_in_signed_expression2508);
            atomic_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesigned_expressionEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesigned_expressionEx; /* Prevent compiler warnings */
    rulesigned_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end signed_expression */

/**
 * $ANTLR start atomic_expression
 * /home/project/sitarV2/translator/grammar/sitar.g:1412:1: atomic_expression : ( '(' expression ')' | INTEGER | IDENTIFIER );
 */
static void
atomic_expression(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1413:2: ( '(' expression ')' | INTEGER | IDENTIFIER )

            ANTLR3_UINT32 alt54;

            alt54=3;

            switch ( LA(1) )
            {
            case 72:
            	{
            		alt54=1;
            	}
                break;
            case INTEGER:
            	{
            		alt54=2;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt54=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 54;
                EXCEPTION->state        = 0;


                goto ruleatomic_expressionEx;

            }

            switch (alt54)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1414:2: '(' expression ')'
        	    {
        	         MATCHT(72, &FOLLOW_72_in_atomic_expression2525);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_atomic_expression2526);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	         MATCHT(73, &FOLLOW_73_in_atomic_expression2527);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1415:4: INTEGER
        	    {
        	         MATCHT(INTEGER, &FOLLOW_INTEGER_in_atomic_expression2532);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1416:4: IDENTIFIER
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_atomic_expression2537);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomic_expressionEx; /* Prevent compiler warnings */
    ruleatomic_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end atomic_expression */

/**
 * $ANTLR start behavior_block
 * /home/project/sitarV2/translator/grammar/sitar.g:1430:1: behavior_block : cf ;
 */
static void
behavior_block(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1431:2: ( cf )
        // /home/project/sitarV2/translator/grammar/sitar.g:1432:3: cf
        {
            FOLLOWPUSH(FOLLOW_cf_in_behavior_block2563);
            cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebehavior_blockEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebehavior_blockEx; /* Prevent compiler warnings */
    rulebehavior_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end behavior_block */

/**
 * $ANTLR start cf
 * /home/project/sitarV2/translator/grammar/sitar.g:1436:1: cf : BEHAVIOR sequence[0] END BEHAVIOR ;
 */
static void
cf(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_cfTop = psitarParser_cfPush(ctx);


    	

    	//initialize counts
    	(SCOPE_TOP(cf))->pointer_count=0;
    	(SCOPE_TOP(cf))->timer_count=0;
    	(SCOPE_TOP(cf))->if_flag_count=0;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1468:2: ( BEHAVIOR sequence[0] END BEHAVIOR )
        // /home/project/sitarV2/translator/grammar/sitar.g:1469:2: BEHAVIOR sequence[0] END BEHAVIOR
        {
             MATCHT(BEHAVIOR, &FOLLOW_BEHAVIOR_in_cf2592);
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


            {
                ++(SCOPE_TOP(cf))->pointer_count;
            }


            FOLLOWPUSH(FOLLOW_sequence_in_cf2602);
            sequence(ctx, 0);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


             MATCHT(END, &FOLLOW_END_in_cf2606);
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


             MATCHT(BEHAVIOR, &FOLLOW_BEHAVIOR_in_cf2608);
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecfEx; /* Prevent compiler warnings */
    rulecfEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {


                    	//add declarations for pointers, timers and flags
                    	//used by the  behavior block 
                    	(SCOPE_TOP(du))->num_pointers=(SCOPE_TOP(cf))->pointer_count;
                    	(SCOPE_TOP(du))->num_timers=(SCOPE_TOP(cf))->timer_count;
                    	(SCOPE_TOP(du))->num_if_flags=(SCOPE_TOP(cf))->if_flag_count;


                }
            }


    psitarParser_cfPop(ctx);

    return ;
}
/* $ANTLR end cf */

/**
 * $ANTLR start sequence
 * /home/project/sitarV2/translator/grammar/sitar.g:1497:1: sequence[int p] returns [int last_case] : (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' ) ;
 */
static int
sequence(psitarParser ctx, int p)
{
    int last_case;


    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    int s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 int

    int s3;
    #undef	RETURN_TYPE_s3
    #define	RETURN_TYPE_s3 int

    int s4;
    #undef	RETURN_TYPE_s4
    #define	RETURN_TYPE_s4 int

    /* Initialize rule variables
     */

     int k=0;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1514:1: ( (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' ) )
        // /home/project/sitarV2/translator/grammar/sitar.g:1515:1: (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' )
        {
            {
                	
                	//Add some text at the start of the sequence
                	E_file<<"\nswitch(_pointer["<<p<<"])\n{\n";

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1521:14: (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' )
            {
                int alt59=2;
                switch ( LA(1) )
                {
                case CODE_BLOCK:
                case DECL:
                case DO:
                case IF:
                case INCLUDE:
                case INIT:
                case NOTHING:
                case RUN:
                case STOP:
                case WAIT:
                case 82:
                	{
                		alt59=1;
                	}
                    break;
                case 72:
                	{
                		alt59=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 59;
                    EXCEPTION->state        = 0;


                    goto rulesequenceEx;

                }

                switch (alt59)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1523:14: s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )?
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_sequence2689);
            	        s1=statement(ctx, p, k);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	        {
            	            k=s1
            	            +1;
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1524:2: ( ';' s2= statement[p,k] )*

            	        for (;;)
            	        {
            	            int alt55=2;
            	            switch ( LA(1) )
            	            {
            	            case 77:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case CODE_BLOCK:
            	            		case DECL:
            	            		case DO:
            	            		case IF:
            	            		case INCLUDE:
            	            		case INIT:
            	            		case NOTHING:
            	            		case RUN:
            	            		case STOP:
            	            		case WAIT:
            	            		case 82:
            	            			{
            	            				alt55=1;
            	            			}
            	            		    break;

            	            		}

            	            	}
            	                break;

            	            }

            	            switch (alt55)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1524:3: ';' s2= statement[p,k]
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2696);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_statement_in_sequence2700);
            	        	        s2=statement(ctx, p, k);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        {
            	        	            k=(s2
            	        	            +1);
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop55;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop55: ; /* Jump out to here if this rule does not match */


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1524:51: ( ';' )?
            	        {
            	            int alt56=2;
            	            switch ( LA(1) )
            	            {
            	                case 77:
            	                	{
            	                		alt56=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt56)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1524:51: ';'
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2707);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1525:3: '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')'
            	    {
            	         MATCHT(72, &FOLLOW_72_in_sequence2712);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_statement_in_sequence2717);
            	        s3=statement(ctx, p, k);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	        {
            	            k=(s3
            	            +1);
            	        }


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1526:9: ( ';' s4= statement[p,k] )*

            	        for (;;)
            	        {
            	            int alt57=2;
            	            switch ( LA(1) )
            	            {
            	            case 77:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case CODE_BLOCK:
            	            		case DECL:
            	            		case DO:
            	            		case IF:
            	            		case INCLUDE:
            	            		case INIT:
            	            		case NOTHING:
            	            		case RUN:
            	            		case STOP:
            	            		case WAIT:
            	            		case 82:
            	            			{
            	            				alt57=1;
            	            			}
            	            		    break;

            	            		}

            	            	}
            	                break;

            	            }

            	            switch (alt57)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1526:10: ';' s4= statement[p,k]
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2731);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_statement_in_sequence2735);
            	        	        s4=statement(ctx, p, k);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        {
            	        	            k=(s4
            	        	            +1);
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop57;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop57: ; /* Jump out to here if this rule does not match */


            	        // /home/project/sitarV2/translator/grammar/sitar.g:1526:59: ( ';' )?
            	        {
            	            int alt58=2;
            	            switch ( LA(1) )
            	            {
            	                case 77:
            	                	{
            	                		alt58=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt58)
            	            {
            	        	case 1:
            	        	    // /home/project/sitarV2/translator/grammar/sitar.g:1526:59: ';'
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2743);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(73, &FOLLOW_73_in_sequence2746);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesequenceEx; /* Prevent compiler warnings */
    rulesequenceEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//add the last case that indicates the sequence has terminated
                    	E_file<<"\ncase "<<k<<": break;\n}\n";
                    	last_case=k;

                    	C_file<<"\n_pointer_last_value["<<p<<"]="<<k<<";";

                }
            }


    return last_case;
}
/* $ANTLR end sequence */

/**
 * $ANTLR start statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1535:1: statement[int p_, int k_] returns [int last_case_] : ( atomic_statement | compound_statement );
 */
static int
statement(psitarParser ctx, int p_, int k_)
{
    int last_case_;


    /* Initialize rule variables
     */
    ctx->psitarParser_statementTop = psitarParser_statementPush(ctx);

    	//Initialize variables
    	(SCOPE_TOP(statement))->p=p_;
    	(SCOPE_TOP(statement))->k=k_;
    	(SCOPE_TOP(statement))->last_case=k_;
    	
    	

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1561:2: ( atomic_statement | compound_statement )

            ANTLR3_UINT32 alt60;

            alt60=2;

            switch ( LA(1) )
            {
            case CODE_BLOCK:
            case DECL:
            case INCLUDE:
            case INIT:
            case NOTHING:
            case RUN:
            case STOP:
            case WAIT:
            	{
            		alt60=1;
            	}
                break;
            case DO:
            case IF:
            case 82:
            	{
            		alt60=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 60;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt60)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1562:1: atomic_statement
        	    {
        	        {

        	            	//Initialize variables
        	            	(SCOPE_TOP(statement))->p=p_;
        	            	(SCOPE_TOP(statement))->k=k_;
        	            	(SCOPE_TOP(statement))->last_case=k_;
        	            	
        	            	

        	        }


        	        FOLLOWPUSH(FOLLOW_atomic_statement_in_statement2792);
        	        atomic_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1572:4: compound_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_compound_statement_in_statement2798);
        	        compound_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//return the last case label used by this statement
                    	last_case_=(SCOPE_TOP(statement))->last_case;

                    	
                    	

                }
            }


    psitarParser_statementPop(ctx);

    return last_case_;
}
/* $ANTLR end statement */

/**
 * $ANTLR start atomic_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1577:1: atomic_statement : ( nothing_statement | wait_statement | stop_statement | run_procedure_statement | code_block_statement );
 */
static void
atomic_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1578:2: ( nothing_statement | wait_statement | stop_statement | run_procedure_statement | code_block_statement )

            ANTLR3_UINT32 alt61;

            alt61=5;

            switch ( LA(1) )
            {
            case NOTHING:
            	{
            		alt61=1;
            	}
                break;
            case WAIT:
            	{
            		alt61=2;
            	}
                break;
            case STOP:
            	{
            		alt61=3;
            	}
                break;
            case RUN:
            	{
            		alt61=4;
            	}
                break;
            case CODE_BLOCK:
            case DECL:
            case INCLUDE:
            case INIT:
            	{
            		alt61=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 61;
                EXCEPTION->state        = 0;


                goto ruleatomic_statementEx;

            }

            switch (alt61)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1578:4: nothing_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_nothing_statement_in_atomic_statement2813);
        	        nothing_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1579:4: wait_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_wait_statement_in_atomic_statement2818);
        	        wait_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1580:4: stop_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_stop_statement_in_atomic_statement2823);
        	        stop_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1581:4: run_procedure_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_run_procedure_statement_in_atomic_statement2828);
        	        run_procedure_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1582:4: code_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_code_block_statement_in_atomic_statement2833);
        	        code_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomic_statementEx; /* Prevent compiler warnings */
    ruleatomic_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end atomic_statement */

/**
 * $ANTLR start code_block_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1590:1: code_block_statement : ( behavior_code_block_statement | declaration_block_statement | initialization_block_statement | includes_block_statement );
 */
static void
code_block_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1591:2: ( behavior_code_block_statement | declaration_block_statement | initialization_block_statement | includes_block_statement )

            ANTLR3_UINT32 alt62;

            alt62=4;

            switch ( LA(1) )
            {
            case CODE_BLOCK:
            	{
            		alt62=1;
            	}
                break;
            case DECL:
            	{
            		alt62=2;
            	}
                break;
            case INIT:
            	{
            		alt62=3;
            	}
                break;
            case INCLUDE:
            	{
            		alt62=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 62;
                EXCEPTION->state        = 0;


                goto rulecode_block_statementEx;

            }

            switch (alt62)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1591:4: behavior_code_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_behavior_code_block_statement_in_code_block_statement2859);
        	        behavior_code_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1592:4: declaration_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_declaration_block_statement_in_code_block_statement2864);
        	        declaration_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1593:4: initialization_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_initialization_block_statement_in_code_block_statement2869);
        	        initialization_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1594:4: includes_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_includes_block_statement_in_code_block_statement2874);
        	        includes_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecode_block_statementEx; /* Prevent compiler warnings */
    rulecode_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end code_block_statement */

/**
 * $ANTLR start behavior_code_block_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1601:1: behavior_code_block_statement : c= code_block_with_info ;
 */
static void
behavior_code_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1602:2: (c= code_block_with_info )
        // /home/project/sitarV2/translator/grammar/sitar.g:1602:5: c= code_block_with_info
        {
            FOLLOWPUSH(FOLLOW_code_block_with_info_in_behavior_code_block_statement2893);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebehavior_code_block_statementEx;
            }


            {

                               	
                        E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//code_block_statement ";
                	E_file<<
                c.text
                ;
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebehavior_code_block_statementEx; /* Prevent compiler warnings */
    rulebehavior_code_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end behavior_code_block_statement */

/**
 * $ANTLR start declaration_block_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1616:1: declaration_block_statement : DECL c= code_block_with_info ;
 */
static void
declaration_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1617:2: ( DECL c= code_block_with_info )
        // /home/project/sitarV2/translator/grammar/sitar.g:1618:2: DECL c= code_block_with_info
        {
             MATCHT(DECL, &FOLLOW_DECL_in_declaration_block_statement2913);
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_block_statementEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_declaration_block_statement2917);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_block_statementEx;
            }


            {

                               	
                               	
                        E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//declaration_block_statement ";
                	
                	D_file<<
                c.text
                ;
                	

                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_block_statementEx; /* Prevent compiler warnings */
    ruledeclaration_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration_block_statement */

/**
 * $ANTLR start initialization_block_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1636:1: initialization_block_statement : INIT c= code_block_with_info ;
 */
static void
initialization_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1637:2: ( INIT c= code_block_with_info )
        // /home/project/sitarV2/translator/grammar/sitar.g:1638:2: INIT c= code_block_with_info
        {
             MATCHT(INIT, &FOLLOW_INIT_in_initialization_block_statement2937);
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_block_statementEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_initialization_block_statement2941);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_block_statementEx;
            }


            {

                               	
                       	E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//initialization_block_statement";
                	C_file<<
                c.text
                ;
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinitialization_block_statementEx; /* Prevent compiler warnings */
    ruleinitialization_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end initialization_block_statement */

/**
 * $ANTLR start includes_block_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1651:1: includes_block_statement : INCLUDE c= code_block_with_info ;
 */
static void
includes_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1652:2: ( INCLUDE c= code_block_with_info )
        // /home/project/sitarV2/translator/grammar/sitar.g:1653:2: INCLUDE c= code_block_with_info
        {
             MATCHT(INCLUDE, &FOLLOW_INCLUDE_in_includes_block_statement2959);
            if  (HASEXCEPTION())
            {
                goto ruleincludes_block_statementEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_includes_block_statement2963);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleincludes_block_statementEx;
            }


            {

                               	
                       	E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//includes_block_statement";

                	I_file<<
                c.text
                ;
                	
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleincludes_block_statementEx; /* Prevent compiler warnings */
    ruleincludes_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end includes_block_statement */

/**
 * $ANTLR start nothing_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1668:1: nothing_statement : n1= NOTHING ;
 */
static void
nothing_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    n1;

    /* Initialize rule variables
     */

    n1       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1669:3: (n1= NOTHING )
        // /home/project/sitarV2/translator/grammar/sitar.g:1669:5: n1= NOTHING
        {
            n1 = (pANTLR3_COMMON_TOKEN) MATCHT(NOTHING, &FOLLOW_NOTHING_in_nothing_statement2982);
            if  (HASEXCEPTION())
            {
                goto rulenothing_statementEx;
            }


            {

                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{ \n ";
                		E_file<<"\n//nothing statement , line:"<<(n1->getLine(n1));
                		E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\n}\n";
                		(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenothing_statementEx; /* Prevent compiler warnings */
    rulenothing_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nothing_statement */

/**
 * $ANTLR start wait_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1754:1: wait_statement : ( wait_until | wait_for_time | single_wait );
 */
static void
wait_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1755:2: ( wait_until | wait_for_time | single_wait )

            ANTLR3_UINT32 alt63;

            alt63=3;

            switch ( LA(1) )
            {
            case WAIT:
            	{
            		switch ( LA(2) )
            		{
            		case UNTIL:
            			{
            				alt63=1;
            			}
            		    break;
            		case 72:
            			{
            				alt63=2;
            			}
            		    break;
            		case ELSE:
            		case END:
            		case WHILE:
            		case 73:
            		case 77:
            		case 83:
            		case 84:
            			{
            				alt63=3;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 63;
            		    EXCEPTION->state        = 1;


            		    goto rulewait_statementEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 63;
                EXCEPTION->state        = 0;


                goto rulewait_statementEx;

            }

            switch (alt63)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1755:4: wait_until
        	    {
        	        FOLLOWPUSH(FOLLOW_wait_until_in_wait_statement3009);
        	        wait_until(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewait_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1756:3: wait_for_time
        	    {
        	        FOLLOWPUSH(FOLLOW_wait_for_time_in_wait_statement3017);
        	        wait_for_time(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewait_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1757:3: single_wait
        	    {
        	        FOLLOWPUSH(FOLLOW_single_wait_in_wait_statement3025);
        	        single_wait(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewait_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulewait_statementEx; /* Prevent compiler warnings */
    rulewait_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end wait_statement */

/**
 * $ANTLR start wait_until
 * /home/project/sitarV2/translator/grammar/sitar.g:1761:1: wait_until : s= WAIT UNTIL e= expression_cf ;
 */
static void
wait_until(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    std::string e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e std::string

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1762:9: (s= WAIT UNTIL e= expression_cf )
        // /home/project/sitarV2/translator/grammar/sitar.g:1762:11: s= WAIT UNTIL e= expression_cf
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(WAIT, &FOLLOW_WAIT_in_wait_until3050);
            if  (HASEXCEPTION())
            {
                goto rulewait_untilEx;
            }


             MATCHT(UNTIL, &FOLLOW_UNTIL_in_wait_until3052);
            if  (HASEXCEPTION())
            {
                goto rulewait_untilEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_wait_until3056);
            e=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewait_untilEx;
            }


            {

                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{\n";
                		E_file<<"\n//wait-until statement , line:"<<(s->getLine(s));
                		E_file<<"\nif("<<
                e
                <<")";
                		E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\nelse\n break;\n }";
                		(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewait_untilEx; /* Prevent compiler warnings */
    rulewait_untilEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end wait_until */

/**
 * $ANTLR start wait_for_time
 * /home/project/sitarV2/translator/grammar/sitar.g:1774:1: wait_for_time : s= WAIT '(' e1= expression_cf ',' e2= expression_cf ')' ;
 */
static void
wait_for_time(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1775:9: (s= WAIT '(' e1= expression_cf ',' e2= expression_cf ')' )
        // /home/project/sitarV2/translator/grammar/sitar.g:1775:11: s= WAIT '(' e1= expression_cf ',' e2= expression_cf ')'
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(WAIT, &FOLLOW_WAIT_in_wait_for_time3093);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


             MATCHT(72, &FOLLOW_72_in_wait_for_time3096);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_wait_for_time3100);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


             MATCHT(75, &FOLLOW_75_in_wait_for_time3102);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_wait_for_time3106);
            e2=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


             MATCHT(73, &FOLLOW_73_in_wait_for_time3108);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


            {

                                 E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                                 E_file<<"\n{\n";


                		 E_file<<"\n//wait-for -time statement , line:"<<(s->getLine(s));
                                 E_file<<"\n_timer["<<(SCOPE_TOP(cf))->timer_count<<"] = sitar::time(current_time)+sitar::time(";
                                 E_file<<
                e1
                <<","<<e2
                <<");";
                		 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\n}\n";


                                 E_file<<"\ncase "<<((SCOPE_TOP(statement))->k+1)<<":";
                                 E_file<<"\n{\n";
                                 E_file<<"if(current_time>=_timer["<<(SCOPE_TOP(cf))->timer_count<<"])";
                                 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\nelse\n break; \n}";

                                //a unique timer has been used to implement this delay.
                                //increment the timer count
                                 ++(SCOPE_TOP(cf))->timer_count;

                                 (SCOPE_TOP(statement))->last_case=((SCOPE_TOP(statement))->k+1);

                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewait_for_timeEx; /* Prevent compiler warnings */
    rulewait_for_timeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end wait_for_time */

/**
 * $ANTLR start single_wait
 * /home/project/sitarV2/translator/grammar/sitar.g:1804:1: single_wait : s= WAIT ;
 */
static void
single_wait(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1805:2: (s= WAIT )
        // /home/project/sitarV2/translator/grammar/sitar.g:1805:4: s= WAIT
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(WAIT, &FOLLOW_WAIT_in_single_wait3139);
            if  (HASEXCEPTION())
            {
                goto rulesingle_waitEx;
            }


            {

                                 E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                                 E_file<<"\n{\n";


                                 E_file<<"\n//wait statement , line:"<<(s->getLine(s));
                                 E_file<<"\n_timer["<<(SCOPE_TOP(cf))->timer_count<<"] = sitar::time(current_time)+sitar::time(0,1);";
                		 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\n}\n";


                                 E_file<<"\ncase "<<((SCOPE_TOP(statement))->k+1)<<":";
                                 E_file<<"\n{\n";
                                 E_file<<"if(current_time>=_timer["<<(SCOPE_TOP(cf))->timer_count<<"])";
                		 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\nelse\n break; \n}";

                                //a unique timer has been used to implement this delay.
                                //increment the timer count
                                 ++(SCOPE_TOP(cf))->timer_count;

                                 (SCOPE_TOP(statement))->last_case=((SCOPE_TOP(statement))->k+1);
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesingle_waitEx; /* Prevent compiler warnings */
    rulesingle_waitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end single_wait */

/**
 * $ANTLR start stop_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1832:1: stop_statement : ( stop_behavior | stop_simulation );
 */
static void
stop_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1833:2: ( stop_behavior | stop_simulation )

            ANTLR3_UINT32 alt64;

            alt64=2;

            switch ( LA(1) )
            {
            case STOP:
            	{
            		switch ( LA(2) )
            		{
            		case BEHAVIOR:
            			{
            				alt64=1;
            			}
            		    break;
            		case SIMULATION:
            			{
            				alt64=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 64;
            		    EXCEPTION->state        = 1;


            		    goto rulestop_statementEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 64;
                EXCEPTION->state        = 0;


                goto rulestop_statementEx;

            }

            switch (alt64)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1833:4: stop_behavior
        	    {
        	        FOLLOWPUSH(FOLLOW_stop_behavior_in_stop_statement3165);
        	        stop_behavior(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestop_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1834:5: stop_simulation
        	    {
        	        FOLLOWPUSH(FOLLOW_stop_simulation_in_stop_statement3171);
        	        stop_simulation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestop_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestop_statementEx; /* Prevent compiler warnings */
    rulestop_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stop_statement */

/**
 * $ANTLR start stop_behavior
 * /home/project/sitarV2/translator/grammar/sitar.g:1836:1: stop_behavior : s= STOP BEHAVIOR ;
 */
static void
stop_behavior(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1837:3: (s= STOP BEHAVIOR )
        // /home/project/sitarV2/translator/grammar/sitar.g:1837:5: s= STOP BEHAVIOR
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(STOP, &FOLLOW_STOP_in_stop_behavior3184);
            if  (HASEXCEPTION())
            {
                goto rulestop_behaviorEx;
            }


             MATCHT(BEHAVIOR, &FOLLOW_BEHAVIOR_in_stop_behavior3186);
            if  (HASEXCEPTION())
            {
                goto rulestop_behaviorEx;
            }


            {

                			
                			
                			E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                			E_file<<"\n{ \n ";
                			E_file<<"\n//stop module statement , line:"<<(s->getLine(s));
                			E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                			E_file<<"\n _terminated=1;";
                			E_file<<"\n}\n";
                			(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestop_behaviorEx; /* Prevent compiler warnings */
    rulestop_behaviorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stop_behavior */

/**
 * $ANTLR start stop_simulation
 * /home/project/sitarV2/translator/grammar/sitar.g:1851:1: stop_simulation : s= STOP SIMULATION ;
 */
static void
stop_simulation(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1852:3: (s= STOP SIMULATION )
        // /home/project/sitarV2/translator/grammar/sitar.g:1852:5: s= STOP SIMULATION
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(STOP, &FOLLOW_STOP_in_stop_simulation3206);
            if  (HASEXCEPTION())
            {
                goto rulestop_simulationEx;
            }


             MATCHT(SIMULATION, &FOLLOW_SIMULATION_in_stop_simulation3208);
            if  (HASEXCEPTION())
            {
                goto rulestop_simulationEx;
            }


            {

                			
                			
                			E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                			E_file<<"\n{ \n ";
                			E_file<<"\n//stop simulation statement , line:"<<(s->getLine(s));
                			E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                			E_file<<"\n stop_simulation();";
                			E_file<<"\n}\n";
                			(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestop_simulationEx; /* Prevent compiler warnings */
    rulestop_simulationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stop_simulation */

/**
 * $ANTLR start run_procedure_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1866:1: run_procedure_statement : s= RUN id= IDENTIFIER ;
 */
static void
run_procedure_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    s       = NULL;
    id       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1867:3: (s= RUN id= IDENTIFIER )
        // /home/project/sitarV2/translator/grammar/sitar.g:1867:5: s= RUN id= IDENTIFIER
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(RUN, &FOLLOW_RUN_in_run_procedure_statement3228);
            if  (HASEXCEPTION())
            {
                goto rulerun_procedure_statementEx;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_run_procedure_statement3232);
            if  (HASEXCEPTION())
            {
                goto rulerun_procedure_statementEx;
            }


            {

                		std::string name =(const char *)((id->getText(id))->chars);
                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{ \n ";
                		
                		E_file<<"\n//run procedure statement , line:"<<(s->getLine(s));
                		E_file<<"\n"<<name<<".runBehavior(current_time);";
                		E_file<<"\nif("<<name<<"._terminated==1)";
                		E_file<<"\n{";
                		E_file<<"\n"<<name<<"._resetBehavior();";
                		E_file<<"\n_incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\n}";
                		E_file<<"\nelse";
                		E_file<<"\n{";
                		E_file<<"\n//procedure has converged, and might";
                		E_file<<"\n//need to be re-executed";
                		E_file<<"\nif("<<name<<"._reexecute==true)";
                		E_file<<"\n_reexecute=true;";
                		E_file<<"\nbreak;";
                		E_file<<"\n}";
                		
                		E_file<<"\n}\n";
                		(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulerun_procedure_statementEx; /* Prevent compiler warnings */
    rulerun_procedure_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end run_procedure_statement */

/**
 * $ANTLR start compound_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1898:1: compound_statement : ( if_statement | do_while_statement | parallel_statement );
 */
static void
compound_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:1899:2: ( if_statement | do_while_statement | parallel_statement )

            ANTLR3_UINT32 alt65;

            alt65=3;

            switch ( LA(1) )
            {
            case IF:
            	{
            		alt65=1;
            	}
                break;
            case DO:
            	{
            		alt65=2;
            	}
                break;
            case 82:
            	{
            		alt65=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 65;
                EXCEPTION->state        = 0;


                goto rulecompound_statementEx;

            }

            switch (alt65)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1899:4: if_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_if_statement_in_compound_statement3253);
        	        if_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompound_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1900:4: do_while_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_do_while_statement_in_compound_statement3258);
        	        do_while_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompound_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:1901:4: parallel_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_parallel_statement_in_compound_statement3263);
        	        parallel_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompound_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecompound_statementEx; /* Prevent compiler warnings */
    rulecompound_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end compound_statement */

/**
 * $ANTLR start if_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1908:1: if_statement : s= IF e1= expression_cf THEN s1= sequence[true_branch] (else_clause= ELSE s2= sequence[false_branch] )? END IF ;
 */
static void
if_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    pANTLR3_COMMON_TOKEN    else_clause;
    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    int s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 int

    /* Initialize rule variables
     */


            //pointers used by the two sequences
            //within this statement
            int true_branch=0;
            int false_branch=0;
            int flag;

    s       = NULL;
    else_clause       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:1921:2: (s= IF e1= expression_cf THEN s1= sequence[true_branch] (else_clause= ELSE s2= sequence[false_branch] )? END IF )
        // /home/project/sitarV2/translator/grammar/sitar.g:1921:4: s= IF e1= expression_cf THEN s1= sequence[true_branch] (else_clause= ELSE s2= sequence[false_branch] )? END IF
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(IF, &FOLLOW_IF_in_if_statement3290);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_if_statement3296);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


             MATCHT(THEN, &FOLLOW_THEN_in_if_statement3300);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            {

                                true_branch=(SCOPE_TOP(cf))->pointer_count;
                                ++(SCOPE_TOP(cf))->pointer_count;
                                flag=(SCOPE_TOP(cf))->if_flag_count;
                                ++(SCOPE_TOP(cf))->if_flag_count;

                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{\n";
                		E_file<<"\n//if statement , line:"<<(s->getLine(s));

                		E_file<<"\nif("<<
                e1
                <<")";
                		E_file<<"\n_if_flag["<<flag<<"]=true;";
                		E_file<<"\nelse";
                		E_file<<"\n_if_flag["<<flag<<"]=false;";
                		E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\n}\n";

                		E_file<<"\ncase "<<((SCOPE_TOP(statement))->k+1)<<":";
                		E_file<<"\n{\n";

                		E_file<<"\nif(_if_flag["<<flag<<"]==true)";
                		E_file<<"\n{\n";

                        
            }


            FOLLOWPUSH(FOLLOW_sequence_in_if_statement3310);
            s1=sequence(ctx, true_branch);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            {


                                 E_file<<"\n}\n";
                                 E_file<<"\nelse\n{\n";
                        
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:1952:2: (else_clause= ELSE s2= sequence[false_branch] )?
            {
                int alt66=2;
                switch ( LA(1) )
                {
                    case ELSE:
                    	{
                    		alt66=1;
                    	}
                        break;
                }

                switch (alt66)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:1952:4: else_clause= ELSE s2= sequence[false_branch]
            	    {
            	        else_clause = (pANTLR3_COMMON_TOKEN) MATCHT(ELSE, &FOLLOW_ELSE_in_if_statement3328);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_statementEx;
            	        }


            	        {

            	            				false_branch=(SCOPE_TOP(cf))->pointer_count; 
            	            				++(SCOPE_TOP(cf))->pointer_count;
            	            			
            	        }


            	        FOLLOWPUSH(FOLLOW_sequence_in_if_statement3352);
            	        s2=sequence(ctx, false_branch);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_statementEx;
            	        }


            	    }
            	    break;

                }
            }

            {


                                 E_file<<"\n}\n";
                        
            }


             MATCHT(END, &FOLLOW_END_in_if_statement3384);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


             MATCHT(IF, &FOLLOW_IF_in_if_statement3386);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            {

                                E_file<<"\nif(";
                                E_file<<"(_if_flag["<<flag<<"]==true && _pointer["<<true_branch<<"]>=_pointer_last_value["<<true_branch<<"])";
                                E_file<<" || (_if_flag["<<flag<<"]==false";
                                if(else_clause!=NULL) 
                		{	E_file<<"&& _pointer["<<false_branch<<"]>= _pointer_last_value["<<false_branch<<"]"; }
                		E_file<<"))\n";
                                E_file<<"\n{";
                                E_file<<"\n //if-statement has terminated";
                                E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                E_file<<"\n _pointer["<<true_branch<<"]=0;\n";
                                if(else_clause!=NULL)   E_file<<"\n _pointer["<<false_branch<<"]=0;\n";
                                E_file<<"\n}\n";

                                E_file<<"\n else ";
                                E_file<<"\n //if-statement has converged";
                                E_file<<"\n break;";
                                E_file<<"\n}\n";
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleif_statementEx; /* Prevent compiler warnings */
    ruleif_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                     (SCOPE_TOP(statement))->last_case=((SCOPE_TOP(statement))->k+1);

                }
            }


    return ;
}
/* $ANTLR end if_statement */

/**
 * $ANTLR start do_while_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:1995:1: do_while_statement : s= DO s1= sequence[Q] WHILE e1= expression_cf END DO ;
 */
static void
do_while_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    /* Initialize rule variables
     */


    	int Q=0; //pointer used by child sequence
    	int m=0; //last case in child sequence

    s       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2004:2: (s= DO s1= sequence[Q] WHILE e1= expression_cf END DO )
        // /home/project/sitarV2/translator/grammar/sitar.g:2004:4: s= DO s1= sequence[Q] WHILE e1= expression_cf END DO
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(DO, &FOLLOW_DO_in_do_while_statement3426);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


            {

                	Q=(SCOPE_TOP(cf))->pointer_count;
                	(SCOPE_TOP(cf))->pointer_count++;
                	
            }


            {


                	E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<" :";
                	E_file<<"\n{";
                	E_file<<"\n//do-while statement , line:"<<(s->getLine(s));
                	E_file<<"\n int _dowhile_iteration;";
                	E_file<<"\nfor(_dowhile_iteration=1; _dowhile_iteration<=SITAR_ITERATION_LIMIT; _dowhile_iteration++)";
                	E_file<<"\n{";
                	E_file<<"\n//execute the sequence  ";
                	
            }


            FOLLOWPUSH(FOLLOW_sequence_in_do_while_statement3516);
            s1=sequence(ctx, Q);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


             MATCHT(WHILE, &FOLLOW_WHILE_in_do_while_statement3580);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_do_while_statement3584);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


             MATCHT(END, &FOLLOW_END_in_do_while_statement3586);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


             MATCHT(DO, &FOLLOW_DO_in_do_while_statement3588);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


            {

                	m=s1
                ;
                	E_file<<"\nif(_pointer["<<Q<<"]< _pointer_last_value["<<Q<<"])  ";
                	E_file<<"\nbreak; //sequence has converged  ";
                	E_file<<"\n else ";
                	E_file<<"\n if(_pointer["<<Q<<"]==_pointer_last_value["<<Q<<"] && ("<<e1
                <<"==true))";
                	E_file<<"\n {";
                	E_file<<"\n//re-activate the sequence	"; 
                	E_file<<"\n_pointer["<<Q<<"]=0;	";
                	E_file<<"\n_reexecute=1;       	";
                	E_file<<"\n}				";
                	E_file<<"\nelse break; //sequence has terminated			";
                	E_file<<"\n };";

                		

                	E_file<<"\n	//For loop will finish if									";	
                	E_file<<"\n	//the sequence inside do-while loop converges                                                   ";
                	E_file<<"\n	//OR the expression becomes false at the end of some execution of while loop                    ";
                	E_file<<"\n	//OR  if the iteration limit is exceeded.                                                       ";
                	
                	E_file<<"\n	if (_dowhile_iteration>SITAR_ITERATION_LIMIT)   ";
                	E_file<<"\n	{                                                                                               ";
                	E_file<<"\n		//iteration limit exceeded. Throw error and                                             ";
                	E_file<<"\n		//terminate the do-while statement                                                      ";
                	E_file<<"\n 		std::cerr<<\"\\nERROR:Iteration limit exceeded for do-while loop on line:"<<(s->getLine(s))<<" in file "<<GDATA->getAttribute("INPUT_FILE")<<"\";";
                	E_file<<"\n		_pointer["<<Q<<"]=0;                                                               ";
                	E_file<<"\n		_incrementPointer("<<(SCOPE_TOP(statement))->p<<");                                                                    ";
                	E_file<<"\n	}                                                                                              ";
                	
                	E_file<<"\n	else if(_pointer["<<Q<<"]<_pointer_last_value["<<Q<<"])                                    ";
                	E_file<<"\n	{                                                                                               ";
                	E_file<<"\n		//sequence just converged;                                                              ";
                	E_file<<"\n		break;                                                                                  ";
                	E_file<<"\n	}                                                                                               ";
                	E_file<<"\n	else if (_pointer["<<Q<<"]==_pointer_last_value["<<Q<<"] && ("<<
                e1
                <<"==false))  ";
                	E_file<<"\n	{                                                                                               ";
                	E_file<<"\n		//terminate the do-while statement                                                      ";
                	E_file<<"\n		_pointer["<<Q<<"]=0;                                                               ";
                	E_file<<"\n		_incrementPointer("<<(SCOPE_TOP(statement))->p<<");                                                                    ";
                	E_file<<"\n	} ;                                                                                              ";
                	
                	E_file<<"\n};                                                                                                   ";
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledo_while_statementEx; /* Prevent compiler warnings */
    ruledo_while_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end do_while_statement */

/**
 * $ANTLR start parallel_statement
 * /home/project/sitarV2/translator/grammar/sitar.g:2072:1: parallel_statement : s= '[' s1= sequence[ptr] ( '||' s2= sequence[ptr] )+ ']' ;
 */
static void
parallel_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    int s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 int

    /* Initialize rule variables
     */


            //list that stores pointers and last
            //states of each of the sequences contained in the
            //parallel region.
            std::list<std::pair<int,int> > ptr_list;
            std::list<std::pair<int,int> >::iterator it;
            std::pair<int,int> pair;

            int branches=0; //number of branches
            int ptr=0;      //pointer for each branch
    	ptr_list.clear();

    s       = NULL;

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2093:9: (s= '[' s1= sequence[ptr] ( '||' s2= sequence[ptr] )+ ']' )
        // /home/project/sitarV2/translator/grammar/sitar.g:2093:11: s= '[' s1= sequence[ptr] ( '||' s2= sequence[ptr] )+ ']'
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(82, &FOLLOW_82_in_parallel_statement3632);
            if  (HASEXCEPTION())
            {
                goto ruleparallel_statementEx;
            }


            {
                	//write some text
                			E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                			E_file<<" {\n";
                			E_file<<"\n//parallel statement begins, line "<<(s->getLine(s));
                			
                			//generate a pointer for the child sequence
                			ptr=(SCOPE_TOP(cf))->pointer_count;
                			++(SCOPE_TOP(cf))->pointer_count;

                                	
            }


            {
                E_file<<"\n//one branch of parallel statement, using pointer "<<ptr;
            }


            FOLLOWPUSH(FOLLOW_sequence_in_parallel_statement3692);
            s1=sequence(ctx, ptr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparallel_statementEx;
            }


            {

                	pair=std::make_pair(ptr, s1
                );
                        	ptr_list.push_back(pair);
                        
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2114:9: ( '||' s2= sequence[ptr] )+
            {
                int cnt67=0;

                for (;;)
                {
                    int alt67=2;
            	switch ( LA(1) )
            	{
            	case 84:
            		{
            			alt67=1;
            		}
            	    break;

            	}

            	switch (alt67)
            	{
            	    case 1:
            	        // /home/project/sitarV2/translator/grammar/sitar.g:2114:10: '||' s2= sequence[ptr]
            	        {
            	             MATCHT(84, &FOLLOW_84_in_parallel_statement3735);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparallel_statementEx;
            	            }


            	            {

            	                                        //generate a pointer for the child sequence
            	                                        ptr=(SCOPE_TOP(cf))->pointer_count;
            	                                        ++(SCOPE_TOP(cf))->pointer_count;
            	                                
            	            }


            	            {
            	                E_file<<"\n//another branch of parallel statement, using pointer "<<ptr;
            	            }


            	            FOLLOWPUSH(FOLLOW_sequence_in_parallel_statement3792);
            	            s2=sequence(ctx, ptr);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparallel_statementEx;
            	            }


            	            {
            	                 
            	                	pair=std::make_pair(ptr, s2
            	                );
            	                        	ptr_list.push_back(pair);
            	                        
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt67 >= 1 )
            		{
            		    goto loop67;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleparallel_statementEx;
            	}
            	cnt67++;
                }
                loop67: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(83, &FOLLOW_83_in_parallel_statement3826);
            if  (HASEXCEPTION())
            {
                goto ruleparallel_statementEx;
            }


            {

                                //write some code at the end of the parallel block:
                                //to check if all parallel branches have terminated
                                E_file<<"\n//if all parallel branches have terminated,";
                                E_file<<"\n//exit the parallel statement.";
                                E_file<<"\nif(";

                                for(it=ptr_list.begin(); it!=ptr_list.end();it++)
                                {
                                        if(!(it==ptr_list.begin()))
                                              E_file<<" &&";
                                        pair=*it;
                                        int P=pair.first;
                                        int Q=pair.second;
                                        E_file<<" _pointer["<<P<<"]=="<<Q;
                                }
                                E_file<<") \n{\n";
                                E_file<<"\n //reset pointers of parallel branches";
                                for(it=ptr_list.begin(); it!=ptr_list.end();it++)
                                         {
                                              pair=*it;
                                               int P=pair.first;
                                                E_file<<"\n_pointer["<<P<<"]=0;";
                	}
                	E_file<<"\n_reexecute=1;";
                	E_file<<"\n//terminate the parallel statement";
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");\n}";
                	
                                E_file<<"\nelse \n break;";
                                E_file<<"\n//parallel statement ends";
                                E_file<<"\n}\n";
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparallel_statementEx; /* Prevent compiler warnings */
    ruleparallel_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                     	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;

                }
            }


    return ;
}
/* $ANTLR end parallel_statement */

/**
 * $ANTLR start expression_cf
 * /home/project/sitarV2/translator/grammar/sitar.g:2249:1: expression_cf returns [std::string text] : e1= exp1 ( OR e2= exp1 )* ;
 */
static std::string
expression_cf(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2250:9: (e1= exp1 ( OR e2= exp1 )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:2253:9: e1= exp1 ( OR e2= exp1 )*
        {
            FOLLOWPUSH(FOLLOW_exp1_in_expression_cf3985);
            e1=exp1(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpression_cfEx;
            }


            {
                text=
                e1
                ;

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2254:9: ( OR e2= exp1 )*

            for (;;)
            {
                int alt68=2;
                switch ( LA(1) )
                {
                case OR:
                	{
                		alt68=1;
                	}
                    break;

                }

                switch (alt68)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2254:11: OR e2= exp1
            	    {
            	         MATCHT(OR, &FOLLOW_OR_in_expression_cf3998);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpression_cfEx;
            	        }


            	        {
            	            text
            	            .append("||");
            	        }


            	        FOLLOWPUSH(FOLLOW_exp1_in_expression_cf4003);
            	        e2=exp1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpression_cfEx;
            	        }


            	        {
            	            text
            	            .append(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop68;	/* break out of the loop */
            	    break;
                }
            }
            loop68: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpression_cfEx; /* Prevent compiler warnings */
    ruleexpression_cfEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end expression_cf */

/**
 * $ANTLR start exp1
 * /home/project/sitarV2/translator/grammar/sitar.g:2258:1: exp1 returns [std::string text] : e1= exp2 ( AND e2= exp2 )* ;
 */
static std::string
exp1(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2259:9: (e1= exp2 ( AND e2= exp2 )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:2260:9: e1= exp2 ( AND e2= exp2 )*
        {
            FOLLOWPUSH(FOLLOW_exp2_in_exp14047);
            e1=exp2(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp1Ex;
            }


            {
                text=
                e1
                ;

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2261:9: ( AND e2= exp2 )*

            for (;;)
            {
                int alt69=2;
                switch ( LA(1) )
                {
                case AND:
                	{
                		alt69=1;
                	}
                    break;

                }

                switch (alt69)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2261:10: AND e2= exp2
            	    {
            	         MATCHT(AND, &FOLLOW_AND_in_exp14059);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp1Ex;
            	        }


            	        {
            	            text
            	            .append("&&");
            	        }


            	        FOLLOWPUSH(FOLLOW_exp2_in_exp14067);
            	        e2=exp2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp1Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            );  
            	        }


            	    }
            	    break;

            	default:
            	    goto loop69;	/* break out of the loop */
            	    break;
                }
            }
            loop69: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp1Ex; /* Prevent compiler warnings */
    ruleexp1Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp1 */

/**
 * $ANTLR start exp2
 * /home/project/sitarV2/translator/grammar/sitar.g:2265:1: exp2 returns [std::string text] : ( NOT )? exp3 ;
 */
static std::string
exp2(psitarParser ctx)
{
    std::string text;


    std::string exp33;
    #undef	RETURN_TYPE_exp33
    #define	RETURN_TYPE_exp33 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2266:9: ( ( NOT )? exp3 )
        // /home/project/sitarV2/translator/grammar/sitar.g:2266:10: ( NOT )? exp3
        {
            {
                text="";

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2267:9: ( NOT )?
            {
                int alt70=2;
                switch ( LA(1) )
                {
                    case NOT:
                    	{
                    		alt70=1;
                    	}
                        break;
                }

                switch (alt70)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2267:10: NOT
            	    {
            	         MATCHT(NOT, &FOLLOW_NOT_in_exp24117);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp2Ex;
            	        }


            	        {
            	            text
            	            .append("!");
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_exp3_in_exp24132);
            exp33=exp3(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp2Ex;
            }


            {
                text
                .append("(");text
                .append(exp33
                ); text
                .append(")");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp2Ex; /* Prevent compiler warnings */
    ruleexp2Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp2 */

/**
 * $ANTLR start exp3
 * /home/project/sitarV2/translator/grammar/sitar.g:2271:1: exp3 returns [std::string text] : e1= exp4 (c1= comparison_operator e2= exp4 )* ;
 */
static std::string
exp3(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    sitarParser_comparison_operator_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 sitarParser_comparison_operator_return

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2272:9: (e1= exp4 (c1= comparison_operator e2= exp4 )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:2272:10: e1= exp4 (c1= comparison_operator e2= exp4 )*
        {
            FOLLOWPUSH(FOLLOW_exp4_in_exp34162);
            e1=exp4(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp3Ex;
            }


            {
                text=
                e1
                ;

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2273:10: (c1= comparison_operator e2= exp4 )*

            for (;;)
            {
                int alt71=2;
                switch ( LA(1) )
                {
                case CONNECT_LEFT:
                case 70:
                case 78:
                case 79:
                case 80:
                case 81:
                	{
                		alt71=1;
                	}
                    break;

                }

                switch (alt71)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2273:11: c1= comparison_operator e2= exp4
            	    {
            	        FOLLOWPUSH(FOLLOW_comparison_operator_in_exp34177);
            	        c1=comparison_operator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp3Ex;
            	        }


            	        {
            	            text
            	            .append( (const char*)((STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
            	            ->chars));
            	        }


            	        FOLLOWPUSH(FOLLOW_exp4_in_exp34193);
            	        e2=exp4(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp3Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop71;	/* break out of the loop */
            	    break;
                }
            }
            loop71: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp3Ex; /* Prevent compiler warnings */
    ruleexp3Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp3 */

/**
 * $ANTLR start exp4
 * /home/project/sitarV2/translator/grammar/sitar.g:2280:1: exp4 returns [std::string text] : e1= exp5 (c1= add_operator e2= exp5 )* ;
 */
static std::string
exp4(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    sitarParser_add_operator_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 sitarParser_add_operator_return

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2281:9: (e1= exp5 (c1= add_operator e2= exp5 )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:2281:11: e1= exp5 (c1= add_operator e2= exp5 )*
        {
            FOLLOWPUSH(FOLLOW_exp5_in_exp44238);
            e1=exp5(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp4Ex;
            }


            {
                text=
                e1
                ;

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2282:10: (c1= add_operator e2= exp5 )*

            for (;;)
            {
                int alt72=2;
                switch ( LA(1) )
                {
                case MINUS:
                case PLUS:
                	{
                		alt72=1;
                	}
                    break;

                }

                switch (alt72)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2282:11: c1= add_operator e2= exp5
            	    {
            	        FOLLOWPUSH(FOLLOW_add_operator_in_exp44253);
            	        c1=add_operator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp4Ex;
            	        }


            	        {
            	            text
            	            .append((const char*)((STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
            	            ->chars));
            	        }


            	        FOLLOWPUSH(FOLLOW_exp5_in_exp44269);
            	        e2=exp5(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp4Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop72;	/* break out of the loop */
            	    break;
                }
            }
            loop72: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp4Ex; /* Prevent compiler warnings */
    ruleexp4Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp4 */

/**
 * $ANTLR start exp5
 * /home/project/sitarV2/translator/grammar/sitar.g:2288:1: exp5 returns [std::string text] : e1= exp6 (c1= mul_operator e2= exp6 )* ;
 */
static std::string
exp5(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    sitarParser_mul_operator_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 sitarParser_mul_operator_return

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2289:9: (e1= exp6 (c1= mul_operator e2= exp6 )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:2289:11: e1= exp6 (c1= mul_operator e2= exp6 )*
        {
            FOLLOWPUSH(FOLLOW_exp6_in_exp54313);
            e1=exp6(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp5Ex;
            }


            {
                text=
                e1
                ;
                 
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2290:9: (c1= mul_operator e2= exp6 )*

            for (;;)
            {
                int alt73=2;
                switch ( LA(1) )
                {
                case 71:
                case 74:
                case 76:
                	{
                		alt73=1;
                	}
                    break;

                }

                switch (alt73)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2290:11: c1= mul_operator e2= exp6
            	    {
            	        FOLLOWPUSH(FOLLOW_mul_operator_in_exp54328);
            	        c1=mul_operator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp5Ex;
            	        }


            	        {
            	            text
            	            .append((const char*)((STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
            	            ->chars));
            	        }


            	        FOLLOWPUSH(FOLLOW_exp6_in_exp54344);
            	        e2=exp6(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp5Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            );  
            	        }


            	    }
            	    break;

            	default:
            	    goto loop73;	/* break out of the loop */
            	    break;
                }
            }
            loop73: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp5Ex; /* Prevent compiler warnings */
    ruleexp5Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp5 */

/**
 * $ANTLR start exp6
 * /home/project/sitarV2/translator/grammar/sitar.g:2295:1: exp6 returns [std::string text] : ( '-' )? a1= atomic_expression_cf ;
 */
static std::string
exp6(psitarParser ctx)
{
    std::string text;


    std::string a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2296:9: ( ( '-' )? a1= atomic_expression_cf )
        // /home/project/sitarV2/translator/grammar/sitar.g:2296:10: ( '-' )? a1= atomic_expression_cf
        {
            {
                text="(";

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2297:9: ( '-' )?
            {
                int alt74=2;
                switch ( LA(1) )
                {
                    case MINUS:
                    	{
                    		alt74=1;
                    	}
                        break;
                }

                switch (alt74)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2297:10: '-'
            	    {
            	         MATCHT(MINUS, &FOLLOW_MINUS_in_exp64394);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp6Ex;
            	        }


            	        {
            	            text
            	            .append("-");
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_atomic_expression_cf_in_exp64412);
            a1=atomic_expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp6Ex;
            }


            {
                text
                .append(a1
                ); text
                .append(")");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp6Ex; /* Prevent compiler warnings */
    ruleexp6Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp6 */

/**
 * $ANTLR start comparison_operator
 * /home/project/sitarV2/translator/grammar/sitar.g:2305:1: comparison_operator : ( '==' | '!=' | '>=' | '<=' | '<' | '>' );
 */
static sitarParser_comparison_operator_return
comparison_operator(psitarParser ctx)
{
    sitarParser_comparison_operator_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2306:9: ( '==' | '!=' | '>=' | '<=' | '<' | '>' )
        // /home/project/sitarV2/translator/grammar/sitar.g:
        {
            if ( LA(1) == CONNECT_LEFT || LA(1) == 70 || ((LA(1) >= 78) && (LA(1) <= 81)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulecomparison_operatorEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparison_operatorEx; /* Prevent compiler warnings */
    rulecomparison_operatorEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end comparison_operator */

/**
 * $ANTLR start add_operator
 * /home/project/sitarV2/translator/grammar/sitar.g:2308:1: add_operator : ( '+' | '-' );
 */
static sitarParser_add_operator_return
add_operator(psitarParser ctx)
{
    sitarParser_add_operator_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2309:9: ( '+' | '-' )
        // /home/project/sitarV2/translator/grammar/sitar.g:
        {
            if ( LA(1) == MINUS || LA(1) == PLUS )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleadd_operatorEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadd_operatorEx; /* Prevent compiler warnings */
    ruleadd_operatorEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end add_operator */

/**
 * $ANTLR start mul_operator
 * /home/project/sitarV2/translator/grammar/sitar.g:2311:1: mul_operator : ( '*' | '/' | '%' );
 */
static sitarParser_mul_operator_return
mul_operator(psitarParser ctx)
{
    sitarParser_mul_operator_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2312:9: ( '*' | '/' | '%' )
        // /home/project/sitarV2/translator/grammar/sitar.g:
        {
            if ( LA(1) == 71 || LA(1) == 74 || LA(1) == 76 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulemul_operatorEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemul_operatorEx; /* Prevent compiler warnings */
    rulemul_operatorEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end mul_operator */

/**
 * $ANTLR start atomic_expression_cf
 * /home/project/sitarV2/translator/grammar/sitar.g:2317:1: atomic_expression_cf returns [std::string text] : ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block );
 */
static std::string
atomic_expression_cf(psitarParser ctx)
{
    std::string text;


    pANTLR3_COMMON_TOKEN    int1;
    pANTLR3_COMMON_TOKEN    str1;
    std::string e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e std::string

    sitarParser_function_call_return f;
    #undef	RETURN_TYPE_f
    #define	RETURN_TYPE_f sitarParser_function_call_return

    std::string tc;
    #undef	RETURN_TYPE_tc
    #define	RETURN_TYPE_tc std::string

    std::string tp;
    #undef	RETURN_TYPE_tp
    #define	RETURN_TYPE_tp std::string

    sitarParser_identifier_return id1;
    #undef	RETURN_TYPE_id1
    #define	RETURN_TYPE_id1 sitarParser_identifier_return

    sitarParser_expression_code_block_return exp;
    #undef	RETURN_TYPE_exp
    #define	RETURN_TYPE_exp sitarParser_expression_code_block_return

    /* Initialize rule variables
     */

    int1       = NULL;
    str1       = NULL;

    {
        {
            //  /home/project/sitarV2/translator/grammar/sitar.g:2318:9: ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block )

            ANTLR3_UINT32 alt75;

            alt75=8;

            alt75 = cdfa75.predict(ctx, RECOGNIZER, ISTREAM, &cdfa75);
            if  (HASEXCEPTION())
            {
                goto ruleatomic_expression_cfEx;
            }

            switch (alt75)
            {
        	case 1:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2319:9: '(' e= expression_cf ')'
        	    {
        	         MATCHT(72, &FOLLOW_72_in_atomic_expression_cf4545);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_cf_in_atomic_expression_cf4548);
        	        e=expression_cf(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	         MATCHT(73, &FOLLOW_73_in_atomic_expression_cf4549);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text="("+
        	            e
        	            +")";

        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2321:10: f= function_call
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_atomic_expression_cf4574);
        	        f=function_call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            f.text
        	            ;

        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2322:10: tc= this_cycle
        	    {
        	        FOLLOWPUSH(FOLLOW_this_cycle_in_atomic_expression_cf4591);
        	        tc=this_cycle(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            tc
        	            ;

        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2323:10: tp= this_phase
        	    {
        	        FOLLOWPUSH(FOLLOW_this_phase_in_atomic_expression_cf4610);
        	        tp=this_phase(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            tp
        	            ;

        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2324:10: int1= INTEGER
        	    {
        	        int1 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_atomic_expression_cf4629);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=((const char*)(int1->getText(int1))->chars);

        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2325:10: str1= STRING
        	    {
        	        str1 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_atomic_expression_cf4649);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=((const char*)(str1->getText(str1))->chars);

        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2326:10: id1= identifier
        	    {
        	        FOLLOWPUSH(FOLLOW_identifier_in_atomic_expression_cf4672);
        	        id1=identifier(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=((const char*)
        	            (STRSTREAM->toStringTT(STRSTREAM, id1.start, id1.stop))
        	            ->chars);

        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/project/sitarV2/translator/grammar/sitar.g:2327:11: exp= expression_code_block
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_code_block_in_atomic_expression_cf4691);
        	        exp=expression_code_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            exp.text
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomic_expression_cfEx; /* Prevent compiler warnings */
    ruleatomic_expression_cfEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end atomic_expression_cf */

/**
 * $ANTLR start expression_code_block
 * /home/project/sitarV2/translator/grammar/sitar.g:2332:1: expression_code_block returns [std::string text, int line] : c= code_block ;
 */
static sitarParser_expression_code_block_return
expression_code_block(psitarParser ctx)
{
    sitarParser_expression_code_block_return retval;


    sitarParser_code_block_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_return

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2333:9: (c= code_block )
        // /home/project/sitarV2/translator/grammar/sitar.g:2333:11: c= code_block
        {
            FOLLOWPUSH(FOLLOW_code_block_in_expression_code_block4754);
            c=code_block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpression_code_blockEx;
            }


            {
                retval.line=
                c.line
                ;
                 
                             retval.text=
                c.text
                ;

                            
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpression_code_blockEx; /* Prevent compiler warnings */
    ruleexpression_code_blockEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end expression_code_block */

/**
 * $ANTLR start function_call
 * /home/project/sitarV2/translator/grammar/sitar.g:2342:1: function_call returns [std::string text, int line] : id1= identifier '(' (a1= argument_list )? ')' ;
 */
static sitarParser_function_call_return
function_call(psitarParser ctx)
{
    sitarParser_function_call_return retval;


    sitarParser_identifier_return id1;
    #undef	RETURN_TYPE_id1
    #define	RETURN_TYPE_id1 sitarParser_identifier_return

    std::string a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 std::string

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2343:9: (id1= identifier '(' (a1= argument_list )? ')' )
        // /home/project/sitarV2/translator/grammar/sitar.g:2344:9: id1= identifier '(' (a1= argument_list )? ')'
        {
            FOLLOWPUSH(FOLLOW_identifier_in_function_call4839);
            id1=identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunction_callEx;
            }


             MATCHT(72, &FOLLOW_72_in_function_call4841);
            if  (HASEXCEPTION())
            {
                goto rulefunction_callEx;
            }


            {
                retval.line=
                id1.line
                ;
                 
                             retval.text=((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, id1.start, id1.stop))
                ->chars);

                             retval.text
                .append("(");
                            
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2349:10: (a1= argument_list )?
            {
                int alt76=2;
                switch ( LA(1) )
                {
                    case CODE_BLOCK:
                    case IDENTIFIER:
                    case INTEGER:
                    case MINUS:
                    case NOT:
                    case STRING:
                    case THIS_CYCLE:
                    case THIS_PHASE:
                    case 72:
                    	{
                    		alt76=1;
                    	}
                        break;
                }

                switch (alt76)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2349:12: a1= argument_list
            	    {
            	        FOLLOWPUSH(FOLLOW_argument_list_in_function_call4870);
            	        a1=argument_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunction_callEx;
            	        }


            	        {
            	             retval.text
            	            .append(a1
            	            ); 
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(73, &FOLLOW_73_in_function_call4894);
            if  (HASEXCEPTION())
            {
                goto rulefunction_callEx;
            }


            {
                retval.text
                .append(")");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end function_call */

/**
 * $ANTLR start argument_list
 * /home/project/sitarV2/translator/grammar/sitar.g:2356:1: argument_list returns [std::string text] : e1= expression_cf ( ',' e2= expression_cf )* ;
 */
static std::string
argument_list(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2357:9: (e1= expression_cf ( ',' e2= expression_cf )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:2357:12: e1= expression_cf ( ',' e2= expression_cf )*
        {
            FOLLOWPUSH(FOLLOW_expression_cf_in_argument_list4929);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleargument_listEx;
            }


            {
                text=
                e1
                ;

            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2358:9: ( ',' e2= expression_cf )*

            for (;;)
            {
                int alt77=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt77=1;
                	}
                    break;

                }

                switch (alt77)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2358:11: ',' e2= expression_cf
            	    {
            	         MATCHT(75, &FOLLOW_75_in_argument_list4950);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargument_listEx;
            	        }


            	        {
            	            text
            	            .append(",");
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_cf_in_argument_list4985);
            	        e2=expression_cf(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargument_listEx;
            	        }


            	        {
            	            text
            	            .append(e2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop77;	/* break out of the loop */
            	    break;
                }
            }
            loop77: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleargument_listEx; /* Prevent compiler warnings */
    ruleargument_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end argument_list */

/**
 * $ANTLR start this_cycle
 * /home/project/sitarV2/translator/grammar/sitar.g:2366:1: this_cycle returns [std::string text] : THIS_CYCLE ;
 */
static std::string
this_cycle(psitarParser ctx)
{
    std::string text;


    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2367:9: ( THIS_CYCLE )
        // /home/project/sitarV2/translator/grammar/sitar.g:2367:17: THIS_CYCLE
        {
             MATCHT(THIS_CYCLE, &FOLLOW_THIS_CYCLE_in_this_cycle5039);
            if  (HASEXCEPTION())
            {
                goto rulethis_cycleEx;
            }


            {
                text="(current_time.cycle())";

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulethis_cycleEx; /* Prevent compiler warnings */
    rulethis_cycleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end this_cycle */

/**
 * $ANTLR start this_phase
 * /home/project/sitarV2/translator/grammar/sitar.g:2371:1: this_phase returns [std::string text] : THIS_PHASE ;
 */
static std::string
this_phase(psitarParser ctx)
{
    std::string text;


    /* Initialize rule variables
     */

    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2372:9: ( THIS_PHASE )
        // /home/project/sitarV2/translator/grammar/sitar.g:2372:17: THIS_PHASE
        {
             MATCHT(THIS_PHASE, &FOLLOW_THIS_PHASE_in_this_phase5092);
            if  (HASEXCEPTION())
            {
                goto rulethis_phaseEx;
            }


            {
                text="(current_time.phase())";

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulethis_phaseEx; /* Prevent compiler warnings */
    rulethis_phaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end this_phase */

/**
 * $ANTLR start code_block_with_info
 * /home/project/sitarV2/translator/grammar/sitar.g:2378:1: code_block_with_info returns [std::string text, int line] : code_block ;
 */
static sitarParser_code_block_with_info_return
code_block_with_info(psitarParser ctx)
{
    sitarParser_code_block_with_info_return retval;


    sitarParser_code_block_return code_block4;
    #undef	RETURN_TYPE_code_block4
    #define	RETURN_TYPE_code_block4 sitarParser_code_block_return

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2379:9: ( code_block )
        // /home/project/sitarV2/translator/grammar/sitar.g:2379:19: code_block
        {
            FOLLOWPUSH(FOLLOW_code_block_in_code_block_with_info5150);
            code_block4=code_block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecode_block_with_infoEx;
            }


            {


                                //Delete the delimeters of the code block,
                                //and return the entire code as a string
                                //to the parent rule
                                retval.line=
                code_block4.line
                ;

                                retval.text= 
                code_block4.text
                ;

                                 std::stringstream ss;
                                ss.str(std::string());  //clear the string stream
                                ss<<"\n//----code block from file "<<(GDATA->getAttribute("INPUT_FILE"))<<", line:"<<code_block4.line
                <<" ----\n";
                                ss<<retval.text
                ;
                                ss<<"\n//----end code block-------\n";
                                retval.text=ss.str();

                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecode_block_with_infoEx; /* Prevent compiler warnings */
    rulecode_block_with_infoEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end code_block_with_info */

/**
 * $ANTLR start code_block
 * /home/project/sitarV2/translator/grammar/sitar.g:2403:1: code_block returns [std::string text, int line] : CODE_BLOCK ;
 */
static sitarParser_code_block_return
code_block(psitarParser ctx)
{
    sitarParser_code_block_return retval;


    pANTLR3_COMMON_TOKEN    CODE_BLOCK5;

    /* Initialize rule variables
     */

    CODE_BLOCK5       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2404:9: ( CODE_BLOCK )
        // /home/project/sitarV2/translator/grammar/sitar.g:2404:20: CODE_BLOCK
        {
            CODE_BLOCK5 = (pANTLR3_COMMON_TOKEN) MATCHT(CODE_BLOCK, &FOLLOW_CODE_BLOCK_in_code_block5217);
            if  (HASEXCEPTION())
            {
                goto rulecode_blockEx;
            }


            {


                                //Delete the delimeters of the code block,
                                //and return the entire code as a string
                                //to the parent rule
                                retval.line=(CODE_BLOCK5->getLine(CODE_BLOCK5));

                                retval.text= std::string((const char*)((CODE_BLOCK5->getText(CODE_BLOCK5))->chars));

                                std::string &s = retval.text
                ;
                                //erase the first '$'
                                s.erase(0,1);
                                //erase the last '$'
                                if(s.size() > 0)
                                   s.resize(s.size() - 1);
                                //s.erase(s.find("$"),1);
                                
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecode_blockEx; /* Prevent compiler warnings */
    rulecode_blockEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end code_block */

/**
 * $ANTLR start identifier
 * /home/project/sitarV2/translator/grammar/sitar.g:2424:1: identifier returns [int line] : id= IDENTIFIER ( ( DOT | SCOPE | POINTER ) IDENTIFIER )* ;
 */
static sitarParser_identifier_return
identifier(psitarParser ctx)
{
    sitarParser_identifier_return retval;


    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    id       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/project/sitarV2/translator/grammar/sitar.g:2425:2: (id= IDENTIFIER ( ( DOT | SCOPE | POINTER ) IDENTIFIER )* )
        // /home/project/sitarV2/translator/grammar/sitar.g:2425:5: id= IDENTIFIER ( ( DOT | SCOPE | POINTER ) IDENTIFIER )*
        {
            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_identifier5273);
            if  (HASEXCEPTION())
            {
                goto ruleidentifierEx;
            }


            // /home/project/sitarV2/translator/grammar/sitar.g:2425:18: ( ( DOT | SCOPE | POINTER ) IDENTIFIER )*

            for (;;)
            {
                int alt78=2;
                switch ( LA(1) )
                {
                case DOT:
                case POINTER:
                case SCOPE:
                	{
                		alt78=1;
                	}
                    break;

                }

                switch (alt78)
                {
            	case 1:
            	    // /home/project/sitarV2/translator/grammar/sitar.g:2425:19: ( DOT | SCOPE | POINTER ) IDENTIFIER
            	    {
            	        if ( LA(1) == DOT || LA(1) == POINTER || LA(1) == SCOPE )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleidentifierEx;
            	        }


            	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_identifier5282);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifierEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop78;	/* break out of the loop */
            	    break;
                }
            }
            loop78: ; /* Jump out to here if this rule does not match */


            {
                retval.line=(id->getLine(id));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end identifier */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
