/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /home/nehak/Projects/sitar/translator/grammar/sitar.g
 *     -                            On : 2017-04-30 16:08:14
 *     -                for the parser : sitarParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "sitarParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   psitarParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  psitarParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->psitarParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->psitarParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_top scope set
 */
static psitarParser_top_SCOPE   psitarParser_topPush(psitarParser ctx);
static void ANTLR3_CDECL topFree(psitarParser_top_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL topFree(psitarParser_top_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser top scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_topTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_top_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_top_SCOPE
psitarParser_topPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_top_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_topStack->size(ctx->psitarParser_topStack) > ctx->psitarParser_topStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_top_SCOPE)ctx->psitarParser_topStack->get(ctx->psitarParser_topStack, ctx->psitarParser_topStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_top_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_top_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_topStack->push(ctx->psitarParser_topStack, newAttributes, (void (*)(void *))topFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_topStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_du scope set
 */
static psitarParser_du_SCOPE   psitarParser_duPush(psitarParser ctx);
static void ANTLR3_CDECL duFree(psitarParser_du_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL duFree(psitarParser_du_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser du scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_duTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_du_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_du_SCOPE
psitarParser_duPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_du_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_duStack->size(ctx->psitarParser_duStack) > ctx->psitarParser_duStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_du_SCOPE)ctx->psitarParser_duStack->get(ctx->psitarParser_duStack, ctx->psitarParser_duStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_du_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_du_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_duStack->push(ctx->psitarParser_duStack, newAttributes, (void (*)(void *))duFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_duStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_port_declaration scope set
 */
static psitarParser_port_declaration_SCOPE   psitarParser_port_declarationPush(psitarParser ctx);
static void ANTLR3_CDECL port_declarationFree(psitarParser_port_declaration_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL port_declarationFree(psitarParser_port_declaration_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser port_declaration scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_port_declarationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_port_declaration_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_port_declaration_SCOPE
psitarParser_port_declarationPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_port_declaration_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_port_declarationStack->size(ctx->psitarParser_port_declarationStack) > ctx->psitarParser_port_declarationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_port_declaration_SCOPE)ctx->psitarParser_port_declarationStack->get(ctx->psitarParser_port_declarationStack, ctx->psitarParser_port_declarationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_port_declaration_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_port_declaration_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_port_declarationStack->push(ctx->psitarParser_port_declarationStack, newAttributes, (void (*)(void *))port_declarationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_port_declarationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_net_declaration scope set
 */
static psitarParser_net_declaration_SCOPE   psitarParser_net_declarationPush(psitarParser ctx);
static void ANTLR3_CDECL net_declarationFree(psitarParser_net_declaration_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL net_declarationFree(psitarParser_net_declaration_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser net_declaration scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_net_declarationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_net_declaration_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_net_declaration_SCOPE
psitarParser_net_declarationPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_net_declaration_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_net_declarationStack->size(ctx->psitarParser_net_declarationStack) > ctx->psitarParser_net_declarationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_net_declaration_SCOPE)ctx->psitarParser_net_declarationStack->get(ctx->psitarParser_net_declarationStack, ctx->psitarParser_net_declarationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_net_declaration_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_net_declaration_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_net_declarationStack->push(ctx->psitarParser_net_declarationStack, newAttributes, (void (*)(void *))net_declarationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_net_declarationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_cf scope set
 */
static psitarParser_cf_SCOPE   psitarParser_cfPush(psitarParser ctx);
static void ANTLR3_CDECL cfFree(psitarParser_cf_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL cfFree(psitarParser_cf_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser cf scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_cfTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_cf_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_cf_SCOPE
psitarParser_cfPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_cf_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_cfStack->size(ctx->psitarParser_cfStack) > ctx->psitarParser_cfStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_cf_SCOPE)ctx->psitarParser_cfStack->get(ctx->psitarParser_cfStack, ctx->psitarParser_cfStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_cf_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_cf_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_cfStack->push(ctx->psitarParser_cfStack, newAttributes, (void (*)(void *))cfFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_cfStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a sitarParser_statement scope set
 */
static psitarParser_statement_SCOPE   psitarParser_statementPush(psitarParser ctx);
static void ANTLR3_CDECL statementFree(psitarParser_statement_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL statementFree(psitarParser_statement_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a sitarParser statement scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->psitarParser_statementTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( psitarParser_statement_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static psitarParser_statement_SCOPE
psitarParser_statementPush(psitarParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    psitarParser_statement_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->psitarParser_statementStack->size(ctx->psitarParser_statementStack) > ctx->psitarParser_statementStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (psitarParser_statement_SCOPE)ctx->psitarParser_statementStack->get(ctx->psitarParser_statementStack, ctx->psitarParser_statementStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (psitarParser_statement_SCOPE) ANTLR3_MALLOC(sizeof(sitarParser_statement_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->psitarParser_statementStack->push(ctx->psitarParser_statementStack, newAttributes, (void (*)(void *))statementFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->psitarParser_statementStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}







/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   sitarParserTokenNames[81+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "BEGIN",
        (pANTLR3_UINT8) "BEHAVIOR",
        (pANTLR3_UINT8) "BOOL",
        (pANTLR3_UINT8) "CAPACITY",
        (pANTLR3_UINT8) "CHAR",
        (pANTLR3_UINT8) "CODE",
        (pANTLR3_UINT8) "CODE_BLOCK",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONNECT_LEFT",
        (pANTLR3_UINT8) "CONNECT_RIGHT",
        (pANTLR3_UINT8) "DECL",
        (pANTLR3_UINT8) "DO",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "ELSE",
        (pANTLR3_UINT8) "END",
        (pANTLR3_UINT8) "EQUALS",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "EXPR",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "IN",
        (pANTLR3_UINT8) "INCLUDE",
        (pANTLR3_UINT8) "INIT",
        (pANTLR3_UINT8) "INPORT",
        (pANTLR3_UINT8) "INPORT_ARRAY",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "KEYWORD_BOOL",
        (pANTLR3_UINT8) "KEYWORD_CHAR",
        (pANTLR3_UINT8) "KEYWORD_INT",
        (pANTLR3_UINT8) "LOG",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "MODULE",
        (pANTLR3_UINT8) "NET",
        (pANTLR3_UINT8) "NET_ARRAY",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "NOTHING",
        (pANTLR3_UINT8) "OCTAL_ESC",
        (pANTLR3_UINT8) "OR",
        (pANTLR3_UINT8) "OUTPORT",
        (pANTLR3_UINT8) "OUTPORT_ARRAY",
        (pANTLR3_UINT8) "PARAMETER",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "POINTER",
        (pANTLR3_UINT8) "PROCEDURE",
        (pANTLR3_UINT8) "RUN",
        (pANTLR3_UINT8) "SCOPE",
        (pANTLR3_UINT8) "SEND",
        (pANTLR3_UINT8) "SIMULATION",
        (pANTLR3_UINT8) "STOP",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SUBMODULE",
        (pANTLR3_UINT8) "SUBMODULE_ARRAY",
        (pANTLR3_UINT8) "THEN",
        (pANTLR3_UINT8) "THIS_CYCLE",
        (pANTLR3_UINT8) "THIS_PHASE",
        (pANTLR3_UINT8) "TO",
        (pANTLR3_UINT8) "UNICODE_ESC",
        (pANTLR3_UINT8) "UNTIL",
        (pANTLR3_UINT8) "WAIT",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WIDTH",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'||'"
       };


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_topStack
 */
void
psitarParser_topPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(top)->free != NULL)
	{
        SCOPE_TOP(top)->free(SCOPE_TOP(top));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_topStack_limit--;
    SCOPE_TOP(top) = (psitarParser_top_SCOPE)(ctx->psitarParser_topStack->get(ctx->psitarParser_topStack, ctx->psitarParser_topStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_duStack
 */
void
psitarParser_duPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(du)->free != NULL)
	{
        SCOPE_TOP(du)->free(SCOPE_TOP(du));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_duStack_limit--;
    SCOPE_TOP(du) = (psitarParser_du_SCOPE)(ctx->psitarParser_duStack->get(ctx->psitarParser_duStack, ctx->psitarParser_duStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_port_declarationStack
 */
void
psitarParser_port_declarationPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(port_declaration)->free != NULL)
	{
        SCOPE_TOP(port_declaration)->free(SCOPE_TOP(port_declaration));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_port_declarationStack_limit--;
    SCOPE_TOP(port_declaration) = (psitarParser_port_declaration_SCOPE)(ctx->psitarParser_port_declarationStack->get(ctx->psitarParser_port_declarationStack, ctx->psitarParser_port_declarationStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_net_declarationStack
 */
void
psitarParser_net_declarationPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(net_declaration)->free != NULL)
	{
        SCOPE_TOP(net_declaration)->free(SCOPE_TOP(net_declaration));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_net_declarationStack_limit--;
    SCOPE_TOP(net_declaration) = (psitarParser_net_declaration_SCOPE)(ctx->psitarParser_net_declarationStack->get(ctx->psitarParser_net_declarationStack, ctx->psitarParser_net_declarationStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_cfStack
 */
void
psitarParser_cfPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(cf)->free != NULL)
	{
        SCOPE_TOP(cf)->free(SCOPE_TOP(cf));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_cfStack_limit--;
    SCOPE_TOP(cf) = (psitarParser_cf_SCOPE)(ctx->psitarParser_cfStack->get(ctx->psitarParser_cfStack, ctx->psitarParser_cfStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a psitarParser_statementStack
 */
void
psitarParser_statementPop(psitarParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(statement)->free != NULL)
	{
        SCOPE_TOP(statement)->free(SCOPE_TOP(statement));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->psitarParser_statementStack_limit--;
    SCOPE_TOP(statement) = (psitarParser_statement_SCOPE)(ctx->psitarParser_statementStack->get(ctx->psitarParser_statementStack, ctx->psitarParser_statementStack_limit - 1));
}



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	top    (psitarParser ctx);
static 
 void
	design_unit    (psitarParser ctx);
static 
 void
	du    (psitarParser ctx);
static 
 void
	module_definition    (psitarParser ctx);
static 
 void
	procedure_definition    (psitarParser ctx);
static 
 void
	module_body    (psitarParser ctx);
static 
 void
	procedure_body    (psitarParser ctx);
static 
 void
	code_block_regions    (psitarParser ctx);
static 
 void
	include_block    (psitarParser ctx);
static 
 void
	declaration_block    (psitarParser ctx);
static 
 void
	initialization_block    (psitarParser ctx);
static 
 void
	structural_component_declaration    (psitarParser ctx);
static 
 void
	parameter_declaration_region    (psitarParser ctx);
static 
 void
	parameter_declaration    (psitarParser ctx);
static 
 sitarParser_param_type_return
	param_type    (psitarParser ctx);
static 
 sitarParser_default_value_return
	default_value    (psitarParser ctx);
static 
 void
	integer    (psitarParser ctx);
static 
 void
	port_declaration    (psitarParser ctx);
static 
 void
	inport_declaration    (psitarParser ctx);
static 
 void
	inport_array_declaration    (psitarParser ctx);
static 
 void
	outport_declaration    (psitarParser ctx);
static 
 void
	outport_array_declaration    (psitarParser ctx);
static 
 void
	net_declaration    (psitarParser ctx);
static 
 void
	simple_net_declaration    (psitarParser ctx);
static 
 void
	net_array_declaration    (psitarParser ctx);
static 
 void
	submodule_declaration    (psitarParser ctx);
static 
 void
	simple_submodule_declaration    (psitarParser ctx);
static 
 sitarParser_template_arguments_return
	template_arguments    (psitarParser ctx);
static 
 void
	argument    (psitarParser ctx);
static 
 void
	submodule_array_declaration    (psitarParser ctx);
static 
 void
	procedure_declaration    (psitarParser ctx);
static 
 void
	connection    (psitarParser ctx);
static 
 void
	simple_connect_statement    (psitarParser ctx);
static 
 sitarParser_port_instance_name_return
	port_instance_name    (psitarParser ctx);
static 
 sitarParser_net_instance_name_return
	net_instance_name    (psitarParser ctx);
static 
 void
	hierarchical_instance_name    (psitarParser ctx);
static 
 void
	object_name    (psitarParser ctx);
static 
 void
	for_loop_for_connections    (psitarParser ctx);
static 
 sitarParser_expression_return
	expression    (psitarParser ctx);
static 
 void
	term    (psitarParser ctx);
static 
 void
	signed_expression    (psitarParser ctx);
static 
 void
	atomic_expression    (psitarParser ctx);
static 
 void
	behavior_block    (psitarParser ctx);
static 
 void
	cf    (psitarParser ctx);
static 
 int
	sequence    (psitarParser ctx, int p);
static 
 int
	statement    (psitarParser ctx, int p_, int k_);
static 
 void
	atomic_statement    (psitarParser ctx);
static 
 void
	code_block_statement    (psitarParser ctx);
static 
 void
	behavior_code_block_statement    (psitarParser ctx);
static 
 void
	declaration_block_statement    (psitarParser ctx);
static 
 void
	initialization_block_statement    (psitarParser ctx);
static 
 void
	includes_block_statement    (psitarParser ctx);
static 
 void
	nothing_statement    (psitarParser ctx);
static 
 void
	wait_statement    (psitarParser ctx);
static 
 void
	wait_until    (psitarParser ctx);
static 
 void
	wait_for_time    (psitarParser ctx);
static 
 void
	single_wait    (psitarParser ctx);
static 
 void
	stop_statement    (psitarParser ctx);
static 
 void
	stop_behavior    (psitarParser ctx);
static 
 void
	stop_simulation    (psitarParser ctx);
static 
 void
	run_procedure_statement    (psitarParser ctx);
static 
 void
	compound_statement    (psitarParser ctx);
static 
 void
	if_statement    (psitarParser ctx);
static 
 void
	do_while_statement    (psitarParser ctx);
static 
 void
	parallel_statement    (psitarParser ctx);
static 
 std::string
	expression_cf    (psitarParser ctx);
static 
 std::string
	exp1    (psitarParser ctx);
static 
 std::string
	exp2    (psitarParser ctx);
static 
 std::string
	exp3    (psitarParser ctx);
static 
 std::string
	exp4    (psitarParser ctx);
static 
 std::string
	exp5    (psitarParser ctx);
static 
 std::string
	exp6    (psitarParser ctx);
static 
 sitarParser_comparison_operator_return
	comparison_operator    (psitarParser ctx);
static 
 sitarParser_add_operator_return
	add_operator    (psitarParser ctx);
static 
 sitarParser_mul_operator_return
	mul_operator    (psitarParser ctx);
static 
 std::string
	atomic_expression_cf    (psitarParser ctx);
static 
 sitarParser_expression_code_block_return
	expression_code_block    (psitarParser ctx);
static 
 sitarParser_function_call_return
	function_call    (psitarParser ctx);
static 
 std::string
	argument_list    (psitarParser ctx);
static 
 std::string
	this_cycle    (psitarParser ctx);
static 
 std::string
	this_phase    (psitarParser ctx);
static 
 sitarParser_code_block_with_info_return
	code_block_with_info    (psitarParser ctx);
static 
 sitarParser_code_block_return
	code_block    (psitarParser ctx);
static 
 sitarParser_identifier_return
	identifier    (psitarParser ctx);
static void	sitarParserFree(psitarParser ctx);
static void     sitarParserReset (psitarParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/nehak/Projects/sitar/translator/grammar/sitar.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new sitarParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API psitarParser
sitarParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return sitarParserNewSSD(instream, NULL);
}

/** \brief Create a new sitarParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API psitarParser
sitarParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    psitarParser ctx;	    /* Context structure we will build and return   */

    ctx	= (psitarParser) ANTLR3_CALLOC(1, sizeof(sitarParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in sitarParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our sitarParser interface
     */
    ctx->top	= top;
    ctx->design_unit	= design_unit;
    ctx->du	= du;
    ctx->module_definition	= module_definition;
    ctx->procedure_definition	= procedure_definition;
    ctx->module_body	= module_body;
    ctx->procedure_body	= procedure_body;
    ctx->code_block_regions	= code_block_regions;
    ctx->include_block	= include_block;
    ctx->declaration_block	= declaration_block;
    ctx->initialization_block	= initialization_block;
    ctx->structural_component_declaration	= structural_component_declaration;
    ctx->parameter_declaration_region	= parameter_declaration_region;
    ctx->parameter_declaration	= parameter_declaration;
    ctx->param_type	= param_type;
    ctx->default_value	= default_value;
    ctx->integer	= integer;
    ctx->port_declaration	= port_declaration;
    ctx->inport_declaration	= inport_declaration;
    ctx->inport_array_declaration	= inport_array_declaration;
    ctx->outport_declaration	= outport_declaration;
    ctx->outport_array_declaration	= outport_array_declaration;
    ctx->net_declaration	= net_declaration;
    ctx->simple_net_declaration	= simple_net_declaration;
    ctx->net_array_declaration	= net_array_declaration;
    ctx->submodule_declaration	= submodule_declaration;
    ctx->simple_submodule_declaration	= simple_submodule_declaration;
    ctx->template_arguments	= template_arguments;
    ctx->argument	= argument;
    ctx->submodule_array_declaration	= submodule_array_declaration;
    ctx->procedure_declaration	= procedure_declaration;
    ctx->connection	= connection;
    ctx->simple_connect_statement	= simple_connect_statement;
    ctx->port_instance_name	= port_instance_name;
    ctx->net_instance_name	= net_instance_name;
    ctx->hierarchical_instance_name	= hierarchical_instance_name;
    ctx->object_name	= object_name;
    ctx->for_loop_for_connections	= for_loop_for_connections;
    ctx->expression	= expression;
    ctx->term	= term;
    ctx->signed_expression	= signed_expression;
    ctx->atomic_expression	= atomic_expression;
    ctx->behavior_block	= behavior_block;
    ctx->cf	= cf;
    ctx->sequence	= sequence;
    ctx->statement	= statement;
    ctx->atomic_statement	= atomic_statement;
    ctx->code_block_statement	= code_block_statement;
    ctx->behavior_code_block_statement	= behavior_code_block_statement;
    ctx->declaration_block_statement	= declaration_block_statement;
    ctx->initialization_block_statement	= initialization_block_statement;
    ctx->includes_block_statement	= includes_block_statement;
    ctx->nothing_statement	= nothing_statement;
    ctx->wait_statement	= wait_statement;
    ctx->wait_until	= wait_until;
    ctx->wait_for_time	= wait_for_time;
    ctx->single_wait	= single_wait;
    ctx->stop_statement	= stop_statement;
    ctx->stop_behavior	= stop_behavior;
    ctx->stop_simulation	= stop_simulation;
    ctx->run_procedure_statement	= run_procedure_statement;
    ctx->compound_statement	= compound_statement;
    ctx->if_statement	= if_statement;
    ctx->do_while_statement	= do_while_statement;
    ctx->parallel_statement	= parallel_statement;
    ctx->expression_cf	= expression_cf;
    ctx->exp1	= exp1;
    ctx->exp2	= exp2;
    ctx->exp3	= exp3;
    ctx->exp4	= exp4;
    ctx->exp5	= exp5;
    ctx->exp6	= exp6;
    ctx->comparison_operator	= comparison_operator;
    ctx->add_operator	= add_operator;
    ctx->mul_operator	= mul_operator;
    ctx->atomic_expression_cf	= atomic_expression_cf;
    ctx->expression_code_block	= expression_code_block;
    ctx->function_call	= function_call;
    ctx->argument_list	= argument_list;
    ctx->this_cycle	= this_cycle;
    ctx->this_phase	= this_phase;
    ctx->code_block_with_info	= code_block_with_info;
    ctx->code_block	= code_block;
    ctx->identifier	= identifier;
    ctx->free			= sitarParserFree;
    ctx->reset			= sitarParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_topPush     = psitarParser_topPush;
    ctx->psitarParser_topStack    = antlr3StackNew(0);
    ctx->psitarParser_topStack_limit    = 0;
    ctx->psitarParser_topTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_duPush     = psitarParser_duPush;
    ctx->psitarParser_duStack    = antlr3StackNew(0);
    ctx->psitarParser_duStack_limit    = 0;
    ctx->psitarParser_duTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_port_declarationPush     = psitarParser_port_declarationPush;
    ctx->psitarParser_port_declarationStack    = antlr3StackNew(0);
    ctx->psitarParser_port_declarationStack_limit    = 0;
    ctx->psitarParser_port_declarationTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_net_declarationPush     = psitarParser_net_declarationPush;
    ctx->psitarParser_net_declarationStack    = antlr3StackNew(0);
    ctx->psitarParser_net_declarationStack_limit    = 0;
    ctx->psitarParser_net_declarationTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_cfPush     = psitarParser_cfPush;
    ctx->psitarParser_cfStack    = antlr3StackNew(0);
    ctx->psitarParser_cfStack_limit    = 0;
    ctx->psitarParser_cfTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_statementPush     = psitarParser_statementPush;
    ctx->psitarParser_statementStack    = antlr3StackNew(0);
    ctx->psitarParser_statementStack_limit    = 0;
    ctx->psitarParser_statementTop      = NULL;





    	ctx->_globalData= NULL;
    	ctx->_codeGen= NULL;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = sitarParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
sitarParserReset (psitarParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 sitarParserFree(psitarParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_topStack->free(ctx->psitarParser_topStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_duStack->free(ctx->psitarParser_duStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_port_declarationStack->free(ctx->psitarParser_port_declarationStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_net_declarationStack->free(ctx->psitarParser_net_declarationStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_cfStack->free(ctx->psitarParser_cfStack);


    /* ruleAttributeScope(scope)
     */
    ctx->psitarParser_statementStack->free(ctx->psitarParser_statementStack);



	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return sitarParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_design_unit_in_top578  */
static	ANTLR3_BITWORD FOLLOW_design_unit_in_top578_bits[]	= { ANTLR3_UINT64_LIT(0x0008008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_design_unit_in_top578	= { FOLLOW_design_unit_in_top578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_top599  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_top599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_top599	= { FOLLOW_EOF_in_top599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_du_in_design_unit619  */
static	ANTLR3_BITWORD FOLLOW_du_in_design_unit619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_du_in_design_unit619	= { FOLLOW_du_in_design_unit619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_module_definition_in_du657  */
static	ANTLR3_BITWORD FOLLOW_module_definition_in_du657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_module_definition_in_du657	= { FOLLOW_module_definition_in_du657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_definition_in_du673  */
static	ANTLR3_BITWORD FOLLOW_procedure_definition_in_du673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_definition_in_du673	= { FOLLOW_procedure_definition_in_du673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MODULE_in_module_definition705  */
static	ANTLR3_BITWORD FOLLOW_MODULE_in_module_definition705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MODULE_in_module_definition705	= { FOLLOW_MODULE_in_module_definition705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_module_definition710  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_module_definition710_bits[]	= { ANTLR3_UINT64_LIT(0x0C09C301E5110040) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_module_definition710	= { FOLLOW_IDENTIFIER_in_module_definition710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_module_body_in_module_definition721  */
static	ANTLR3_BITWORD FOLLOW_module_body_in_module_definition721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_module_body_in_module_definition721	= { FOLLOW_module_body_in_module_definition721_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_module_definition725  */
static	ANTLR3_BITWORD FOLLOW_END_in_module_definition725_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_module_definition725	= { FOLLOW_END_in_module_definition725_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MODULE_in_module_definition727  */
static	ANTLR3_BITWORD FOLLOW_MODULE_in_module_definition727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MODULE_in_module_definition727	= { FOLLOW_MODULE_in_module_definition727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROCEDURE_in_procedure_definition758  */
static	ANTLR3_BITWORD FOLLOW_PROCEDURE_in_procedure_definition758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PROCEDURE_in_procedure_definition758	= { FOLLOW_PROCEDURE_in_procedure_definition758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_definition763  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_definition763_bits[]	= { ANTLR3_UINT64_LIT(0x0009000060010040) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_definition763	= { FOLLOW_IDENTIFIER_in_procedure_definition763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_body_in_procedure_definition775  */
static	ANTLR3_BITWORD FOLLOW_procedure_body_in_procedure_definition775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_body_in_procedure_definition775	= { FOLLOW_procedure_body_in_procedure_definition775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_procedure_definition779  */
static	ANTLR3_BITWORD FOLLOW_END_in_procedure_definition779_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_procedure_definition779	= { FOLLOW_END_in_procedure_definition779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROCEDURE_in_procedure_definition781  */
static	ANTLR3_BITWORD FOLLOW_PROCEDURE_in_procedure_definition781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PROCEDURE_in_procedure_definition781	= { FOLLOW_PROCEDURE_in_procedure_definition781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_region_in_module_body833  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_region_in_module_body833_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_region_in_module_body833	= { FOLLOW_parameter_declaration_region_in_module_body833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_module_body868  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_module_body868_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_module_body868	= { FOLLOW_code_block_regions_in_module_body868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structural_component_declaration_in_module_body872  */
static	ANTLR3_BITWORD FOLLOW_structural_component_declaration_in_module_body872_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_structural_component_declaration_in_module_body872	= { FOLLOW_structural_component_declaration_in_module_body872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_declaration_in_module_body875  */
static	ANTLR3_BITWORD FOLLOW_procedure_declaration_in_module_body875_bits[]	= { ANTLR3_UINT64_LIT(0x0C08C301E5010042) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_declaration_in_module_body875	= { FOLLOW_procedure_declaration_in_module_body875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_behavior_block_in_module_body886  */
static	ANTLR3_BITWORD FOLLOW_behavior_block_in_module_body886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_behavior_block_in_module_body886	= { FOLLOW_behavior_block_in_module_body886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_module_body890  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_module_body890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_module_body890	= { FOLLOW_code_block_regions_in_module_body890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_region_in_procedure_body934  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_region_in_procedure_body934_bits[]	= { ANTLR3_UINT64_LIT(0x0008000060010040) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_region_in_procedure_body934	= { FOLLOW_parameter_declaration_region_in_procedure_body934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_procedure_body953  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_procedure_body953_bits[]	= { ANTLR3_UINT64_LIT(0x0008000060010040) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_procedure_body953	= { FOLLOW_code_block_regions_in_procedure_body953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_declaration_in_procedure_body957  */
static	ANTLR3_BITWORD FOLLOW_procedure_declaration_in_procedure_body957_bits[]	= { ANTLR3_UINT64_LIT(0x0008000060010040) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_declaration_in_procedure_body957	= { FOLLOW_procedure_declaration_in_procedure_body957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_behavior_block_in_procedure_body987  */
static	ANTLR3_BITWORD FOLLOW_behavior_block_in_procedure_body987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_behavior_block_in_procedure_body987	= { FOLLOW_behavior_block_in_procedure_body987_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_regions_in_procedure_body995  */
static	ANTLR3_BITWORD FOLLOW_code_block_regions_in_procedure_body995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060010002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_regions_in_procedure_body995	= { FOLLOW_code_block_regions_in_procedure_body995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_include_block_in_code_block_regions1015  */
static	ANTLR3_BITWORD FOLLOW_include_block_in_code_block_regions1015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_include_block_in_code_block_regions1015	= { FOLLOW_include_block_in_code_block_regions1015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_block_in_code_block_regions1020  */
static	ANTLR3_BITWORD FOLLOW_declaration_block_in_code_block_regions1020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_block_in_code_block_regions1020	= { FOLLOW_declaration_block_in_code_block_regions1020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initialization_block_in_code_block_regions1025  */
static	ANTLR3_BITWORD FOLLOW_initialization_block_in_code_block_regions1025_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_initialization_block_in_code_block_regions1025	= { FOLLOW_initialization_block_in_code_block_regions1025_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_in_include_block1035  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_in_include_block1035_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_in_include_block1035	= { FOLLOW_INCLUDE_in_include_block1035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_include_block1039  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_include_block1039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_include_block1039	= { FOLLOW_code_block_with_info_in_include_block1039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECL_in_declaration_block1052  */
static	ANTLR3_BITWORD FOLLOW_DECL_in_declaration_block1052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECL_in_declaration_block1052	= { FOLLOW_DECL_in_declaration_block1052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_declaration_block1056  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_declaration_block1056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_declaration_block1056	= { FOLLOW_code_block_with_info_in_declaration_block1056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INIT_in_initialization_block1069  */
static	ANTLR3_BITWORD FOLLOW_INIT_in_initialization_block1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INIT_in_initialization_block1069	= { FOLLOW_INIT_in_initialization_block1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_initialization_block1073  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_initialization_block1073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_initialization_block1073	= { FOLLOW_code_block_with_info_in_initialization_block1073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_declaration_in_structural_component_declaration1101  */
static	ANTLR3_BITWORD FOLLOW_port_declaration_in_structural_component_declaration1101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_port_declaration_in_structural_component_declaration1101	= { FOLLOW_port_declaration_in_structural_component_declaration1101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_net_declaration_in_structural_component_declaration1107  */
static	ANTLR3_BITWORD FOLLOW_net_declaration_in_structural_component_declaration1107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_net_declaration_in_structural_component_declaration1107	= { FOLLOW_net_declaration_in_structural_component_declaration1107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_submodule_declaration_in_structural_component_declaration1113  */
static	ANTLR3_BITWORD FOLLOW_submodule_declaration_in_structural_component_declaration1113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_submodule_declaration_in_structural_component_declaration1113	= { FOLLOW_submodule_declaration_in_structural_component_declaration1113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connection_in_structural_component_declaration1119  */
static	ANTLR3_BITWORD FOLLOW_connection_in_structural_component_declaration1119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_connection_in_structural_component_declaration1119	= { FOLLOW_connection_in_structural_component_declaration1119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_in_parameter_declaration_region1147  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_in_parameter_declaration_region1147_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_in_parameter_declaration_region1147	= { FOLLOW_parameter_declaration_in_parameter_declaration_region1147_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_parameter_declaration_region1149  */
static	ANTLR3_BITWORD FOLLOW_77_in_parameter_declaration_region1149_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_parameter_declaration_region1149	= { FOLLOW_77_in_parameter_declaration_region1149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAMETER_in_parameter_declaration1169  */
static	ANTLR3_BITWORD FOLLOW_PARAMETER_in_parameter_declaration1169_bits[]	= { ANTLR3_UINT64_LIT(0x0000001C00000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAMETER_in_parameter_declaration1169	= { FOLLOW_PARAMETER_in_parameter_declaration1169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_type_in_parameter_declaration1173  */
static	ANTLR3_BITWORD FOLLOW_param_type_in_parameter_declaration1173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_type_in_parameter_declaration1173	= { FOLLOW_param_type_in_parameter_declaration1173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_parameter_declaration1177  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_parameter_declaration1177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_parameter_declaration1177	= { FOLLOW_IDENTIFIER_in_parameter_declaration1177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_parameter_declaration1180  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_parameter_declaration1180_bits[]	= { ANTLR3_UINT64_LIT(0x0000004200000280) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_parameter_declaration1180	= { FOLLOW_EQUALS_in_parameter_declaration1180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_default_value_in_parameter_declaration1184  */
static	ANTLR3_BITWORD FOLLOW_default_value_in_parameter_declaration1184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_default_value_in_parameter_declaration1184	= { FOLLOW_default_value_in_parameter_declaration1184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_default_value1228  */
static	ANTLR3_BITWORD FOLLOW_integer_in_default_value1228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_default_value1228	= { FOLLOW_integer_in_default_value1228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_in_default_value1232  */
static	ANTLR3_BITWORD FOLLOW_BOOL_in_default_value1232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOL_in_default_value1232	= { FOLLOW_BOOL_in_default_value1232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHAR_in_default_value1236  */
static	ANTLR3_BITWORD FOLLOW_CHAR_in_default_value1236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHAR_in_default_value1236	= { FOLLOW_CHAR_in_default_value1236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_integer1248  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_integer1248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_integer1248	= { FOLLOW_MINUS_in_integer1248_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_integer1251  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_integer1251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_integer1251	= { FOLLOW_INTEGER_in_integer1251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inport_declaration_in_port_declaration1279  */
static	ANTLR3_BITWORD FOLLOW_inport_declaration_in_port_declaration1279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_inport_declaration_in_port_declaration1279	= { FOLLOW_inport_declaration_in_port_declaration1279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inport_array_declaration_in_port_declaration1284  */
static	ANTLR3_BITWORD FOLLOW_inport_array_declaration_in_port_declaration1284_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_inport_array_declaration_in_port_declaration1284	= { FOLLOW_inport_array_declaration_in_port_declaration1284_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_outport_declaration_in_port_declaration1289  */
static	ANTLR3_BITWORD FOLLOW_outport_declaration_in_port_declaration1289_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_outport_declaration_in_port_declaration1289	= { FOLLOW_outport_declaration_in_port_declaration1289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_outport_array_declaration_in_port_declaration1294  */
static	ANTLR3_BITWORD FOLLOW_outport_array_declaration_in_port_declaration1294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_outport_array_declaration_in_port_declaration1294	= { FOLLOW_outport_array_declaration_in_port_declaration1294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INPORT_in_inport_declaration1319  */
static	ANTLR3_BITWORD FOLLOW_INPORT_in_inport_declaration1319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INPORT_in_inport_declaration1319	= { FOLLOW_INPORT_in_inport_declaration1319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_inport_declaration1323  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_inport_declaration1323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_inport_declaration1323	= { FOLLOW_IDENTIFIER_in_inport_declaration1323_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_inport_declaration1335  */
static	ANTLR3_BITWORD FOLLOW_75_in_inport_declaration1335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_inport_declaration1335	= { FOLLOW_75_in_inport_declaration1335_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_inport_declaration1339  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_inport_declaration1339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_inport_declaration1339	= { FOLLOW_IDENTIFIER_in_inport_declaration1339_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_inport_declaration1353  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_inport_declaration1353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_inport_declaration1353	= { FOLLOW_COLON_in_inport_declaration1353_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_inport_declaration1355  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_inport_declaration1355_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_inport_declaration1355	= { FOLLOW_WIDTH_in_inport_declaration1355_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_declaration1359  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_declaration1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_declaration1359	= { FOLLOW_expression_in_inport_declaration1359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INPORT_ARRAY_in_inport_array_declaration1395  */
static	ANTLR3_BITWORD FOLLOW_INPORT_ARRAY_in_inport_array_declaration1395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INPORT_ARRAY_in_inport_array_declaration1395	= { FOLLOW_INPORT_ARRAY_in_inport_array_declaration1395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_inport_array_declaration1399  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_inport_array_declaration1399_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_inport_array_declaration1399	= { FOLLOW_IDENTIFIER_in_inport_array_declaration1399_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_inport_array_declaration1401  */
static	ANTLR3_BITWORD FOLLOW_82_in_inport_array_declaration1401_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_inport_array_declaration1401	= { FOLLOW_82_in_inport_array_declaration1401_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_array_declaration1405  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_array_declaration1405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_array_declaration1405	= { FOLLOW_expression_in_inport_array_declaration1405_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_inport_array_declaration1408  */
static	ANTLR3_BITWORD FOLLOW_83_in_inport_array_declaration1408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_inport_array_declaration1408	= { FOLLOW_83_in_inport_array_declaration1408_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_inport_array_declaration1421  */
static	ANTLR3_BITWORD FOLLOW_82_in_inport_array_declaration1421_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_inport_array_declaration1421	= { FOLLOW_82_in_inport_array_declaration1421_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_array_declaration1425  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_array_declaration1425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_array_declaration1425	= { FOLLOW_expression_in_inport_array_declaration1425_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_inport_array_declaration1429  */
static	ANTLR3_BITWORD FOLLOW_83_in_inport_array_declaration1429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_inport_array_declaration1429	= { FOLLOW_83_in_inport_array_declaration1429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_inport_array_declaration1435  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_inport_array_declaration1435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_inport_array_declaration1435	= { FOLLOW_COLON_in_inport_array_declaration1435_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_inport_array_declaration1437  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_inport_array_declaration1437_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_inport_array_declaration1437	= { FOLLOW_WIDTH_in_inport_array_declaration1437_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_inport_array_declaration1441  */
static	ANTLR3_BITWORD FOLLOW_expression_in_inport_array_declaration1441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_inport_array_declaration1441	= { FOLLOW_expression_in_inport_array_declaration1441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OUTPORT_in_outport_declaration1473  */
static	ANTLR3_BITWORD FOLLOW_OUTPORT_in_outport_declaration1473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OUTPORT_in_outport_declaration1473	= { FOLLOW_OUTPORT_in_outport_declaration1473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_outport_declaration1477  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_outport_declaration1477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_outport_declaration1477	= { FOLLOW_IDENTIFIER_in_outport_declaration1477_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_outport_declaration1489  */
static	ANTLR3_BITWORD FOLLOW_75_in_outport_declaration1489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_outport_declaration1489	= { FOLLOW_75_in_outport_declaration1489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_outport_declaration1493  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_outport_declaration1493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_outport_declaration1493	= { FOLLOW_IDENTIFIER_in_outport_declaration1493_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_outport_declaration1507  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_outport_declaration1507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_outport_declaration1507	= { FOLLOW_COLON_in_outport_declaration1507_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_outport_declaration1509  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_outport_declaration1509_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_outport_declaration1509	= { FOLLOW_WIDTH_in_outport_declaration1509_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_declaration1513  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_declaration1513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_declaration1513	= { FOLLOW_expression_in_outport_declaration1513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1547  */
static	ANTLR3_BITWORD FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1547	= { FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_outport_array_declaration1551  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_outport_array_declaration1551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_outport_array_declaration1551	= { FOLLOW_IDENTIFIER_in_outport_array_declaration1551_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_outport_array_declaration1553  */
static	ANTLR3_BITWORD FOLLOW_82_in_outport_array_declaration1553_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_outport_array_declaration1553	= { FOLLOW_82_in_outport_array_declaration1553_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_array_declaration1557  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_array_declaration1557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_array_declaration1557	= { FOLLOW_expression_in_outport_array_declaration1557_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_outport_array_declaration1560  */
static	ANTLR3_BITWORD FOLLOW_83_in_outport_array_declaration1560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_outport_array_declaration1560	= { FOLLOW_83_in_outport_array_declaration1560_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_outport_array_declaration1573  */
static	ANTLR3_BITWORD FOLLOW_82_in_outport_array_declaration1573_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_outport_array_declaration1573	= { FOLLOW_82_in_outport_array_declaration1573_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_array_declaration1577  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_array_declaration1577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_array_declaration1577	= { FOLLOW_expression_in_outport_array_declaration1577_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_outport_array_declaration1581  */
static	ANTLR3_BITWORD FOLLOW_83_in_outport_array_declaration1581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_outport_array_declaration1581	= { FOLLOW_83_in_outport_array_declaration1581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_outport_array_declaration1588  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_outport_array_declaration1588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_outport_array_declaration1588	= { FOLLOW_COLON_in_outport_array_declaration1588_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_outport_array_declaration1590  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_outport_array_declaration1590_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_outport_array_declaration1590	= { FOLLOW_WIDTH_in_outport_array_declaration1590_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_outport_array_declaration1594  */
static	ANTLR3_BITWORD FOLLOW_expression_in_outport_array_declaration1594_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_outport_array_declaration1594	= { FOLLOW_expression_in_outport_array_declaration1594_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_net_declaration_in_net_declaration1633  */
static	ANTLR3_BITWORD FOLLOW_simple_net_declaration_in_net_declaration1633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_net_declaration_in_net_declaration1633	= { FOLLOW_simple_net_declaration_in_net_declaration1633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_net_array_declaration_in_net_declaration1638  */
static	ANTLR3_BITWORD FOLLOW_net_array_declaration_in_net_declaration1638_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_net_array_declaration_in_net_declaration1638	= { FOLLOW_net_array_declaration_in_net_declaration1638_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NET_in_simple_net_declaration1663  */
static	ANTLR3_BITWORD FOLLOW_NET_in_simple_net_declaration1663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NET_in_simple_net_declaration1663	= { FOLLOW_NET_in_simple_net_declaration1663_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_net_declaration1668  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_net_declaration1668_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_net_declaration1668	= { FOLLOW_IDENTIFIER_in_simple_net_declaration1668_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_simple_net_declaration1680  */
static	ANTLR3_BITWORD FOLLOW_75_in_simple_net_declaration1680_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_simple_net_declaration1680	= { FOLLOW_75_in_simple_net_declaration1680_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_net_declaration1684  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_net_declaration1684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_net_declaration1684	= { FOLLOW_IDENTIFIER_in_simple_net_declaration1684_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_simple_net_declaration1702  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_simple_net_declaration1702_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_simple_net_declaration1702	= { FOLLOW_COLON_in_simple_net_declaration1702_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CAPACITY_in_simple_net_declaration1704  */
static	ANTLR3_BITWORD FOLLOW_CAPACITY_in_simple_net_declaration1704_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_CAPACITY_in_simple_net_declaration1704	= { FOLLOW_CAPACITY_in_simple_net_declaration1704_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_simple_net_declaration1709  */
static	ANTLR3_BITWORD FOLLOW_expression_in_simple_net_declaration1709_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_simple_net_declaration1709	= { FOLLOW_expression_in_simple_net_declaration1709_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_simple_net_declaration1716  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_simple_net_declaration1716_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_simple_net_declaration1716	= { FOLLOW_WIDTH_in_simple_net_declaration1716_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_simple_net_declaration1720  */
static	ANTLR3_BITWORD FOLLOW_expression_in_simple_net_declaration1720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_simple_net_declaration1720	= { FOLLOW_expression_in_simple_net_declaration1720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NET_ARRAY_in_net_array_declaration1753  */
static	ANTLR3_BITWORD FOLLOW_NET_ARRAY_in_net_array_declaration1753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NET_ARRAY_in_net_array_declaration1753	= { FOLLOW_NET_ARRAY_in_net_array_declaration1753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_net_array_declaration1757  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_net_array_declaration1757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_net_array_declaration1757	= { FOLLOW_IDENTIFIER_in_net_array_declaration1757_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_net_array_declaration1759  */
static	ANTLR3_BITWORD FOLLOW_82_in_net_array_declaration1759_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_net_array_declaration1759	= { FOLLOW_82_in_net_array_declaration1759_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1763  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1763	= { FOLLOW_expression_in_net_array_declaration1763_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_net_array_declaration1766  */
static	ANTLR3_BITWORD FOLLOW_83_in_net_array_declaration1766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_net_array_declaration1766	= { FOLLOW_83_in_net_array_declaration1766_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_net_array_declaration1779  */
static	ANTLR3_BITWORD FOLLOW_82_in_net_array_declaration1779_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_net_array_declaration1779	= { FOLLOW_82_in_net_array_declaration1779_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1783  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1783	= { FOLLOW_expression_in_net_array_declaration1783_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_net_array_declaration1787  */
static	ANTLR3_BITWORD FOLLOW_83_in_net_array_declaration1787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_net_array_declaration1787	= { FOLLOW_83_in_net_array_declaration1787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_net_array_declaration1791  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_net_array_declaration1791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_net_array_declaration1791	= { FOLLOW_COLON_in_net_array_declaration1791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CAPACITY_in_net_array_declaration1793  */
static	ANTLR3_BITWORD FOLLOW_CAPACITY_in_net_array_declaration1793_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_CAPACITY_in_net_array_declaration1793	= { FOLLOW_CAPACITY_in_net_array_declaration1793_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1797  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1797	= { FOLLOW_expression_in_net_array_declaration1797_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WIDTH_in_net_array_declaration1809  */
static	ANTLR3_BITWORD FOLLOW_WIDTH_in_net_array_declaration1809_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WIDTH_in_net_array_declaration1809	= { FOLLOW_WIDTH_in_net_array_declaration1809_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_net_array_declaration1813  */
static	ANTLR3_BITWORD FOLLOW_expression_in_net_array_declaration1813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_net_array_declaration1813	= { FOLLOW_expression_in_net_array_declaration1813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_submodule_declaration_in_submodule_declaration1835  */
static	ANTLR3_BITWORD FOLLOW_simple_submodule_declaration_in_submodule_declaration1835_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_submodule_declaration_in_submodule_declaration1835	= { FOLLOW_simple_submodule_declaration_in_submodule_declaration1835_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_submodule_array_declaration_in_submodule_declaration1840  */
static	ANTLR3_BITWORD FOLLOW_submodule_array_declaration_in_submodule_declaration1840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_submodule_array_declaration_in_submodule_declaration1840	= { FOLLOW_submodule_array_declaration_in_submodule_declaration1840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SUBMODULE_in_simple_submodule_declaration1864  */
static	ANTLR3_BITWORD FOLLOW_SUBMODULE_in_simple_submodule_declaration1864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SUBMODULE_in_simple_submodule_declaration1864	= { FOLLOW_SUBMODULE_in_simple_submodule_declaration1864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_submodule_declaration1868  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_submodule_declaration1868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_submodule_declaration1868	= { FOLLOW_IDENTIFIER_in_simple_submodule_declaration1868_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_simple_submodule_declaration1880  */
static	ANTLR3_BITWORD FOLLOW_75_in_simple_submodule_declaration1880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_simple_submodule_declaration1880	= { FOLLOW_75_in_simple_submodule_declaration1880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_submodule_declaration1884  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_submodule_declaration1884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_submodule_declaration1884	= { FOLLOW_IDENTIFIER_in_simple_submodule_declaration1884_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_simple_submodule_declaration1902  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_simple_submodule_declaration1902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_simple_submodule_declaration1902	= { FOLLOW_COLON_in_simple_submodule_declaration1902_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simple_submodule_declaration1906  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simple_submodule_declaration1906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simple_submodule_declaration1906	= { FOLLOW_IDENTIFIER_in_simple_submodule_declaration1906_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_simple_submodule_declaration1909  */
static	ANTLR3_BITWORD FOLLOW_78_in_simple_submodule_declaration1909_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000010100) };
static  ANTLR3_BITSET_LIST FOLLOW_78_in_simple_submodule_declaration1909	= { FOLLOW_78_in_simple_submodule_declaration1909_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_template_arguments_in_simple_submodule_declaration1912  */
static	ANTLR3_BITWORD FOLLOW_template_arguments_in_simple_submodule_declaration1912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_template_arguments_in_simple_submodule_declaration1912	= { FOLLOW_template_arguments_in_simple_submodule_declaration1912_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_simple_submodule_declaration1917  */
static	ANTLR3_BITWORD FOLLOW_80_in_simple_submodule_declaration1917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_80_in_simple_submodule_declaration1917	= { FOLLOW_80_in_simple_submodule_declaration1917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_template_arguments1938  */
static	ANTLR3_BITWORD FOLLOW_argument_in_template_arguments1938_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_template_arguments1938	= { FOLLOW_argument_in_template_arguments1938_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_template_arguments1941  */
static	ANTLR3_BITWORD FOLLOW_75_in_template_arguments1941_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_template_arguments1941	= { FOLLOW_75_in_template_arguments1941_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_template_arguments1943  */
static	ANTLR3_BITWORD FOLLOW_argument_in_template_arguments1943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_template_arguments1943	= { FOLLOW_argument_in_template_arguments1943_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_in_argument1957  */
static	ANTLR3_BITWORD FOLLOW_BOOL_in_argument1957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOL_in_argument1957	= { FOLLOW_BOOL_in_argument1957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHAR_in_argument1961  */
static	ANTLR3_BITWORD FOLLOW_CHAR_in_argument1961_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHAR_in_argument1961	= { FOLLOW_CHAR_in_argument1961_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_argument1965  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_argument1965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_argument1965	= { FOLLOW_STRING_in_argument1965_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_argument1969  */
static	ANTLR3_BITWORD FOLLOW_expression_in_argument1969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_argument1969	= { FOLLOW_expression_in_argument1969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1997  */
static	ANTLR3_BITWORD FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1997_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1997	= { FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_submodule_array_declaration2001  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_submodule_array_declaration2001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_submodule_array_declaration2001	= { FOLLOW_IDENTIFIER_in_submodule_array_declaration2001_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_submodule_array_declaration2003  */
static	ANTLR3_BITWORD FOLLOW_82_in_submodule_array_declaration2003_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_submodule_array_declaration2003	= { FOLLOW_82_in_submodule_array_declaration2003_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_submodule_array_declaration2007  */
static	ANTLR3_BITWORD FOLLOW_expression_in_submodule_array_declaration2007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_submodule_array_declaration2007	= { FOLLOW_expression_in_submodule_array_declaration2007_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_submodule_array_declaration2010  */
static	ANTLR3_BITWORD FOLLOW_83_in_submodule_array_declaration2010_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_submodule_array_declaration2010	= { FOLLOW_83_in_submodule_array_declaration2010_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_submodule_array_declaration2023  */
static	ANTLR3_BITWORD FOLLOW_82_in_submodule_array_declaration2023_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_submodule_array_declaration2023	= { FOLLOW_82_in_submodule_array_declaration2023_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_submodule_array_declaration2027  */
static	ANTLR3_BITWORD FOLLOW_expression_in_submodule_array_declaration2027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_submodule_array_declaration2027	= { FOLLOW_expression_in_submodule_array_declaration2027_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_submodule_array_declaration2031  */
static	ANTLR3_BITWORD FOLLOW_83_in_submodule_array_declaration2031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_submodule_array_declaration2031	= { FOLLOW_83_in_submodule_array_declaration2031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_submodule_array_declaration2053  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_submodule_array_declaration2053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_submodule_array_declaration2053	= { FOLLOW_COLON_in_submodule_array_declaration2053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_submodule_array_declaration2057  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_submodule_array_declaration2057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_submodule_array_declaration2057	= { FOLLOW_IDENTIFIER_in_submodule_array_declaration2057_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_submodule_array_declaration2061  */
static	ANTLR3_BITWORD FOLLOW_78_in_submodule_array_declaration2061_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000010100) };
static  ANTLR3_BITSET_LIST FOLLOW_78_in_submodule_array_declaration2061	= { FOLLOW_78_in_submodule_array_declaration2061_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_template_arguments_in_submodule_array_declaration2066  */
static	ANTLR3_BITWORD FOLLOW_template_arguments_in_submodule_array_declaration2066_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_template_arguments_in_submodule_array_declaration2066	= { FOLLOW_template_arguments_in_submodule_array_declaration2066_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_submodule_array_declaration2072  */
static	ANTLR3_BITWORD FOLLOW_80_in_submodule_array_declaration2072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_80_in_submodule_array_declaration2072	= { FOLLOW_80_in_submodule_array_declaration2072_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROCEDURE_in_procedure_declaration2105  */
static	ANTLR3_BITWORD FOLLOW_PROCEDURE_in_procedure_declaration2105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PROCEDURE_in_procedure_declaration2105	= { FOLLOW_PROCEDURE_in_procedure_declaration2105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_declaration2112  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_declaration2112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_declaration2112	= { FOLLOW_IDENTIFIER_in_procedure_declaration2112_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_procedure_declaration2124  */
static	ANTLR3_BITWORD FOLLOW_75_in_procedure_declaration2124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_procedure_declaration2124	= { FOLLOW_75_in_procedure_declaration2124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_declaration2128  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_declaration2128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_declaration2128	= { FOLLOW_IDENTIFIER_in_procedure_declaration2128_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_procedure_declaration2146  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_procedure_declaration2146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_procedure_declaration2146	= { FOLLOW_COLON_in_procedure_declaration2146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_procedure_declaration2150  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_procedure_declaration2150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_procedure_declaration2150	= { FOLLOW_IDENTIFIER_in_procedure_declaration2150_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_procedure_declaration2153  */
static	ANTLR3_BITWORD FOLLOW_78_in_procedure_declaration2153_bits[]	= { ANTLR3_UINT64_LIT(0x0200004204000280), ANTLR3_UINT64_LIT(0x0000000000010100) };
static  ANTLR3_BITSET_LIST FOLLOW_78_in_procedure_declaration2153	= { FOLLOW_78_in_procedure_declaration2153_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_template_arguments_in_procedure_declaration2156  */
static	ANTLR3_BITWORD FOLLOW_template_arguments_in_procedure_declaration2156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_template_arguments_in_procedure_declaration2156	= { FOLLOW_template_arguments_in_procedure_declaration2156_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_procedure_declaration2161  */
static	ANTLR3_BITWORD FOLLOW_80_in_procedure_declaration2161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_80_in_procedure_declaration2161	= { FOLLOW_80_in_procedure_declaration2161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_connect_statement_in_connection2189  */
static	ANTLR3_BITWORD FOLLOW_simple_connect_statement_in_connection2189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_connect_statement_in_connection2189	= { FOLLOW_simple_connect_statement_in_connection2189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_for_loop_for_connections_in_connection2195  */
static	ANTLR3_BITWORD FOLLOW_for_loop_for_connections_in_connection2195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_for_loop_for_connections_in_connection2195	= { FOLLOW_for_loop_for_connections_in_connection2195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_instance_name_in_simple_connect_statement2225  */
static	ANTLR3_BITWORD FOLLOW_port_instance_name_in_simple_connect_statement2225_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000C000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_port_instance_name_in_simple_connect_statement2225	= { FOLLOW_port_instance_name_in_simple_connect_statement2225_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_simple_connect_statement2239  */
static	ANTLR3_BITWORD FOLLOW_75_in_simple_connect_statement2239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_simple_connect_statement2239	= { FOLLOW_75_in_simple_connect_statement2239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_instance_name_in_simple_connect_statement2243  */
static	ANTLR3_BITWORD FOLLOW_port_instance_name_in_simple_connect_statement2243_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000C000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_port_instance_name_in_simple_connect_statement2243	= { FOLLOW_port_instance_name_in_simple_connect_statement2243_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_simple_connect_statement2260  */
static	ANTLR3_BITWORD FOLLOW_set_in_simple_connect_statement2260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_simple_connect_statement2260	= { FOLLOW_set_in_simple_connect_statement2260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_net_instance_name_in_simple_connect_statement2270  */
static	ANTLR3_BITWORD FOLLOW_net_instance_name_in_simple_connect_statement2270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_net_instance_name_in_simple_connect_statement2270	= { FOLLOW_net_instance_name_in_simple_connect_statement2270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hierarchical_instance_name_in_port_instance_name2292  */
static	ANTLR3_BITWORD FOLLOW_hierarchical_instance_name_in_port_instance_name2292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hierarchical_instance_name_in_port_instance_name2292	= { FOLLOW_hierarchical_instance_name_in_port_instance_name2292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hierarchical_instance_name_in_net_instance_name2307  */
static	ANTLR3_BITWORD FOLLOW_hierarchical_instance_name_in_net_instance_name2307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hierarchical_instance_name_in_net_instance_name2307	= { FOLLOW_hierarchical_instance_name_in_net_instance_name2307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_name_in_hierarchical_instance_name2320  */
static	ANTLR3_BITWORD FOLLOW_object_name_in_hierarchical_instance_name2320_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_name_in_hierarchical_instance_name2320	= { FOLLOW_object_name_in_hierarchical_instance_name2320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_hierarchical_instance_name2322  */
static	ANTLR3_BITWORD FOLLOW_set_in_hierarchical_instance_name2322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_hierarchical_instance_name2322	= { FOLLOW_set_in_hierarchical_instance_name2322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_name_in_hierarchical_instance_name2330  */
static	ANTLR3_BITWORD FOLLOW_object_name_in_hierarchical_instance_name2330_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_name_in_hierarchical_instance_name2330	= { FOLLOW_object_name_in_hierarchical_instance_name2330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_object_name2344  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_object_name2344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_object_name2344	= { FOLLOW_IDENTIFIER_in_object_name2344_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_object_name2347  */
static	ANTLR3_BITWORD FOLLOW_82_in_object_name2347_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_object_name2347	= { FOLLOW_82_in_object_name2347_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_object_name2348  */
static	ANTLR3_BITWORD FOLLOW_expression_in_object_name2348_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_object_name2348	= { FOLLOW_expression_in_object_name2348_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_object_name2350  */
static	ANTLR3_BITWORD FOLLOW_83_in_object_name2350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_object_name2350	= { FOLLOW_83_in_object_name2350_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_object_name2353  */
static	ANTLR3_BITWORD FOLLOW_82_in_object_name2353_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_object_name2353	= { FOLLOW_82_in_object_name2353_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_object_name2354  */
static	ANTLR3_BITWORD FOLLOW_expression_in_object_name2354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_object_name2354	= { FOLLOW_expression_in_object_name2354_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_object_name2356  */
static	ANTLR3_BITWORD FOLLOW_83_in_object_name2356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_object_name2356	= { FOLLOW_83_in_object_name2356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_for_loop_for_connections2388  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_for_loop_for_connections2388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_for_loop_for_connections2388	= { FOLLOW_FOR_in_for_loop_for_connections2388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_for_loop_for_connections2392  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_for_loop_for_connections2392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_for_loop_for_connections2392	= { FOLLOW_IDENTIFIER_in_for_loop_for_connections2392_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IN_in_for_loop_for_connections2394  */
static	ANTLR3_BITWORD FOLLOW_IN_in_for_loop_for_connections2394_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_IN_in_for_loop_for_connections2394	= { FOLLOW_IN_in_for_loop_for_connections2394_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_for_loop_for_connections2398  */
static	ANTLR3_BITWORD FOLLOW_expression_in_for_loop_for_connections2398_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_for_loop_for_connections2398	= { FOLLOW_expression_in_for_loop_for_connections2398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TO_in_for_loop_for_connections2400  */
static	ANTLR3_BITWORD FOLLOW_TO_in_for_loop_for_connections2400_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_TO_in_for_loop_for_connections2400	= { FOLLOW_TO_in_for_loop_for_connections2400_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_for_loop_for_connections2404  */
static	ANTLR3_BITWORD FOLLOW_expression_in_for_loop_for_connections2404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_for_loop_for_connections2404	= { FOLLOW_expression_in_for_loop_for_connections2404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connection_in_for_loop_for_connections2411  */
static	ANTLR3_BITWORD FOLLOW_connection_in_for_loop_for_connections2411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005100000) };
static  ANTLR3_BITSET_LIST FOLLOW_connection_in_for_loop_for_connections2411	= { FOLLOW_connection_in_for_loop_for_connections2411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_for_loop_for_connections2418  */
static	ANTLR3_BITWORD FOLLOW_END_in_for_loop_for_connections2418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_for_loop_for_connections2418	= { FOLLOW_END_in_for_loop_for_connections2418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_for_loop_for_connections2420  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_for_loop_for_connections2420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_for_loop_for_connections2420	= { FOLLOW_FOR_in_for_loop_for_connections2420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expression2463  */
static	ANTLR3_BITWORD FOLLOW_term_in_expression2463_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expression2463	= { FOLLOW_term_in_expression2463_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression2466  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression2466_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression2466	= { FOLLOW_set_in_expression2466_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expression2472  */
static	ANTLR3_BITWORD FOLLOW_term_in_expression2472_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expression2472	= { FOLLOW_term_in_expression2472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signed_expression_in_term2483  */
static	ANTLR3_BITWORD FOLLOW_signed_expression_in_term2483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_signed_expression_in_term2483	= { FOLLOW_signed_expression_in_term2483_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_term2486  */
static	ANTLR3_BITWORD FOLLOW_set_in_term2486_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_term2486	= { FOLLOW_set_in_term2486_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signed_expression_in_term2494  */
static	ANTLR3_BITWORD FOLLOW_signed_expression_in_term2494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_signed_expression_in_term2494	= { FOLLOW_signed_expression_in_term2494_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_signed_expression2506  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_signed_expression2506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_signed_expression2506	= { FOLLOW_MINUS_in_signed_expression2506_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomic_expression_in_signed_expression2509  */
static	ANTLR3_BITWORD FOLLOW_atomic_expression_in_signed_expression2509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomic_expression_in_signed_expression2509	= { FOLLOW_atomic_expression_in_signed_expression2509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_atomic_expression2526  */
static	ANTLR3_BITWORD FOLLOW_72_in_atomic_expression2526_bits[]	= { ANTLR3_UINT64_LIT(0x0000004204000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_atomic_expression2526	= { FOLLOW_72_in_atomic_expression2526_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_atomic_expression2527  */
static	ANTLR3_BITWORD FOLLOW_expression_in_atomic_expression2527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_atomic_expression2527	= { FOLLOW_expression_in_atomic_expression2527_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_atomic_expression2528  */
static	ANTLR3_BITWORD FOLLOW_73_in_atomic_expression2528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_atomic_expression2528	= { FOLLOW_73_in_atomic_expression2528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atomic_expression2533  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atomic_expression2533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atomic_expression2533	= { FOLLOW_INTEGER_in_atomic_expression2533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_atomic_expression2538  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_atomic_expression2538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_atomic_expression2538	= { FOLLOW_IDENTIFIER_in_atomic_expression2538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cf_in_behavior_block2564  */
static	ANTLR3_BITWORD FOLLOW_cf_in_behavior_block2564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cf_in_behavior_block2564	= { FOLLOW_cf_in_behavior_block2564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEHAVIOR_in_cf2593  */
static	ANTLR3_BITWORD FOLLOW_BEHAVIOR_in_cf2593_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_BEHAVIOR_in_cf2593	= { FOLLOW_BEHAVIOR_in_cf2593_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_cf2603  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_cf2603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_cf2603	= { FOLLOW_sequence_in_cf2603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_cf2607  */
static	ANTLR3_BITWORD FOLLOW_END_in_cf2607_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_cf2607	= { FOLLOW_END_in_cf2607_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEHAVIOR_in_cf2609  */
static	ANTLR3_BITWORD FOLLOW_BEHAVIOR_in_cf2609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BEHAVIOR_in_cf2609	= { FOLLOW_BEHAVIOR_in_cf2609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2690  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2690_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2690	= { FOLLOW_statement_in_sequence2690_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2697  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2697_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040004) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2697	= { FOLLOW_77_in_sequence2697_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2701  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2701	= { FOLLOW_statement_in_sequence2701_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2708  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2708	= { FOLLOW_77_in_sequence2708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_sequence2713  */
static	ANTLR3_BITWORD FOLLOW_72_in_sequence2713_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040004) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_sequence2713	= { FOLLOW_72_in_sequence2713_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2718  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002200) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2718	= { FOLLOW_statement_in_sequence2718_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2732  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2732_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040004) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2732	= { FOLLOW_77_in_sequence2732_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_sequence2736  */
static	ANTLR3_BITWORD FOLLOW_statement_in_sequence2736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002200) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_sequence2736	= { FOLLOW_statement_in_sequence2736_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_sequence2744  */
static	ANTLR3_BITWORD FOLLOW_77_in_sequence2744_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_sequence2744	= { FOLLOW_77_in_sequence2744_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_sequence2747  */
static	ANTLR3_BITWORD FOLLOW_73_in_sequence2747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_sequence2747	= { FOLLOW_73_in_sequence2747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomic_statement_in_statement2793  */
static	ANTLR3_BITWORD FOLLOW_atomic_statement_in_statement2793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomic_statement_in_statement2793	= { FOLLOW_atomic_statement_in_statement2793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_statement_in_statement2799  */
static	ANTLR3_BITWORD FOLLOW_compound_statement_in_statement2799_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_statement_in_statement2799	= { FOLLOW_compound_statement_in_statement2799_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nothing_statement_in_atomic_statement2814  */
static	ANTLR3_BITWORD FOLLOW_nothing_statement_in_atomic_statement2814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nothing_statement_in_atomic_statement2814	= { FOLLOW_nothing_statement_in_atomic_statement2814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wait_statement_in_atomic_statement2819  */
static	ANTLR3_BITWORD FOLLOW_wait_statement_in_atomic_statement2819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wait_statement_in_atomic_statement2819	= { FOLLOW_wait_statement_in_atomic_statement2819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stop_statement_in_atomic_statement2824  */
static	ANTLR3_BITWORD FOLLOW_stop_statement_in_atomic_statement2824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stop_statement_in_atomic_statement2824	= { FOLLOW_stop_statement_in_atomic_statement2824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_run_procedure_statement_in_atomic_statement2829  */
static	ANTLR3_BITWORD FOLLOW_run_procedure_statement_in_atomic_statement2829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_run_procedure_statement_in_atomic_statement2829	= { FOLLOW_run_procedure_statement_in_atomic_statement2829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_statement_in_atomic_statement2834  */
static	ANTLR3_BITWORD FOLLOW_code_block_statement_in_atomic_statement2834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_statement_in_atomic_statement2834	= { FOLLOW_code_block_statement_in_atomic_statement2834_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_behavior_code_block_statement_in_code_block_statement2860  */
static	ANTLR3_BITWORD FOLLOW_behavior_code_block_statement_in_code_block_statement2860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_behavior_code_block_statement_in_code_block_statement2860	= { FOLLOW_behavior_code_block_statement_in_code_block_statement2860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_block_statement_in_code_block_statement2865  */
static	ANTLR3_BITWORD FOLLOW_declaration_block_statement_in_code_block_statement2865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_block_statement_in_code_block_statement2865	= { FOLLOW_declaration_block_statement_in_code_block_statement2865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initialization_block_statement_in_code_block_statement2870  */
static	ANTLR3_BITWORD FOLLOW_initialization_block_statement_in_code_block_statement2870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_initialization_block_statement_in_code_block_statement2870	= { FOLLOW_initialization_block_statement_in_code_block_statement2870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_includes_block_statement_in_code_block_statement2875  */
static	ANTLR3_BITWORD FOLLOW_includes_block_statement_in_code_block_statement2875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_includes_block_statement_in_code_block_statement2875	= { FOLLOW_includes_block_statement_in_code_block_statement2875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_behavior_code_block_statement2894  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_behavior_code_block_statement2894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_behavior_code_block_statement2894	= { FOLLOW_code_block_with_info_in_behavior_code_block_statement2894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECL_in_declaration_block_statement2914  */
static	ANTLR3_BITWORD FOLLOW_DECL_in_declaration_block_statement2914_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECL_in_declaration_block_statement2914	= { FOLLOW_DECL_in_declaration_block_statement2914_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_declaration_block_statement2918  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_declaration_block_statement2918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_declaration_block_statement2918	= { FOLLOW_code_block_with_info_in_declaration_block_statement2918_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INIT_in_initialization_block_statement2938  */
static	ANTLR3_BITWORD FOLLOW_INIT_in_initialization_block_statement2938_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INIT_in_initialization_block_statement2938	= { FOLLOW_INIT_in_initialization_block_statement2938_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_initialization_block_statement2942  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_initialization_block_statement2942_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_initialization_block_statement2942	= { FOLLOW_code_block_with_info_in_initialization_block_statement2942_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_in_includes_block_statement2960  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_in_includes_block_statement2960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_in_includes_block_statement2960	= { FOLLOW_INCLUDE_in_includes_block_statement2960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_with_info_in_includes_block_statement2964  */
static	ANTLR3_BITWORD FOLLOW_code_block_with_info_in_includes_block_statement2964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_with_info_in_includes_block_statement2964	= { FOLLOW_code_block_with_info_in_includes_block_statement2964_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOTHING_in_nothing_statement2983  */
static	ANTLR3_BITWORD FOLLOW_NOTHING_in_nothing_statement2983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOTHING_in_nothing_statement2983	= { FOLLOW_NOTHING_in_nothing_statement2983_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wait_until_in_wait_statement3010  */
static	ANTLR3_BITWORD FOLLOW_wait_until_in_wait_statement3010_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wait_until_in_wait_statement3010	= { FOLLOW_wait_until_in_wait_statement3010_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wait_for_time_in_wait_statement3018  */
static	ANTLR3_BITWORD FOLLOW_wait_for_time_in_wait_statement3018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wait_for_time_in_wait_statement3018	= { FOLLOW_wait_for_time_in_wait_statement3018_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_single_wait_in_wait_statement3026  */
static	ANTLR3_BITWORD FOLLOW_single_wait_in_wait_statement3026_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_single_wait_in_wait_statement3026	= { FOLLOW_single_wait_in_wait_statement3026_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAIT_in_wait_until3051  */
static	ANTLR3_BITWORD FOLLOW_WAIT_in_wait_until3051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WAIT_in_wait_until3051	= { FOLLOW_WAIT_in_wait_until3051_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNTIL_in_wait_until3053  */
static	ANTLR3_BITWORD FOLLOW_UNTIL_in_wait_until3053_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_UNTIL_in_wait_until3053	= { FOLLOW_UNTIL_in_wait_until3053_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_wait_until3057  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_wait_until3057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_wait_until3057	= { FOLLOW_expression_cf_in_wait_until3057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAIT_in_wait_for_time3094  */
static	ANTLR3_BITWORD FOLLOW_WAIT_in_wait_for_time3094_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WAIT_in_wait_for_time3094	= { FOLLOW_WAIT_in_wait_for_time3094_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_wait_for_time3097  */
static	ANTLR3_BITWORD FOLLOW_72_in_wait_for_time3097_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_wait_for_time3097	= { FOLLOW_72_in_wait_for_time3097_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_wait_for_time3101  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_wait_for_time3101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_wait_for_time3101	= { FOLLOW_expression_cf_in_wait_for_time3101_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_wait_for_time3103  */
static	ANTLR3_BITWORD FOLLOW_75_in_wait_for_time3103_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_wait_for_time3103	= { FOLLOW_75_in_wait_for_time3103_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_wait_for_time3107  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_wait_for_time3107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_wait_for_time3107	= { FOLLOW_expression_cf_in_wait_for_time3107_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_wait_for_time3109  */
static	ANTLR3_BITWORD FOLLOW_73_in_wait_for_time3109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_wait_for_time3109	= { FOLLOW_73_in_wait_for_time3109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAIT_in_single_wait3140  */
static	ANTLR3_BITWORD FOLLOW_WAIT_in_single_wait3140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WAIT_in_single_wait3140	= { FOLLOW_WAIT_in_single_wait3140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stop_behavior_in_stop_statement3166  */
static	ANTLR3_BITWORD FOLLOW_stop_behavior_in_stop_statement3166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stop_behavior_in_stop_statement3166	= { FOLLOW_stop_behavior_in_stop_statement3166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stop_simulation_in_stop_statement3172  */
static	ANTLR3_BITWORD FOLLOW_stop_simulation_in_stop_statement3172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stop_simulation_in_stop_statement3172	= { FOLLOW_stop_simulation_in_stop_statement3172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STOP_in_stop_behavior3185  */
static	ANTLR3_BITWORD FOLLOW_STOP_in_stop_behavior3185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_STOP_in_stop_behavior3185	= { FOLLOW_STOP_in_stop_behavior3185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEHAVIOR_in_stop_behavior3187  */
static	ANTLR3_BITWORD FOLLOW_BEHAVIOR_in_stop_behavior3187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BEHAVIOR_in_stop_behavior3187	= { FOLLOW_BEHAVIOR_in_stop_behavior3187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STOP_in_stop_simulation3207  */
static	ANTLR3_BITWORD FOLLOW_STOP_in_stop_simulation3207_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STOP_in_stop_simulation3207	= { FOLLOW_STOP_in_stop_simulation3207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMULATION_in_stop_simulation3209  */
static	ANTLR3_BITWORD FOLLOW_SIMULATION_in_stop_simulation3209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMULATION_in_stop_simulation3209	= { FOLLOW_SIMULATION_in_stop_simulation3209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RUN_in_run_procedure_statement3229  */
static	ANTLR3_BITWORD FOLLOW_RUN_in_run_procedure_statement3229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RUN_in_run_procedure_statement3229	= { FOLLOW_RUN_in_run_procedure_statement3229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_run_procedure_statement3233  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_run_procedure_statement3233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_run_procedure_statement3233	= { FOLLOW_IDENTIFIER_in_run_procedure_statement3233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_if_statement_in_compound_statement3254  */
static	ANTLR3_BITWORD FOLLOW_if_statement_in_compound_statement3254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_if_statement_in_compound_statement3254	= { FOLLOW_if_statement_in_compound_statement3254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_do_while_statement_in_compound_statement3259  */
static	ANTLR3_BITWORD FOLLOW_do_while_statement_in_compound_statement3259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_do_while_statement_in_compound_statement3259	= { FOLLOW_do_while_statement_in_compound_statement3259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parallel_statement_in_compound_statement3264  */
static	ANTLR3_BITWORD FOLLOW_parallel_statement_in_compound_statement3264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parallel_statement_in_compound_statement3264	= { FOLLOW_parallel_statement_in_compound_statement3264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_if_statement3291  */
static	ANTLR3_BITWORD FOLLOW_IF_in_if_statement3291_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_if_statement3291	= { FOLLOW_IF_in_if_statement3291_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_if_statement3297  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_if_statement3297_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_if_statement3297	= { FOLLOW_expression_cf_in_if_statement3297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THEN_in_if_statement3301  */
static	ANTLR3_BITWORD FOLLOW_THEN_in_if_statement3301_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_THEN_in_if_statement3301	= { FOLLOW_THEN_in_if_statement3301_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_if_statement3311  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_if_statement3311_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000180000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_if_statement3311	= { FOLLOW_sequence_in_if_statement3311_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELSE_in_if_statement3329  */
static	ANTLR3_BITWORD FOLLOW_ELSE_in_if_statement3329_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_ELSE_in_if_statement3329	= { FOLLOW_ELSE_in_if_statement3329_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_if_statement3353  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_if_statement3353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_if_statement3353	= { FOLLOW_sequence_in_if_statement3353_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_if_statement3385  */
static	ANTLR3_BITWORD FOLLOW_END_in_if_statement3385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_if_statement3385	= { FOLLOW_END_in_if_statement3385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_if_statement3387  */
static	ANTLR3_BITWORD FOLLOW_IF_in_if_statement3387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_if_statement3387	= { FOLLOW_IF_in_if_statement3387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DO_in_do_while_statement3427  */
static	ANTLR3_BITWORD FOLLOW_DO_in_do_while_statement3427_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_DO_in_do_while_statement3427	= { FOLLOW_DO_in_do_while_statement3427_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_do_while_statement3517  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_do_while_statement3517_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_do_while_statement3517	= { FOLLOW_sequence_in_do_while_statement3517_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHILE_in_do_while_statement3581  */
static	ANTLR3_BITWORD FOLLOW_WHILE_in_do_while_statement3581_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_WHILE_in_do_while_statement3581	= { FOLLOW_WHILE_in_do_while_statement3581_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_do_while_statement3585  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_do_while_statement3585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_do_while_statement3585	= { FOLLOW_expression_cf_in_do_while_statement3585_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_in_do_while_statement3587  */
static	ANTLR3_BITWORD FOLLOW_END_in_do_while_statement3587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_END_in_do_while_statement3587	= { FOLLOW_END_in_do_while_statement3587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DO_in_do_while_statement3589  */
static	ANTLR3_BITWORD FOLLOW_DO_in_do_while_statement3589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DO_in_do_while_statement3589	= { FOLLOW_DO_in_do_while_statement3589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_parallel_statement3633  */
static	ANTLR3_BITWORD FOLLOW_82_in_parallel_statement3633_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_parallel_statement3633	= { FOLLOW_82_in_parallel_statement3633_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_parallel_statement3693  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_parallel_statement3693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_parallel_statement3693	= { FOLLOW_sequence_in_parallel_statement3693_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_84_in_parallel_statement3736  */
static	ANTLR3_BITWORD FOLLOW_84_in_parallel_statement3736_bits[]	= { ANTLR3_UINT64_LIT(0x0110080068030800), ANTLR3_UINT64_LIT(0x0000000000040104) };
static  ANTLR3_BITSET_LIST FOLLOW_84_in_parallel_statement3736	= { FOLLOW_84_in_parallel_statement3736_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequence_in_parallel_statement3793  */
static	ANTLR3_BITWORD FOLLOW_sequence_in_parallel_statement3793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequence_in_parallel_statement3793	= { FOLLOW_sequence_in_parallel_statement3793_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_parallel_statement3827  */
static	ANTLR3_BITWORD FOLLOW_83_in_parallel_statement3827_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_parallel_statement3827	= { FOLLOW_83_in_parallel_statement3827_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp1_in_expression_cf3986  */
static	ANTLR3_BITWORD FOLLOW_exp1_in_expression_cf3986_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp1_in_expression_cf3986	= { FOLLOW_exp1_in_expression_cf3986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_in_expression_cf3999  */
static	ANTLR3_BITWORD FOLLOW_OR_in_expression_cf3999_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_in_expression_cf3999	= { FOLLOW_OR_in_expression_cf3999_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp1_in_expression_cf4004  */
static	ANTLR3_BITWORD FOLLOW_exp1_in_expression_cf4004_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp1_in_expression_cf4004	= { FOLLOW_exp1_in_expression_cf4004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp2_in_exp14048  */
static	ANTLR3_BITWORD FOLLOW_exp2_in_exp14048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_exp2_in_exp14048	= { FOLLOW_exp2_in_exp14048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_exp14060  */
static	ANTLR3_BITWORD FOLLOW_AND_in_exp14060_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_exp14060	= { FOLLOW_AND_in_exp14060_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp2_in_exp14068  */
static	ANTLR3_BITWORD FOLLOW_exp2_in_exp14068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_exp2_in_exp14068	= { FOLLOW_exp2_in_exp14068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_exp24118  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_exp24118_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_exp24118	= { FOLLOW_NOT_in_exp24118_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp3_in_exp24133  */
static	ANTLR3_BITWORD FOLLOW_exp3_in_exp24133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp3_in_exp24133	= { FOLLOW_exp3_in_exp24133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp4_in_exp34163  */
static	ANTLR3_BITWORD FOLLOW_exp4_in_exp34163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002), ANTLR3_UINT64_LIT(0x000000000003C040) };
static  ANTLR3_BITSET_LIST FOLLOW_exp4_in_exp34163	= { FOLLOW_exp4_in_exp34163_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparison_operator_in_exp34178  */
static	ANTLR3_BITWORD FOLLOW_comparison_operator_in_exp34178_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_comparison_operator_in_exp34178	= { FOLLOW_comparison_operator_in_exp34178_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp4_in_exp34194  */
static	ANTLR3_BITWORD FOLLOW_exp4_in_exp34194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002), ANTLR3_UINT64_LIT(0x000000000003C040) };
static  ANTLR3_BITSET_LIST FOLLOW_exp4_in_exp34194	= { FOLLOW_exp4_in_exp34194_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp5_in_exp44239  */
static	ANTLR3_BITWORD FOLLOW_exp5_in_exp44239_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp5_in_exp44239	= { FOLLOW_exp5_in_exp44239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_add_operator_in_exp44254  */
static	ANTLR3_BITWORD FOLLOW_add_operator_in_exp44254_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_add_operator_in_exp44254	= { FOLLOW_add_operator_in_exp44254_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp5_in_exp44270  */
static	ANTLR3_BITWORD FOLLOW_exp5_in_exp44270_bits[]	= { ANTLR3_UINT64_LIT(0x0002004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exp5_in_exp44270	= { FOLLOW_exp5_in_exp44270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp6_in_exp54314  */
static	ANTLR3_BITWORD FOLLOW_exp6_in_exp54314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_exp6_in_exp54314	= { FOLLOW_exp6_in_exp54314_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mul_operator_in_exp54329  */
static	ANTLR3_BITWORD FOLLOW_mul_operator_in_exp54329_bits[]	= { ANTLR3_UINT64_LIT(0x6200004204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_mul_operator_in_exp54329	= { FOLLOW_mul_operator_in_exp54329_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exp6_in_exp54345  */
static	ANTLR3_BITWORD FOLLOW_exp6_in_exp54345_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001480) };
static  ANTLR3_BITSET_LIST FOLLOW_exp6_in_exp54345	= { FOLLOW_exp6_in_exp54345_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_exp64395  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_exp64395_bits[]	= { ANTLR3_UINT64_LIT(0x6200000204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_exp64395	= { FOLLOW_MINUS_in_exp64395_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomic_expression_cf_in_exp64413  */
static	ANTLR3_BITWORD FOLLOW_atomic_expression_cf_in_exp64413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomic_expression_cf_in_exp64413	= { FOLLOW_atomic_expression_cf_in_exp64413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_atomic_expression_cf4546  */
static	ANTLR3_BITWORD FOLLOW_72_in_atomic_expression_cf4546_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_atomic_expression_cf4546	= { FOLLOW_72_in_atomic_expression_cf4546_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_atomic_expression_cf4549  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_atomic_expression_cf4549_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_atomic_expression_cf4549	= { FOLLOW_expression_cf_in_atomic_expression_cf4549_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_atomic_expression_cf4550  */
static	ANTLR3_BITWORD FOLLOW_73_in_atomic_expression_cf4550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_atomic_expression_cf4550	= { FOLLOW_73_in_atomic_expression_cf4550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_atomic_expression_cf4575  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_atomic_expression_cf4575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_atomic_expression_cf4575	= { FOLLOW_function_call_in_atomic_expression_cf4575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_this_cycle_in_atomic_expression_cf4592  */
static	ANTLR3_BITWORD FOLLOW_this_cycle_in_atomic_expression_cf4592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_this_cycle_in_atomic_expression_cf4592	= { FOLLOW_this_cycle_in_atomic_expression_cf4592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_this_phase_in_atomic_expression_cf4611  */
static	ANTLR3_BITWORD FOLLOW_this_phase_in_atomic_expression_cf4611_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_this_phase_in_atomic_expression_cf4611	= { FOLLOW_this_phase_in_atomic_expression_cf4611_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atomic_expression_cf4630  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atomic_expression_cf4630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atomic_expression_cf4630	= { FOLLOW_INTEGER_in_atomic_expression_cf4630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_atomic_expression_cf4650  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_atomic_expression_cf4650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_atomic_expression_cf4650	= { FOLLOW_STRING_in_atomic_expression_cf4650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_atomic_expression_cf4673  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_atomic_expression_cf4673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_atomic_expression_cf4673	= { FOLLOW_identifier_in_atomic_expression_cf4673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_code_block_in_atomic_expression_cf4692  */
static	ANTLR3_BITWORD FOLLOW_expression_code_block_in_atomic_expression_cf4692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_code_block_in_atomic_expression_cf4692	= { FOLLOW_expression_code_block_in_atomic_expression_cf4692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_in_expression_code_block4755  */
static	ANTLR3_BITWORD FOLLOW_code_block_in_expression_code_block4755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_in_expression_code_block4755	= { FOLLOW_code_block_in_expression_code_block4755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_function_call4840  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_function_call4840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_function_call4840	= { FOLLOW_identifier_in_function_call4840_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_function_call4842  */
static	ANTLR3_BITWORD FOLLOW_72_in_function_call4842_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000300) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_function_call4842	= { FOLLOW_72_in_function_call4842_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_list_in_function_call4871  */
static	ANTLR3_BITWORD FOLLOW_argument_list_in_function_call4871_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_list_in_function_call4871	= { FOLLOW_argument_list_in_function_call4871_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_function_call4895  */
static	ANTLR3_BITWORD FOLLOW_73_in_function_call4895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_function_call4895	= { FOLLOW_73_in_function_call4895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_argument_list4930  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_argument_list4930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_argument_list4930	= { FOLLOW_expression_cf_in_argument_list4930_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_argument_list4951  */
static	ANTLR3_BITWORD FOLLOW_75_in_argument_list4951_bits[]	= { ANTLR3_UINT64_LIT(0x6200044204000800), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_argument_list4951	= { FOLLOW_75_in_argument_list4951_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_cf_in_argument_list4986  */
static	ANTLR3_BITWORD FOLLOW_expression_cf_in_argument_list4986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_cf_in_argument_list4986	= { FOLLOW_expression_cf_in_argument_list4986_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THIS_CYCLE_in_this_cycle5040  */
static	ANTLR3_BITWORD FOLLOW_THIS_CYCLE_in_this_cycle5040_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_THIS_CYCLE_in_this_cycle5040	= { FOLLOW_THIS_CYCLE_in_this_cycle5040_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THIS_PHASE_in_this_phase5093  */
static	ANTLR3_BITWORD FOLLOW_THIS_PHASE_in_this_phase5093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_THIS_PHASE_in_this_phase5093	= { FOLLOW_THIS_PHASE_in_this_phase5093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_code_block_in_code_block_with_info5151  */
static	ANTLR3_BITWORD FOLLOW_code_block_in_code_block_with_info5151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_code_block_in_code_block_with_info5151	= { FOLLOW_code_block_in_code_block_with_info5151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CODE_BLOCK_in_code_block5218  */
static	ANTLR3_BITWORD FOLLOW_CODE_BLOCK_in_code_block5218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CODE_BLOCK_in_code_block5218	= { FOLLOW_CODE_BLOCK_in_code_block5218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_identifier5274  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_identifier5274_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_identifier5274	= { FOLLOW_IDENTIFIER_in_identifier5274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_identifier5276  */
static	ANTLR3_BITWORD FOLLOW_set_in_identifier5276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_identifier5276	= { FOLLOW_set_in_identifier5276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_identifier5283  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_identifier5283_bits[]	= { ANTLR3_UINT64_LIT(0x0024000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_identifier5283	= { FOLLOW_IDENTIFIER_in_identifier5283_bits, 1	};



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    2318:1: atomic_expression_cf returns [std::string text] : ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block );
 */
static const ANTLR3_INT32 dfa74_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa74_eof[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa74_min[12] =
    {
	11, -1, 4, -1, -1, -1, -1, -1, 26, -1, -1, 4
    };
static const ANTLR3_INT32 dfa74_max[12] =
    {
	72, -1, 84, -1, -1, -1, -1, -1, 26, -1, -1, 84
    };
static const ANTLR3_INT32 dfa74_accept[12] =
    {
	-1, 1, -1, 3, 4, 5, 6, 8, -1, 2, 7, -1
    };
static const ANTLR3_INT32 dfa74_special[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa74_T_empty	    NULL

static const ANTLR3_INT32 dfa74_T0[] =
    {
	11
    };

static const ANTLR3_INT32 dfa74_T1[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, 8, 10, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, 10, -1, -1, -1, 10, 8, -1, -1, 8, -1, -1, -1, -1, -1, 
	-1, 10, -1, -1, -1, -1, -1, -1, 10, -1, -1, 10, 10, 9, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, -1, 10, 10
    };

static const ANTLR3_INT32 dfa74_T2[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 
	-1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, 3, 4, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa74_transitions[] =
{
    dfa74_T2, NULL, dfa74_T1, NULL, NULL, NULL, NULL, NULL, dfa74_T0, NULL, 
    NULL, dfa74_T1
};


/* Declare tracking structure for Cyclic DFA 74
 */
static
ANTLR3_CYCLIC_DFA cdfa74
    =	{
	    74,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"2318:1: atomic_expression_cf returns [std::string text] : ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa74_eot,	    /* EOT table			    */
	    dfa74_eof,	    /* EOF table			    */
	    dfa74_min,	    /* Minimum tokens for each state    */
	    dfa74_max,	    /* Maximum tokens for each state    */
	    dfa74_accept,	/* Accept table			    */
	    dfa74_special,	/* Special transition states	    */
	    dfa74_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 74
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start top
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:192:1: top : ( design_unit )+ EOF ;
 */
static void
top(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_topTop = psitarParser_topPush(ctx);
     (SCOPE_TOP(top))->design_unit_names_list=new std::set<std::string>;
    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:197:2: ( ( design_unit )+ EOF )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:197:4: ( design_unit )+ EOF
        {
            {

                			//check if all initializations have occured correctly
                			assert(CODEGEN!=NULL); 
                			assert(GDATA!=NULL);
                			
                			
                		
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:206:3: ( design_unit )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) )
            	{
            	case MODULE:
            	case PROCEDURE:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:207:4: design_unit
            	        {
            	            {
            	                //Ready the data structure:
            	                			//open files for writing and clear
            	                			//the data from previous module description
            	                			if(!(GDATA->openFilesForWriting())) 
            	                			 {std::cout<<"\nERROR: sitar translator couldn't open temporary files for code generation"; exit(1);}
            	                			 D_file<<" ";
            	                			 C_file<<" ";
            	                			 I_file<<" ";
            	                			 E_file<<" ";
            	                			
            	            }


            	            FOLLOWPUSH(FOLLOW_design_unit_in_top578);
            	            design_unit(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletopEx;
            	            }


            	            {

            	                		 	 // after parsing a design unit, close temp files. 
            	                			 //They will be opened by CodeGen for reading
            	                			 GDATA->closeFiles();
            	                			 
            	                			 //Ask codeGen to dump code for the module description just parsed.
            	                			 CODEGEN->parse();
            	                		 	
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletopEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(EOF, &FOLLOW_EOF_in_top599);
            if  (HASEXCEPTION())
            {
                goto ruletopEx;
            }


            {

                		GDATA->closeFiles();
                		GDATA->deleteTemporaryFiles();
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletopEx; /* Prevent compiler warnings */
    ruletopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     delete (SCOPE_TOP(top))->design_unit_names_list;
                }
            }


    psitarParser_topPop(ctx);

    return ;
}
/* $ANTLR end top */

/**
 * $ANTLR start design_unit
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:241:1: design_unit : du ;
 */
static void
design_unit(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:241:13: ( du )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:241:15: du
        {
            FOLLOWPUSH(FOLLOW_du_in_design_unit619);
            du(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledesign_unitEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledesign_unitEx; /* Prevent compiler warnings */
    ruledesign_unitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end design_unit */

/**
 * $ANTLR start du
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:243:1: du : ( ( module_definition ) | ( procedure_definition ) ) ;
 */
static void
du(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_duTop = psitarParser_duPush(ctx);

    	//initialize aatributes
    	(SCOPE_TOP(du))->design_unit_name=new std::string("");
    	
    	(SCOPE_TOP(du))->is_module=true;
    	(SCOPE_TOP(du))->has_parameters=false;
    	(SCOPE_TOP(du))->has_behavior=false;
    	
    	(SCOPE_TOP(du))->num_pointers=0;
    	(SCOPE_TOP(du))->num_timers=0;
    	(SCOPE_TOP(du))->num_if_flags=0;
    	
    	(SCOPE_TOP(du))->filename_h=new std::string("");
    	(SCOPE_TOP(du))->filename_cpp=new std::string("");;
    	(SCOPE_TOP(du))->header_guard=new std::string("");
    	(SCOPE_TOP(du))->template_class=new std::string("");;
    	(SCOPE_TOP(du))->template_member=new std::string("");
    	(SCOPE_TOP(du))->template_args=new std::string("");
    	
    	(SCOPE_TOP(du))->param_name=new std::list<std::string>;
    	(SCOPE_TOP(du))->param_type=new std::list<std::string>;
    	(SCOPE_TOP(du))->param_value=new std::list<std::string>;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:336:3: ( ( ( module_definition ) | ( procedure_definition ) ) )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:336:3: ( ( module_definition ) | ( procedure_definition ) )
        {
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:336:3: ( ( module_definition ) | ( procedure_definition ) )
            {
                int alt2=2;
                switch ( LA(1) )
                {
                case MODULE:
                	{
                		alt2=1;
                	}
                    break;
                case PROCEDURE:
                	{
                		alt2=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 2;
                    EXCEPTION->state        = 0;


                    goto ruleduEx;

                }

                switch (alt2)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:336:6: ( module_definition )
            	    {
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:336:6: ( module_definition )
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:336:10: module_definition
            	        {
            	            FOLLOWPUSH(FOLLOW_module_definition_in_du657);
            	            module_definition(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleduEx;
            	            }


            	            {
            	                (SCOPE_TOP(du))->is_module=true;
            	            }


            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:337:5: ( procedure_definition )
            	    {
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:337:5: ( procedure_definition )
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:337:9: procedure_definition
            	        {
            	            FOLLOWPUSH(FOLLOW_procedure_definition_in_du673);
            	            procedure_definition(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleduEx;
            	            }


            	            {
            	                (SCOPE_TOP(du))->is_module=false;
            	            }


            	        }


            	    }
            	    break;

                }
            }

            {

                	//ready attributes for storing in Global Data structure
                	std::string is_module="";
                	std::string has_parameters="";
                	std::string has_behavior="";

                	if((SCOPE_TOP(du))->is_module) {is_module="y";};
                	if((SCOPE_TOP(du))->has_parameters) {has_parameters="y";};
                	if((SCOPE_TOP(du))->has_behavior) {has_behavior="y";};
                	
                	//determine output file names
                	*(SCOPE_TOP(du))->filename_h=std::string(OUTPUT_FILE_PREFIX_STR+ *(SCOPE_TOP(du))->design_unit_name + ".h");
                	*(SCOPE_TOP(du))->filename_cpp=std::string(OUTPUT_FILE_PREFIX_STR+ *(SCOPE_TOP(du))->design_unit_name + ".cpp");


                	//Generate a string for header guard
                	std::string h=OUTPUT_FILE_PREFIX_STR + *(SCOPE_TOP(du))->design_unit_name;
                	std::transform(h.begin(), h.end(),h.begin(), ::toupper);
                	*(SCOPE_TOP(du))->header_guard=h+"_H";



                	//Generate strings for declaration of template
                	//parameters at various places in the generated code
                	 *(SCOPE_TOP(du))->template_class="";
                	 *(SCOPE_TOP(du))->template_member="";
                	 *(SCOPE_TOP(du))->template_args="";

                		
                	if((SCOPE_TOP(du))->has_parameters==true)
                	{
                		bool flag_first =true;
                	
                		*(SCOPE_TOP(du))->template_class= "template<";
                		*(SCOPE_TOP(du))->template_member="template<";
                		*(SCOPE_TOP(du))->template_args=  "<";

                		while(!(SCOPE_TOP(du))->param_name->empty())
                		{
                			if(!flag_first)
                			{
                				//put a comma
                				(SCOPE_TOP(du))->template_class->append(","); 
                				(SCOPE_TOP(du))->template_member->append(",");
                				(SCOPE_TOP(du))->template_args->append(",");
                			}
                			(SCOPE_TOP(du))->template_class->append((SCOPE_TOP(du))->param_type->front()+" ");
                			(SCOPE_TOP(du))->template_member->append((SCOPE_TOP(du))->param_type->front()+" ");

                			(SCOPE_TOP(du))->template_class->append( (SCOPE_TOP(du))->param_name->front());
                			(SCOPE_TOP(du))->template_member->append((SCOPE_TOP(du))->param_name->front());
                			(SCOPE_TOP(du))->template_args->append(  (SCOPE_TOP(du))->param_name->front());

                			(SCOPE_TOP(du))->template_class->append("=");
                			(SCOPE_TOP(du))->template_class->append((SCOPE_TOP(du))->param_value->front());

                			(SCOPE_TOP(du))->param_name->pop_front();
                			(SCOPE_TOP(du))->param_type->pop_front();
                			(SCOPE_TOP(du))->param_value->pop_front();

                			//the 3 lists should be in sync
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_value->size());
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_type->size());

                			flag_first=false;
                		}
                		(SCOPE_TOP(du))->template_class->append(">"); 
                		(SCOPE_TOP(du))->template_member->append(">");
                		(SCOPE_TOP(du))->template_args->append(">");
                	};


                	//Now store all the attributes in GDATA

                	GDATA->storeAttrib("design_unit_name",*(SCOPE_TOP(du))->design_unit_name);
                	GDATA->storeAttrib("is_module",is_module);
                	GDATA->storeAttrib("has_parameters",has_parameters);
                	GDATA->storeAttrib("has_behavior",has_behavior);

                	GDATA->storeAttrib("num_pointers",CODEGEN->intToString((SCOPE_TOP(du))->num_pointers)); 
                	GDATA->storeAttrib("num_timers",CODEGEN->intToString((SCOPE_TOP(du))->num_timers)); 
                	GDATA->storeAttrib("num_if_flags",CODEGEN->intToString((SCOPE_TOP(du))->num_if_flags)); 
                	
                	GDATA->storeAttrib("filename_h",*(SCOPE_TOP(du))->filename_h);
                	GDATA->storeAttrib("filename_cpp",*(SCOPE_TOP(du))->filename_cpp);
                	GDATA->storeAttrib("header_guard",*(SCOPE_TOP(du))->header_guard);
                	
                	
                	GDATA->storeAttrib("template_class",*(SCOPE_TOP(du))->template_class);
                	GDATA->storeAttrib("template_member",*(SCOPE_TOP(du))->template_member);
                	GDATA->storeAttrib("template_args",*(SCOPE_TOP(du))->template_args); 
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleduEx; /* Prevent compiler warnings */
    ruleduEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	
                    	
                    	
                    	
                    	
                    	//deallocate memory
                    	delete (SCOPE_TOP(du))->design_unit_name;
                    	delete (SCOPE_TOP(du))->filename_h;
                    	delete (SCOPE_TOP(du))->filename_cpp;
                    	delete (SCOPE_TOP(du))->header_guard;
                    	delete (SCOPE_TOP(du))->template_class;
                    	delete (SCOPE_TOP(du))->template_member;
                    	delete (SCOPE_TOP(du))->template_args;

                    	delete (SCOPE_TOP(du))->param_name;
                    	delete (SCOPE_TOP(du))->param_type;
                    	delete (SCOPE_TOP(du))->param_value;

                }
            }


    psitarParser_duPop(ctx);

    return ;
}
/* $ANTLR end du */

/**
 * $ANTLR start module_definition
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:443:1: module_definition : MODULE id= IDENTIFIER module_body END MODULE ;
 */
static void
module_definition(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:444:2: ( MODULE id= IDENTIFIER module_body END MODULE )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:444:4: MODULE id= IDENTIFIER module_body END MODULE
        {
             MATCHT(MODULE, &FOLLOW_MODULE_in_module_definition705);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


            {
                (SCOPE_TOP(du))->is_module=true;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_module_definition710);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


            {

                		    //check for duplicate design unit names
                		    *(SCOPE_TOP(du))->design_unit_name=(const char*)((id->getText(id))->chars);
                		    std::string mname=*(SCOPE_TOP(du))->design_unit_name;
                		    		    
                		    if((SCOPE_TOP(top))->design_unit_names_list->count(mname)>0)
                		    {
                			    std::cout<<"\nDuplicate definition of module ";
                			    std::cout<<mname<<" on line ";
                			    std::cout<<(id->getLine(id));
                		    }
                		    else{(SCOPE_TOP(top))->design_unit_names_list->insert(mname);}
                		
                		
            }


            FOLLOWPUSH(FOLLOW_module_body_in_module_definition721);
            module_body(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


             MATCHT(END, &FOLLOW_END_in_module_definition725);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


             MATCHT(MODULE, &FOLLOW_MODULE_in_module_definition727);
            if  (HASEXCEPTION())
            {
                goto rulemodule_definitionEx;
            }


            {

                			
                			//Write msg to screen
                			std::cout<<"\nParsed module "<<*(SCOPE_TOP(du))->design_unit_name; 
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemodule_definitionEx; /* Prevent compiler warnings */
    rulemodule_definitionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end module_definition */

/**
 * $ANTLR start procedure_definition
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:472:1: procedure_definition : PROCEDURE id= IDENTIFIER procedure_body END PROCEDURE ;
 */
static void
procedure_definition(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:473:2: ( PROCEDURE id= IDENTIFIER procedure_body END PROCEDURE )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:473:4: PROCEDURE id= IDENTIFIER procedure_body END PROCEDURE
        {
             MATCHT(PROCEDURE, &FOLLOW_PROCEDURE_in_procedure_definition758);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


            {
                (SCOPE_TOP(du))->is_module=false;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_definition763);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


            {

                		    //check for duplicate design unit names
                		    *(SCOPE_TOP(du))->design_unit_name=(const char*)((id->getText(id))->chars);
                		    std::string mname=*(SCOPE_TOP(du))->design_unit_name;
                		    		    
                		    if((SCOPE_TOP(top))->design_unit_names_list->count(mname)>0)
                		    {
                			    std::cout<<"\nDuplicate definition of procedure ";
                			    std::cout<<mname<<"on line ";
                			    std::cout<<(id->getLine(id));
                		    }
                		    else{(SCOPE_TOP(top))->design_unit_names_list->insert(mname);}
                		
                		
            }


            FOLLOWPUSH(FOLLOW_procedure_body_in_procedure_definition775);
            procedure_body(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


             MATCHT(END, &FOLLOW_END_in_procedure_definition779);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


             MATCHT(PROCEDURE, &FOLLOW_PROCEDURE_in_procedure_definition781);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_definitionEx;
            }


            {

                			
                			//Write msg to screen
                			std::cout<<"\nParsed procedure "<<*(SCOPE_TOP(du))->design_unit_name; 
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprocedure_definitionEx; /* Prevent compiler warnings */
    ruleprocedure_definitionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end procedure_definition */

/**
 * $ANTLR start module_body
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:514:1: module_body : ( parameter_declaration_region )? ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )? ;
 */
static void
module_body(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:515:2: ( ( parameter_declaration_region )? ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:517:3: ( parameter_declaration_region )? ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )* ( behavior_block ( code_block_regions )* )?
        {
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:517:3: ( parameter_declaration_region )?
            {
                int alt3=2;
                switch ( LA(1) )
                {
                    case PARAMETER:
                    	{
                    		alt3=1;
                    	}
                        break;
                }

                switch (alt3)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:517:5: parameter_declaration_region
            	    {
            	        FOLLOWPUSH(FOLLOW_parameter_declaration_region_in_module_body833);
            	        parameter_declaration_region(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemodule_bodyEx;
            	        }


            	        {
            	            (SCOPE_TOP(du))->has_parameters=true;
            	        }


            	    }
            	    break;

                }
            }

            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:518:3: ( ( code_block_regions | structural_component_declaration | procedure_declaration ) )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case DECL:
                case FOR:
                case IDENTIFIER:
                case INCLUDE:
                case INIT:
                case INPORT:
                case INPORT_ARRAY:
                case NET:
                case NET_ARRAY:
                case OUTPORT:
                case OUTPORT_ARRAY:
                case PROCEDURE:
                case SUBMODULE:
                case SUBMODULE_ARRAY:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:518:5: ( code_block_regions | structural_component_declaration | procedure_declaration )
            	    {
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:518:5: ( code_block_regions | structural_component_declaration | procedure_declaration )
            	        {
            	            int alt4=3;
            	            switch ( LA(1) )
            	            {
            	            case DECL:
            	            case INCLUDE:
            	            case INIT:
            	            	{
            	            		alt4=1;
            	            	}
            	                break;
            	            case FOR:
            	            case IDENTIFIER:
            	            case INPORT:
            	            case INPORT_ARRAY:
            	            case NET:
            	            case NET_ARRAY:
            	            case OUTPORT:
            	            case OUTPORT_ARRAY:
            	            case SUBMODULE:
            	            case SUBMODULE_ARRAY:
            	            	{
            	            		alt4=2;
            	            	}
            	                break;
            	            case PROCEDURE:
            	            	{
            	            		alt4=3;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 4;
            	                EXCEPTION->state        = 0;


            	                goto rulemodule_bodyEx;

            	            }

            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:518:6: code_block_regions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_code_block_regions_in_module_body868);
            	        	        code_block_regions(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:518:27: structural_component_declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_structural_component_declaration_in_module_body872);
            	        	        structural_component_declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:518:61: procedure_declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_procedure_declaration_in_module_body875);
            	        	        procedure_declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:519:3: ( behavior_block ( code_block_regions )* )?
            {
                int alt7=2;
                switch ( LA(1) )
                {
                    case BEHAVIOR:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:519:5: behavior_block ( code_block_regions )*
            	    {
            	        FOLLOWPUSH(FOLLOW_behavior_block_in_module_body886);
            	        behavior_block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemodule_bodyEx;
            	        }


            	        {
            	            (SCOPE_TOP(du))->has_behavior=true;
            	        }


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:519:45: ( code_block_regions )*

            	        for (;;)
            	        {
            	            int alt6=2;
            	            switch ( LA(1) )
            	            {
            	            case DECL:
            	            case INCLUDE:
            	            case INIT:
            	            	{
            	            		alt6=1;
            	            	}
            	                break;

            	            }

            	            switch (alt6)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:519:46: code_block_regions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_code_block_regions_in_module_body890);
            	        	        code_block_regions(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemodule_bodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop6;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop6: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulemodule_bodyEx; /* Prevent compiler warnings */
    rulemodule_bodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end module_body */

/**
 * $ANTLR start procedure_body
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:523:1: procedure_body : ( parameter_declaration_region )? ( ( code_block_regions | procedure_declaration ) )* ( behavior_block ) ( ( code_block_regions )* ) ;
 */
static void
procedure_body(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:524:2: ( ( parameter_declaration_region )? ( ( code_block_regions | procedure_declaration ) )* ( behavior_block ) ( ( code_block_regions )* ) )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:526:3: ( parameter_declaration_region )? ( ( code_block_regions | procedure_declaration ) )* ( behavior_block ) ( ( code_block_regions )* )
        {
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:526:3: ( parameter_declaration_region )?
            {
                int alt8=2;
                switch ( LA(1) )
                {
                    case PARAMETER:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:526:5: parameter_declaration_region
            	    {
            	        FOLLOWPUSH(FOLLOW_parameter_declaration_region_in_procedure_body934);
            	        parameter_declaration_region(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_bodyEx;
            	        }


            	        {
            	            (SCOPE_TOP(du))->has_parameters=true;
            	        }


            	    }
            	    break;

                }
            }

            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:527:3: ( ( code_block_regions | procedure_declaration ) )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) )
                {
                case DECL:
                case INCLUDE:
                case INIT:
                case PROCEDURE:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:527:5: ( code_block_regions | procedure_declaration )
            	    {
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:527:5: ( code_block_regions | procedure_declaration )
            	        {
            	            int alt9=2;
            	            switch ( LA(1) )
            	            {
            	            case DECL:
            	            case INCLUDE:
            	            case INIT:
            	            	{
            	            		alt9=1;
            	            	}
            	                break;
            	            case PROCEDURE:
            	            	{
            	            		alt9=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 9;
            	                EXCEPTION->state        = 0;


            	                goto ruleprocedure_bodyEx;

            	            }

            	            switch (alt9)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:527:6: code_block_regions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_code_block_regions_in_procedure_body953);
            	        	        code_block_regions(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprocedure_bodyEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:527:27: procedure_declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_procedure_declaration_in_procedure_body957);
            	        	        procedure_declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprocedure_bodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:528:3: ( behavior_block )
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:528:4: behavior_block
            {
                FOLLOWPUSH(FOLLOW_behavior_block_in_procedure_body987);
                behavior_block(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleprocedure_bodyEx;
                }


                {
                    (SCOPE_TOP(du))->has_behavior=true;
                }


            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:529:3: ( ( code_block_regions )* )
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:529:4: ( code_block_regions )*
            {
                // /home/nehak/Projects/sitar/translator/grammar/sitar.g:529:4: ( code_block_regions )*

                for (;;)
                {
                    int alt11=2;
                    switch ( LA(1) )
                    {
                    case DECL:
                    case INCLUDE:
                    case INIT:
                    	{
                    		alt11=1;
                    	}
                        break;

                    }

                    switch (alt11)
                    {
                	case 1:
                	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:529:4: code_block_regions
                	    {
                	        FOLLOWPUSH(FOLLOW_code_block_regions_in_procedure_body995);
                	        code_block_regions(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleprocedure_bodyEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */


            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprocedure_bodyEx; /* Prevent compiler warnings */
    ruleprocedure_bodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end procedure_body */

/**
 * $ANTLR start code_block_regions
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:536:1: code_block_regions : ( include_block | declaration_block | initialization_block );
 */
static void
code_block_regions(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:537:2: ( include_block | declaration_block | initialization_block )

            ANTLR3_UINT32 alt12;

            alt12=3;

            switch ( LA(1) )
            {
            case INCLUDE:
            	{
            		alt12=1;
            	}
                break;
            case DECL:
            	{
            		alt12=2;
            	}
                break;
            case INIT:
            	{
            		alt12=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto rulecode_block_regionsEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:537:4: include_block
        	    {
        	        FOLLOWPUSH(FOLLOW_include_block_in_code_block_regions1015);
        	        include_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_regionsEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:538:4: declaration_block
        	    {
        	        FOLLOWPUSH(FOLLOW_declaration_block_in_code_block_regions1020);
        	        declaration_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_regionsEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:539:4: initialization_block
        	    {
        	        FOLLOWPUSH(FOLLOW_initialization_block_in_code_block_regions1025);
        	        initialization_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_regionsEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecode_block_regionsEx; /* Prevent compiler warnings */
    rulecode_block_regionsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end code_block_regions */

/**
 * $ANTLR start include_block
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:541:1: include_block : INCLUDE c= code_block_with_info ;
 */
static void
include_block(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:542:2: ( INCLUDE c= code_block_with_info )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:542:4: INCLUDE c= code_block_with_info
        {
             MATCHT(INCLUDE, &FOLLOW_INCLUDE_in_include_block1035);
            if  (HASEXCEPTION())
            {
                goto ruleinclude_blockEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_include_block1039);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinclude_blockEx;
            }


            {
                	I_file<<c.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinclude_blockEx; /* Prevent compiler warnings */
    ruleinclude_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end include_block */

/**
 * $ANTLR start declaration_block
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:546:1: declaration_block : DECL c= code_block_with_info ;
 */
static void
declaration_block(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:547:2: ( DECL c= code_block_with_info )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:547:4: DECL c= code_block_with_info
        {
             MATCHT(DECL, &FOLLOW_DECL_in_declaration_block1052);
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_blockEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_declaration_block1056);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_blockEx;
            }


            {
                	D_file<<c.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_blockEx; /* Prevent compiler warnings */
    ruledeclaration_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration_block */

/**
 * $ANTLR start initialization_block
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:551:1: initialization_block : INIT c= code_block_with_info ;
 */
static void
initialization_block(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:552:2: ( INIT c= code_block_with_info )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:552:4: INIT c= code_block_with_info
        {
             MATCHT(INIT, &FOLLOW_INIT_in_initialization_block1069);
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_blockEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_initialization_block1073);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_blockEx;
            }


            {
                	C_file<<c.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinitialization_blockEx; /* Prevent compiler warnings */
    ruleinitialization_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end initialization_block */

/**
 * $ANTLR start structural_component_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:560:1: structural_component_declaration : ( port_declaration | net_declaration | submodule_declaration | connection ) ;
 */
static void
structural_component_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:561:2: ( ( port_declaration | net_declaration | submodule_declaration | connection ) )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:565:3: ( port_declaration | net_declaration | submodule_declaration | connection )
        {
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:565:3: ( port_declaration | net_declaration | submodule_declaration | connection )
            {
                int alt13=4;
                switch ( LA(1) )
                {
                case INPORT:
                case INPORT_ARRAY:
                case OUTPORT:
                case OUTPORT_ARRAY:
                	{
                		alt13=1;
                	}
                    break;
                case NET:
                case NET_ARRAY:
                	{
                		alt13=2;
                	}
                    break;
                case SUBMODULE:
                case SUBMODULE_ARRAY:
                	{
                		alt13=3;
                	}
                    break;
                case FOR:
                case IDENTIFIER:
                	{
                		alt13=4;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 13;
                    EXCEPTION->state        = 0;


                    goto rulestructural_component_declarationEx;

                }

                switch (alt13)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:565:5: port_declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_port_declaration_in_structural_component_declaration1101);
            	        port_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:566:5: net_declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_net_declaration_in_structural_component_declaration1107);
            	        net_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:567:5: submodule_declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_submodule_declaration_in_structural_component_declaration1113);
            	        submodule_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:568:5: connection
            	    {
            	        FOLLOWPUSH(FOLLOW_connection_in_structural_component_declaration1119);
            	        connection(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructural_component_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestructural_component_declarationEx; /* Prevent compiler warnings */
    rulestructural_component_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end structural_component_declaration */

/**
 * $ANTLR start parameter_declaration_region
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:578:1: parameter_declaration_region : ( parameter_declaration ( ';' )? )+ ;
 */
static void
parameter_declaration_region(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:579:2: ( ( parameter_declaration ( ';' )? )+ )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:579:5: ( parameter_declaration ( ';' )? )+
        {
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:579:5: ( parameter_declaration ( ';' )? )+
            {
                int cnt15=0;

                for (;;)
                {
                    int alt15=2;
            	switch ( LA(1) )
            	{
            	case PARAMETER:
            		{
            			alt15=1;
            		}
            	    break;

            	}

            	switch (alt15)
            	{
            	    case 1:
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:579:6: parameter_declaration ( ';' )?
            	        {
            	            FOLLOWPUSH(FOLLOW_parameter_declaration_in_parameter_declaration_region1147);
            	            parameter_declaration(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparameter_declaration_regionEx;
            	            }


            	            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:579:28: ( ';' )?
            	            {
            	                int alt14=2;
            	                switch ( LA(1) )
            	                {
            	                    case 77:
            	                    	{
            	                    		alt14=1;
            	                    	}
            	                        break;
            	                }

            	                switch (alt14)
            	                {
            	            	case 1:
            	            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:579:28: ';'
            	            	    {
            	            	         MATCHT(77, &FOLLOW_77_in_parameter_declaration_region1149);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleparameter_declaration_regionEx;
            	            	        }


            	            	    }
            	            	    break;

            	                }
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt15 >= 1 )
            		{
            		    goto loop15;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleparameter_declaration_regionEx;
            	}
            	cnt15++;
                }
                loop15: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparameter_declaration_regionEx; /* Prevent compiler warnings */
    ruleparameter_declaration_regionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parameter_declaration_region */

/**
 * $ANTLR start parameter_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:584:1: parameter_declaration : PARAMETER pt= param_type id= IDENTIFIER EQUALS val= default_value ;
 */
static void
parameter_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;
    sitarParser_param_type_return pt;
    #undef	RETURN_TYPE_pt
    #define	RETURN_TYPE_pt sitarParser_param_type_return

    sitarParser_default_value_return val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val sitarParser_default_value_return

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:585:2: ( PARAMETER pt= param_type id= IDENTIFIER EQUALS val= default_value )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:585:5: PARAMETER pt= param_type id= IDENTIFIER EQUALS val= default_value
        {
             MATCHT(PARAMETER, &FOLLOW_PARAMETER_in_parameter_declaration1169);
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_param_type_in_parameter_declaration1173);
            pt=param_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_parameter_declaration1177);
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


             MATCHT(EQUALS, &FOLLOW_EQUALS_in_parameter_declaration1180);
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_default_value_in_parameter_declaration1184);
            val=default_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }


            {

                			//store this information into lists maintained 
                			//per module_description
                			(SCOPE_TOP(du))->has_parameters=true;
                			assert((SCOPE_TOP(du))->param_name!=NULL);
                			assert((SCOPE_TOP(du))->param_type!=NULL);
                			assert((SCOPE_TOP(du))->param_value!=NULL);

                			(SCOPE_TOP(du))->param_type->push_back(std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, pt.start, pt.stop))
                ->chars)));
                			(SCOPE_TOP(du))->param_name->push_back(std::string((const char*)((id->getText(id))->chars)));
                			(SCOPE_TOP(du))->param_value->push_back(std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, val.start, val.stop))
                ->chars)));
                			
                			//the 3 lists should be in sync
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_value->size());
                			assert((SCOPE_TOP(du))->param_name->size()==(SCOPE_TOP(du))->param_type->size());

                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparameter_declarationEx; /* Prevent compiler warnings */
    ruleparameter_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parameter_declaration */

/**
 * $ANTLR start param_type
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:606:1: param_type : ( KEYWORD_INT | KEYWORD_BOOL | KEYWORD_CHAR );
 */
static sitarParser_param_type_return
param_type(psitarParser ctx)
{
    sitarParser_param_type_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:607:2: ( KEYWORD_INT | KEYWORD_BOOL | KEYWORD_CHAR )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:
        {
            if ( ((LA(1) >= KEYWORD_BOOL) && (LA(1) <= KEYWORD_INT)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleparam_typeEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparam_typeEx; /* Prevent compiler warnings */
    ruleparam_typeEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end param_type */

/**
 * $ANTLR start default_value
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:613:1: default_value : ( integer | BOOL | CHAR );
 */
static sitarParser_default_value_return
default_value(psitarParser ctx)
{
    sitarParser_default_value_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:614:2: ( integer | BOOL | CHAR )

            ANTLR3_UINT32 alt16;

            alt16=3;

            switch ( LA(1) )
            {
            case INTEGER:
            case MINUS:
            	{
            		alt16=1;
            	}
                break;
            case BOOL:
            	{
            		alt16=2;
            	}
                break;
            case CHAR:
            	{
            		alt16=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto ruledefault_valueEx;

            }

            switch (alt16)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:614:6: integer
        	    {
        	        FOLLOWPUSH(FOLLOW_integer_in_default_value1228);
        	        integer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_valueEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:614:16: BOOL
        	    {
        	         MATCHT(BOOL, &FOLLOW_BOOL_in_default_value1232);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_valueEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:614:23: CHAR
        	    {
        	         MATCHT(CHAR, &FOLLOW_CHAR_in_default_value1236);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_valueEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledefault_valueEx; /* Prevent compiler warnings */
    ruledefault_valueEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end default_value */

/**
 * $ANTLR start integer
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:616:1: integer : ( '-' )? INTEGER ;
 */
static void
integer(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:617:2: ( ( '-' )? INTEGER )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:618:2: ( '-' )? INTEGER
        {
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:618:2: ( '-' )?
            {
                int alt17=2;
                switch ( LA(1) )
                {
                    case MINUS:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:618:2: '-'
            	    {
            	         MATCHT(MINUS, &FOLLOW_MINUS_in_integer1248);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintegerEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(INTEGER, &FOLLOW_INTEGER_in_integer1251);
            if  (HASEXCEPTION())
            {
                goto ruleintegerEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleintegerEx; /* Prevent compiler warnings */
    ruleintegerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end integer */

/**
 * $ANTLR start port_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:629:1: port_declaration : ( inport_declaration | inport_array_declaration | outport_declaration | outport_array_declaration );
 */
static void
port_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_port_declarationTop = psitarParser_port_declarationPush(ctx);

    (SCOPE_TOP(port_declaration))->has_width=false;

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:638:2: ( inport_declaration | inport_array_declaration | outport_declaration | outport_array_declaration )

            ANTLR3_UINT32 alt18;

            alt18=4;

            switch ( LA(1) )
            {
            case INPORT:
            	{
            		alt18=1;
            	}
                break;
            case INPORT_ARRAY:
            	{
            		alt18=2;
            	}
                break;
            case OUTPORT:
            	{
            		alt18=3;
            	}
                break;
            case OUTPORT_ARRAY:
            	{
            		alt18=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleport_declarationEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:638:4: inport_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_inport_declaration_in_port_declaration1279);
        	        inport_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:639:4: inport_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_inport_array_declaration_in_port_declaration1284);
        	        inport_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:640:4: outport_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_outport_declaration_in_port_declaration1289);
        	        outport_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:641:4: outport_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_outport_array_declaration_in_port_declaration1294);
        	        outport_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleport_declarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleport_declarationEx; /* Prevent compiler warnings */
    ruleport_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    psitarParser_port_declarationPop(ctx);

    return ;
}
/* $ANTLR end port_declaration */

/**
 * $ANTLR start inport_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:646:1: inport_declaration : INPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? ;
 */
static void
inport_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;
    		

    id1       = NULL;
    id2       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:660:2: ( INPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:660:4: INPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )?
        {
             MATCHT(INPORT, &FOLLOW_INPORT_in_inport_declaration1319);
            if  (HASEXCEPTION())
            {
                goto ruleinport_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_inport_declaration1323);
            if  (HASEXCEPTION())
            {
                goto ruleinport_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:666:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt19=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt19=1;
                	}
                    break;

                }

                switch (alt19)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:666:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_inport_declaration1335);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_inport_declaration1339);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:671:7: ( COLON WIDTH e1= expression )?
            {
                int alt20=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:671:8: COLON WIDTH e1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_inport_declaration1353);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_inport_declaration1355);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_inport_declaration1359);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars));
                		else w = "0";
                					
                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                	 		
                			
                			//Add port as data member of module class
                			D_file<<"\ninport<"<<w<<"> "<<s<<";";
                	 		
                			//Initialize port attributes in the contructor
                			C_file<<"\n//---Initializing inport "<<s<<"---";
                			C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                			C_file<<"\naddInport(&"<<s<<",\""<<s<<"\");\n";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinport_declarationEx; /* Prevent compiler warnings */
    ruleinport_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//empty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end inport_declaration */

/**
 * $ANTLR start inport_array_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:695:1: inport_array_declaration : INPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? ;
 */
static void
inport_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_expression_return w1;
    #undef	RETURN_TYPE_w1
    #define	RETURN_TYPE_w1 sitarParser_expression_return

    /* Initialize rule variables
     */

     
    	int flag_2D=0;
    	std::string port;
    	std::string portij;
    	std::string pname;

    id1       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:710:2: ( INPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:710:4: INPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )?
        {
             MATCHT(INPORT_ARRAY, &FOLLOW_INPORT_ARRAY_in_inport_array_declaration1395);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_inport_array_declaration1399);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_inport_array_declaration1401);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_inport_array_declaration1405);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_inport_array_declaration1408);
            if  (HASEXCEPTION())
            {
                goto ruleinport_array_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:711:9: ( '[' e2= expression ']' )?
            {
                int alt21=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:711:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_inport_array_declaration1421);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_inport_array_declaration1425);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_inport_array_declaration1429);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:711:48: ( COLON WIDTH w1= expression )?
            {
                int alt22=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt22=1;
                    	}
                        break;
                }

                switch (alt22)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:711:49: COLON WIDTH w1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_inport_array_declaration1435);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_inport_array_declaration1437);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_inport_array_declaration1441);
            	        w1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinport_array_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width) 
                		  w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, w1.start, w1.stop))
                ->chars));
                		else w = "0";
                		
                		port=(std::string((const char*)((id1->getText(id1))->chars)));
                		
                		if(flag_2D==0)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"";
                			portij= port + "[i]";
                			
                			//Add port as data member to module class
                			D_file<<"\ninport<"<<w<<"> "<<port<<"["<<
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"];";


                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing inport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddInport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n";

                		}
                		else if(flag_2D==1)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                			portij= port + "[i][j]";
                				
                			//Add port as data member to module class
                			D_file<<"\ninport<"<<w<<"> "<<port<<"["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"];";

                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing inport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddInport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n}\n";
                		}

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinport_array_declarationEx; /* Prevent compiler warnings */
    ruleinport_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;

                }
            }


    return ;
}
/* $ANTLR end inport_array_declaration */

/**
 * $ANTLR start outport_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:759:1: outport_declaration : OUTPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? ;
 */
static void
outport_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;

    id1       = NULL;
    id2       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:772:2: ( OUTPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:772:4: OUTPORT id1= IDENTIFIER ( ',' id2= IDENTIFIER )* ( COLON WIDTH e1= expression )?
        {
             MATCHT(OUTPORT, &FOLLOW_OUTPORT_in_outport_declaration1473);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_outport_declaration1477);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:778:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt23=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt23=1;
                	}
                    break;

                }

                switch (alt23)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:778:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_outport_declaration1489);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_outport_declaration1493);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:783:7: ( COLON WIDTH e1= expression )?
            {
                int alt24=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt24=1;
                    	}
                        break;
                }

                switch (alt24)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:783:8: COLON WIDTH e1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_outport_declaration1507);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_outport_declaration1509);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_outport_declaration1513);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars));
                		else w = "0";
                			
                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                	 		
                			
                			//Add port as data member to module class
                			D_file<<"\noutport<"<<w<<"> "<<s<<";";
                	 		
                			//Initialize port attributes in the contructor
                			C_file<<"\n//---Initializing outport "<<s<<"---";
                			C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                			C_file<<"\naddOutport(&"<<s<<",\""<<s<<"\");\n";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoutport_declarationEx; /* Prevent compiler warnings */
    ruleoutport_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//Empty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end outport_declaration */

/**
 * $ANTLR start outport_array_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:807:1: outport_array_declaration : OUTPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? ;
 */
static void
outport_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_expression_return w1;
    #undef	RETURN_TYPE_w1
    #define	RETURN_TYPE_w1 sitarParser_expression_return

    /* Initialize rule variables
     */

     
    	int flag_2D=0;
    	std::string port;
    	std::string portij;
    	std::string pname;

    id1       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:822:2: ( OUTPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:822:4: OUTPORT_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? ( COLON WIDTH w1= expression )?
        {
             MATCHT(OUTPORT_ARRAY, &FOLLOW_OUTPORT_ARRAY_in_outport_array_declaration1547);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_outport_array_declaration1551);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_outport_array_declaration1553);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_outport_array_declaration1557);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_outport_array_declaration1560);
            if  (HASEXCEPTION())
            {
                goto ruleoutport_array_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:823:9: ( '[' e2= expression ']' )?
            {
                int alt25=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt25=1;
                    	}
                        break;
                }

                switch (alt25)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:823:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_outport_array_declaration1573);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_outport_array_declaration1577);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_outport_array_declaration1581);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:823:49: ( COLON WIDTH w1= expression )?
            {
                int alt26=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt26=1;
                    	}
                        break;
                }

                switch (alt26)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:823:50: COLON WIDTH w1= expression
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_outport_array_declaration1588);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_outport_array_declaration1590);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_outport_array_declaration1594);
            	        w1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoutport_array_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(port_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(port_declaration))->has_width==true) 
                		 w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, w1.start, w1.stop))
                ->chars));
                		else w = "0";
                		port=(std::string((const char*)((id1->getText(id1))->chars)));
                		
                		if(flag_2D==0)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"";
                			portij= port + "[i]";
                			
                			//Add port as data member to module class
                			D_file<<"\noutport<"<<w<<"> "<<port<<"["<<
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"];";

                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing outport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddOutport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n";

                		}
                		else if(flag_2D==1)
                		{
                			pname="\""+port+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                			portij= port + "[i][j]";
                				
                			//Add port as data member to module class
                			D_file<<"\noutport<"<<w<<"> "<<port<<"["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"];";

                			//Initialize port attributes in the contructor
                			C_file<<"\n//----Initializing outport-array "<<port<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			C_file<<"\nstd::string pname="<<pname<<";";
                			C_file<<"\n"<<portij<<".setInstanceId(pname);";
                			C_file<<"\naddOutport(&"<<portij<<","<<pname<<");\n";
                			C_file<<"\n}\n}\n";
                		}

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoutport_array_declarationEx; /* Prevent compiler warnings */
    ruleoutport_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;

                }
            }


    return ;
}
/* $ANTLR end outport_array_declaration */

/**
 * $ANTLR start net_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:881:1: net_declaration : ( simple_net_declaration | net_array_declaration );
 */
static void
net_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_net_declarationTop = psitarParser_net_declarationPush(ctx);

    (SCOPE_TOP(net_declaration))->has_width=false;

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:890:2: ( simple_net_declaration | net_array_declaration )

            ANTLR3_UINT32 alt27;

            alt27=2;

            switch ( LA(1) )
            {
            case NET:
            	{
            		alt27=1;
            	}
                break;
            case NET_ARRAY:
            	{
            		alt27=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto rulenet_declarationEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:890:4: simple_net_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_simple_net_declaration_in_net_declaration1633);
        	        simple_net_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenet_declarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:891:4: net_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_net_array_declaration_in_net_declaration1638);
        	        net_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenet_declarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulenet_declarationEx; /* Prevent compiler warnings */
    rulenet_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    psitarParser_net_declarationPop(ctx);

    return ;
}
/* $ANTLR end net_declaration */

/**
 * $ANTLR start simple_net_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:895:1: simple_net_declaration : NET id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON CAPACITY c= expression ( WIDTH e1= expression )? ;
 */
static void
simple_net_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    sitarParser_expression_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_expression_return

    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;

    id1       = NULL;
    id2       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:909:2: ( NET id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON CAPACITY c= expression ( WIDTH e1= expression )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:909:4: NET id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON CAPACITY c= expression ( WIDTH e1= expression )?
        {
             MATCHT(NET, &FOLLOW_NET_in_simple_net_declaration1663);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_net_declaration1668);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:915:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt28=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt28=1;
                	}
                    break;

                }

                switch (alt28)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:915:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_simple_net_declaration1680);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_net_declaration1684);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop28;	/* break out of the loop */
            	    break;
                }
            }
            loop28: ; /* Jump out to here if this rule does not match */


             MATCHT(COLON, &FOLLOW_COLON_in_simple_net_declaration1702);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


             MATCHT(CAPACITY, &FOLLOW_CAPACITY_in_simple_net_declaration1704);
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_simple_net_declaration1709);
            c=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimple_net_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:923:3: ( WIDTH e1= expression )?
            {
                int alt29=2;
                switch ( LA(1) )
                {
                    case WIDTH:
                    	{
                    		alt29=1;
                    	}
                        break;
                }

                switch (alt29)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:923:4: WIDTH e1= expression
            	    {
            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_simple_net_declaration1716);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_simple_net_declaration1720);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_net_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(net_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(net_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars));
                		else w = "0";
                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                	 		
                			
                			//Add net as data member to module class
                			D_file<<"\nnet<"<<w<<"> "<<s<<";"; 					//net
                			D_file<<"\ntoken<"<<w<<"> "<<s<<"_buffer["<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<"];";	//token buffer for net
                	 		
                			//Initialize port attributes in the contructor
                			C_file<<"\n//---Initializing net "<<s<<"---";
                			C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                			C_file<<"\n"<<s<<".setBuffer("<<s<<"_buffer,"<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<");";
                			C_file<<"\naddNet(&"<<s<<",\""<<s<<"\");\n";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimple_net_declarationEx; /* Prevent compiler warnings */
    rulesimple_net_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end simple_net_declaration */

/**
 * $ANTLR start net_array_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:948:1: net_array_declaration : NET_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON CAPACITY c= expression ( WIDTH e11= expression )? ;
 */
static void
net_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_expression_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_expression_return

    sitarParser_expression_return e11;
    #undef	RETURN_TYPE_e11
    #define	RETURN_TYPE_e11 sitarParser_expression_return

    /* Initialize rule variables
     */

     
    	int flag_2D=0; //0 implies net array is 1 dimensional, else 2-dimensional
    	std::string net;
    	std::string netij;
    	std::string nname;

    id1       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:962:2: ( NET_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON CAPACITY c= expression ( WIDTH e11= expression )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:962:4: NET_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON CAPACITY c= expression ( WIDTH e11= expression )?
        {
             MATCHT(NET_ARRAY, &FOLLOW_NET_ARRAY_in_net_array_declaration1753);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_net_array_declaration1757);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_net_array_declaration1759);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1763);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_net_array_declaration1766);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:963:9: ( '[' e2= expression ']' )?
            {
                int alt30=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt30=1;
                    	}
                        break;
                }

                switch (alt30)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:963:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_net_array_declaration1779);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1783);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_net_array_declaration1787);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(COLON, &FOLLOW_COLON_in_net_array_declaration1791);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


             MATCHT(CAPACITY, &FOLLOW_CAPACITY_in_net_array_declaration1793);
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1797);
            c=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenet_array_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:964:9: ( WIDTH e11= expression )?
            {
                int alt31=2;
                switch ( LA(1) )
                {
                    case WIDTH:
                    	{
                    		alt31=1;
                    	}
                        break;
                }

                switch (alt31)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:964:10: WIDTH e11= expression
            	    {
            	         MATCHT(WIDTH, &FOLLOW_WIDTH_in_net_array_declaration1809);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_net_array_declaration1813);
            	        e11=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenet_array_declarationEx;
            	        }


            	        {
            	            (SCOPE_TOP(net_declaration))->has_width=true;
            	        }


            	    }
            	    break;

                }
            }

            {

                		std::string w;
                		if((SCOPE_TOP(net_declaration))->has_width==true) w = std::string((const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e11.start, e11.stop))
                ->chars));
                		else w = "0";
                		net=(std::string((const char*)((id1->getText(id1))->chars)));
                		
                		if(flag_2D==0)
                		{
                			nname="\""+net+"[\"+sitar::toString(i)+\"]\"";
                			netij= net + "[i]";
                			
                			//Add net as data member to module class
                			D_file<<"\nnet<"<<w<<"> "<<net<<"["<<
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"];";
                			D_file<<"\ntoken<"<<w<<"> "<<net<<"_buffer["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<"];";	//token buffer for net

                			//Initialize net attributes in the contructor
                			C_file<<"\n//----Initializing net-array "<<net<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nstd::string nname="<<nname<<";";
                			C_file<<"\n"<<netij<<".setInstanceId(nname);";
                			C_file<<"\n"<<netij<<".setBuffer("<<net<<"_buffer[i],"<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<");";
                			C_file<<"\naddNet(&"<<netij<<","<<nname<<");\n";
                			C_file<<"\n}\n";

                		}
                		else if(flag_2D==1)
                		{
                			nname="\""+net+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                			netij= net + "[i][j]";
                				
                			//Add net as data member to module class
                			D_file<<"\nnet<"<<w<<"> "<<net<<"["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"];";
                			D_file<<"\ntoken<"<<w<<"> "<<net<<"_buffer["<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<"]["<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<"];";	//token buffer for net

                			//Initialize net attributes in the contructor
                			C_file<<"\n//----Initializing net-array "<<net<<"------";
                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			C_file<<"\nstd::string nname="<<nname<<";";
                			C_file<<"\n"<<netij<<".setInstanceId(nname);";
                			C_file<<"\n"<<netij<<".setBuffer("<<net<<"_buffer[i][j],"<<(STRSTREAM->toStringTT(STRSTREAM, c.start, c.stop))
                ->chars<<");";
                			C_file<<"\naddNet(&"<<netij<<","<<nname<<");\n";
                			C_file<<"\n}\n}\n";
                		}

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenet_array_declarationEx; /* Prevent compiler warnings */
    rulenet_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;

                }
            }


    return ;
}
/* $ANTLR end net_array_declaration */

/**
 * $ANTLR start submodule_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1017:1: submodule_declaration : ( simple_submodule_declaration | submodule_array_declaration );
 */
static void
submodule_declaration(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1018:2: ( simple_submodule_declaration | submodule_array_declaration )

            ANTLR3_UINT32 alt32;

            alt32=2;

            switch ( LA(1) )
            {
            case SUBMODULE:
            	{
            		alt32=1;
            	}
                break;
            case SUBMODULE_ARRAY:
            	{
            		alt32=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 32;
                EXCEPTION->state        = 0;


                goto rulesubmodule_declarationEx;

            }

            switch (alt32)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1018:4: simple_submodule_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_simple_submodule_declaration_in_submodule_declaration1835);
        	        simple_submodule_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesubmodule_declarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1019:4: submodule_array_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_submodule_array_declaration_in_submodule_declaration1840);
        	        submodule_array_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesubmodule_declarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesubmodule_declarationEx; /* Prevent compiler warnings */
    rulesubmodule_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end submodule_declaration */

/**
 * $ANTLR start simple_submodule_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1024:1: simple_submodule_declaration : SUBMODULE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? ;
 */
static void
simple_submodule_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    pANTLR3_COMMON_TOKEN    mod_type;
    sitarParser_template_arguments_return template_arguments1;
    #undef	RETURN_TYPE_template_arguments1
    #define	RETURN_TYPE_template_arguments1 sitarParser_template_arguments_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;
    	std::string mname; //name/type of the submodule
    	std::string fname; //name of file that contains submodule description
    	bool flag1=0;	   //flag1==1 indicates the submodule has template arguments.
    	bool flag2=0;

    id1       = NULL;
    id2       = NULL;
    mod_type       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1042:2: ( SUBMODULE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1042:4: SUBMODULE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )?
        {
             MATCHT(SUBMODULE, &FOLLOW_SUBMODULE_in_simple_submodule_declaration1864);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_submodule_declaration1868);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1048:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt33=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt33=1;
                	}
                    break;

                }

                switch (alt33)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1048:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_simple_submodule_declaration1880);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_submodule_declaration1884);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop33;	/* break out of the loop */
            	    break;
                }
            }
            loop33: ; /* Jump out to here if this rule does not match */


             MATCHT(COLON, &FOLLOW_COLON_in_simple_submodule_declaration1902);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            mod_type = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simple_submodule_declaration1906);
            if  (HASEXCEPTION())
            {
                goto rulesimple_submodule_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1055:29: ( '<' ( template_arguments )? '>' )?
            {
                int alt35=2;
                switch ( LA(1) )
                {
                    case 78:
                    	{
                    		alt35=1;
                    	}
                        break;
                }

                switch (alt35)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1055:30: '<' ( template_arguments )? '>'
            	    {
            	         MATCHT(78, &FOLLOW_78_in_simple_submodule_declaration1909);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1055:34: ( template_arguments )?
            	        {
            	            int alt34=2;
            	            switch ( LA(1) )
            	            {
            	                case BOOL:
            	                case CHAR:
            	                case IDENTIFIER:
            	                case INTEGER:
            	                case MINUS:
            	                case STRING:
            	                case 72:
            	                	{
            	                		alt34=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt34)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1055:35: template_arguments
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_template_arguments_in_simple_submodule_declaration1912);
            	        	        template_arguments1=template_arguments(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesimple_submodule_declarationEx;
            	        	        }


            	        	        {
            	        	            flag2=1;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(80, &FOLLOW_80_in_simple_submodule_declaration1917);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_submodule_declarationEx;
            	        }


            	        {
            	            flag1=1;
            	        }


            	    }
            	    break;

                }
            }

            {

                			//Generate type-name of the module
                			fname= (const char*)((mod_type->getText(mod_type))->chars);
                			mname=fname;
                			if(flag1==1)
                			{
                			  mname=mname+"<" ;
                			  if(flag2==1)
                			  	mname=mname +(const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, template_arguments1.start, template_arguments1.stop))
                ->chars);
                			  mname=mname+">";
                			  }
                			
                                                                                         //Include the header that contains description of
                			//Submodule
                			I_file<<"\n#include\""<<OUTPUT_FILE_PREFIX_STR<<fname<<".h\"";
                			
                	        	while(!list1.empty())
                	 	 	{
                				s = list1.front();
                				list1.pop_front();

                								
                				//Add Submodule as data member of module class
                				D_file<<"\n"<<mname<<" "<<s<<";";
                				
                				
                				
                				//Initialize Submodule instance in the contructor
                				C_file<<"\n//---Initializing submodule "<<s<<"---";
                				C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                				C_file<<"\naddSubmodule(&"<<s<<",\""<<s<<"\");\n";
                	 	 	}
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimple_submodule_declarationEx; /* Prevent compiler warnings */
    rulesimple_submodule_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();
                    	flag1=0;
                    	flag2=0;

                }
            }


    return ;
}
/* $ANTLR end simple_submodule_declaration */

/**
 * $ANTLR start template_arguments
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1091:1: template_arguments : argument ( ',' argument )* ;
 */
static sitarParser_template_arguments_return
template_arguments(psitarParser ctx)
{
    sitarParser_template_arguments_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1092:2: ( argument ( ',' argument )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1092:4: argument ( ',' argument )*
        {
            FOLLOWPUSH(FOLLOW_argument_in_template_arguments1938);
            argument(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletemplate_argumentsEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1092:13: ( ',' argument )*

            for (;;)
            {
                int alt36=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt36=1;
                	}
                    break;

                }

                switch (alt36)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1092:14: ',' argument
            	    {
            	         MATCHT(75, &FOLLOW_75_in_template_arguments1941);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletemplate_argumentsEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_argument_in_template_arguments1943);
            	        argument(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletemplate_argumentsEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletemplate_argumentsEx; /* Prevent compiler warnings */
    ruletemplate_argumentsEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end template_arguments */

/**
 * $ANTLR start argument
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1094:1: argument : ( BOOL | CHAR | STRING | expression );
 */
static void
argument(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1095:2: ( BOOL | CHAR | STRING | expression )

            ANTLR3_UINT32 alt37;

            alt37=4;

            switch ( LA(1) )
            {
            case BOOL:
            	{
            		alt37=1;
            	}
                break;
            case CHAR:
            	{
            		alt37=2;
            	}
                break;
            case STRING:
            	{
            		alt37=3;
            	}
                break;
            case IDENTIFIER:
            case INTEGER:
            case MINUS:
            case 72:
            	{
            		alt37=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 37;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;

            }

            switch (alt37)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1095:5: BOOL
        	    {
        	         MATCHT(BOOL, &FOLLOW_BOOL_in_argument1957);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1095:12: CHAR
        	    {
        	         MATCHT(CHAR, &FOLLOW_CHAR_in_argument1961);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1095:19: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_argument1965);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1095:28: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_argument1969);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end argument */

/**
 * $ANTLR start submodule_array_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1101:1: submodule_array_declaration : SUBMODULE_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON mod_type= IDENTIFIER ( '<' (t= template_arguments )? '>' )? ;
 */
static void
submodule_array_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    mod_type;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    sitarParser_template_arguments_return t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t sitarParser_template_arguments_return

    /* Initialize rule variables
     */

     
    	bool flag_2D=0; //1 implies array is 2-dimensional, else 1D
    	bool flag1=0; //1 implies submodule takes template arguments
    	bool flag2=0;


    	
    	//generate some handy strings for translation
    	//Eg. for input
    	//sr[2][3] :ShiftRegister<4>


    	//iname=sr[2][3]        instance name -goes into declaration
    	//inameij=sr[i][j]      for initilalizing the array inside a for loop
    	//inamestring="sr[" + "sitar::toString(i)" +"]".... ->for creating
    	//			an instance name at elaboration time
    	//tname=ShiftRegister<4> type name
    	//fname=ShiftRegister   Goes into the includes region as
    	//			#include"sitar_ShiftRegister.h"


    	std::string iname0;
    	std::string iname;
    	std::string inameij;
    	std::string inamestring;
    	std::string tname;
    	std::string fname;

    id1       = NULL;
    mod_type       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1141:2: ( SUBMODULE_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON mod_type= IDENTIFIER ( '<' (t= template_arguments )? '>' )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1141:4: SUBMODULE_ARRAY id1= IDENTIFIER '[' e1= expression ']' ( '[' e2= expression ']' )? COLON mod_type= IDENTIFIER ( '<' (t= template_arguments )? '>' )?
        {
             MATCHT(SUBMODULE_ARRAY, &FOLLOW_SUBMODULE_ARRAY_in_submodule_array_declaration1997);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_submodule_array_declaration2001);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


             MATCHT(82, &FOLLOW_82_in_submodule_array_declaration2003);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_submodule_array_declaration2007);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


             MATCHT(83, &FOLLOW_83_in_submodule_array_declaration2010);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1142:9: ( '[' e2= expression ']' )?
            {
                int alt38=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt38=1;
                    	}
                        break;
                }

                switch (alt38)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1142:10: '[' e2= expression ']'
            	    {
            	         MATCHT(82, &FOLLOW_82_in_submodule_array_declaration2023);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_submodule_array_declaration2027);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        {
            	            flag_2D=1;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_submodule_array_declaration2031);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(COLON, &FOLLOW_COLON_in_submodule_array_declaration2053);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            mod_type = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_submodule_array_declaration2057);
            if  (HASEXCEPTION())
            {
                goto rulesubmodule_array_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1144:36: ( '<' (t= template_arguments )? '>' )?
            {
                int alt40=2;
                switch ( LA(1) )
                {
                    case 78:
                    	{
                    		alt40=1;
                    	}
                        break;
                }

                switch (alt40)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1144:37: '<' (t= template_arguments )? '>'
            	    {
            	         MATCHT(78, &FOLLOW_78_in_submodule_array_declaration2061);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1144:41: (t= template_arguments )?
            	        {
            	            int alt39=2;
            	            switch ( LA(1) )
            	            {
            	                case BOOL:
            	                case CHAR:
            	                case IDENTIFIER:
            	                case INTEGER:
            	                case MINUS:
            	                case STRING:
            	                case 72:
            	                	{
            	                		alt39=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt39)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1144:42: t= template_arguments
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_template_arguments_in_submodule_array_declaration2066);
            	        	        t=template_arguments(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesubmodule_array_declarationEx;
            	        	        }


            	        	        {
            	        	            flag2=1;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(80, &FOLLOW_80_in_submodule_array_declaration2072);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubmodule_array_declarationEx;
            	        }


            	        {
            	            flag1=1;
            	        }


            	    }
            	    break;

                }
            }

            {

                		fname=(const char*)((mod_type->getText(mod_type))->chars);
                		tname=fname;
                		if(flag1==1)
                		{
                			tname=tname+"<";
                			if(flag2==1)
                			 tname+=(const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, t.start, t.stop))
                ->chars);
                			tname+=">";
                		}
                		
                		//Include the header that contains description of
                		//Submodule
                		I_file<<"\n#include\""<<OUTPUT_FILE_PREFIX_STR<<fname<<".h\"";


                		
                		
                		if(flag_2D==1)
                		{
                			iname0=std::string((const char*)((id1->getText(id1))->chars) );
                			iname=iname0+ "[" + (const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars) + "][" + (const char *) ((STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars) + "]";
                			inameij=iname0+"[i][j]";
                			inamestring="\""+iname0+"[\"+sitar::toString(i)+\"]\"+\"[\"+sitar::toString(j)+\"]\"";
                				
                			//Add module as data member to module class
                			D_file<<"\n"<<tname<<" "<<iname<<";"; 

                			//Initialize module attributes in the contructor
                			C_file<<"\n//----Initializing module-array "<<fname<<"------";

                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			C_file<<"\nfor(int j=0;j<("<<(STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");j++)\n{\n";
                			
                			C_file<<"\n"<<inameij<<".setInstanceId("<<inamestring<<");";
                			C_file<<"\naddSubmodule(&"<<inameij<<","<<inamestring<<");\n";
                			C_file<<"\n}\n}\n";
                		}
                		else if(flag_2D==0)
                		{
                			iname0=std::string((const char*)((id1->getText(id1))->chars) );
                			iname=iname0+"[" + (const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars) + "]";
                			inameij=iname0+"[i]";
                			inamestring="\""+iname0+"[\"+sitar::toString(i)+\"]\"";
                				
                			
                				
                			//Add module as data member to module class
                			D_file<<"\n"<<tname<<" "<<iname<<";"; 

                			//Initialize module attributes in the contructor
                			C_file<<"\n//----Initializing module-array "<<fname<<"------";

                			C_file<<"\nfor(int i=0;i<("<<(STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars<<");i++)\n{\n";
                			
                			C_file<<"\n"<<inameij<<".setInstanceId("<<inamestring<<");";
                			C_file<<"\naddSubmodule(&"<<inameij<<","<<inamestring<<");\n";
                			C_file<<"\n}\n";
                		}
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubmodule_array_declarationEx; /* Prevent compiler warnings */
    rulesubmodule_array_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     
                    	flag_2D=0;
                    	flag1=0;
                    	flag2=0;

                }
            }


    return ;
}
/* $ANTLR end submodule_array_declaration */

/**
 * $ANTLR start procedure_declaration
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1209:1: procedure_declaration : PROCEDURE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? ;
 */
static void
procedure_declaration(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    pANTLR3_COMMON_TOKEN    mod_type;
    sitarParser_template_arguments_return template_arguments2;
    #undef	RETURN_TYPE_template_arguments2
    #define	RETURN_TYPE_template_arguments2 sitarParser_template_arguments_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;
    	std::string mname; //name/type of the  procedure
    	std::string fname; //name of file that contains procedure description
    	bool flag1=0;	   //flag1==1 indicates the procedure has template arguments.
    	bool flag2=0;

    id1       = NULL;
    id2       = NULL;
    mod_type       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1227:2: ( PROCEDURE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1227:4: PROCEDURE id1= IDENTIFIER ( ',' id2= IDENTIFIER )* COLON mod_type= IDENTIFIER ( '<' ( template_arguments )? '>' )?
        {
             MATCHT(PROCEDURE, &FOLLOW_PROCEDURE_in_procedure_declaration2105);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_declaration2112);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            {

                			s=std::string((const char*)((id1->getText(id1))->chars));  
                			list1.push_back(s);
                		
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1233:3: ( ',' id2= IDENTIFIER )*

            for (;;)
            {
                int alt41=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt41=1;
                	}
                    break;

                }

                switch (alt41)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1233:4: ',' id2= IDENTIFIER
            	    {
            	         MATCHT(75, &FOLLOW_75_in_procedure_declaration2124);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_declaration2128);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        {

            	            			s=std::string((const char*)((id2->getText(id2))->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


             MATCHT(COLON, &FOLLOW_COLON_in_procedure_declaration2146);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            mod_type = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_procedure_declaration2150);
            if  (HASEXCEPTION())
            {
                goto ruleprocedure_declarationEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1240:29: ( '<' ( template_arguments )? '>' )?
            {
                int alt43=2;
                switch ( LA(1) )
                {
                    case 78:
                    	{
                    		alt43=1;
                    	}
                        break;
                }

                switch (alt43)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1240:30: '<' ( template_arguments )? '>'
            	    {
            	         MATCHT(78, &FOLLOW_78_in_procedure_declaration2153);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1240:34: ( template_arguments )?
            	        {
            	            int alt42=2;
            	            switch ( LA(1) )
            	            {
            	                case BOOL:
            	                case CHAR:
            	                case IDENTIFIER:
            	                case INTEGER:
            	                case MINUS:
            	                case STRING:
            	                case 72:
            	                	{
            	                		alt42=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt42)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1240:35: template_arguments
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_template_arguments_in_procedure_declaration2156);
            	        	        template_arguments2=template_arguments(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprocedure_declarationEx;
            	        	        }


            	        	        {
            	        	            flag2=1;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(80, &FOLLOW_80_in_procedure_declaration2161);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedure_declarationEx;
            	        }


            	        {
            	            flag1=1;
            	        }


            	    }
            	    break;

                }
            }

            {

                			//Generate type-name of the module
                			fname= (const char*)((mod_type->getText(mod_type))->chars);
                			mname=fname;
                			if(flag1==1)
                			{
                			  mname=mname+"<" ;
                			  if(flag2==1)
                			  	mname=mname +(const char*)(
                (STRSTREAM->toStringTT(STRSTREAM, template_arguments2.start, template_arguments2.stop))
                ->chars);
                			  mname=mname+">";
                			  }
                			

                			
                	        	while(!list1.empty())
                	 	 	{
                				s = list1.front();
                				list1.pop_front();

                				//Include the header that contains description of
                				//procedure
                				I_file<<"\n#include\""<<OUTPUT_FILE_PREFIX_STR<<fname<<".h\"";
                				
                				
                				//Add Submodule as data member of module class
                				D_file<<"\n"<<mname<<" "<<s<<";";
                				
                				
                				
                				//Initialize Submodule instance in the contructor
                				C_file<<"\n//---Initializing procedure instance "<<s<<"---";
                				C_file<<"\n"<<s<<".setInstanceId(\""<<s<<"\");";
                				C_file<<"\naddProcedure(&"<<s<<",\""<<s<<"\");\n";
                	 	 	}
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprocedure_declarationEx; /* Prevent compiler warnings */
    ruleprocedure_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();
                    	flag1=0;
                    	flag2=0;

                }
            }


    return ;
}
/* $ANTLR end procedure_declaration */

/**
 * $ANTLR start connection
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1285:1: connection : ( simple_connect_statement | for_loop_for_connections );
 */
static void
connection(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1286:2: ( simple_connect_statement | for_loop_for_connections )

            ANTLR3_UINT32 alt44;

            alt44=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt44=1;
            	}
                break;
            case FOR:
            	{
            		alt44=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 44;
                EXCEPTION->state        = 0;


                goto ruleconnectionEx;

            }

            switch (alt44)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1286:4: simple_connect_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_simple_connect_statement_in_connection2189);
        	        simple_connect_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconnectionEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1287:4: for_loop_for_connections
        	    {
        	        FOLLOWPUSH(FOLLOW_for_loop_for_connections_in_connection2195);
        	        for_loop_for_connections(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconnectionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleconnectionEx; /* Prevent compiler warnings */
    ruleconnectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end connection */

/**
 * $ANTLR start simple_connect_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1294:1: simple_connect_statement : id1= port_instance_name ( ',' id2= port_instance_name )* ( CONNECT_LEFT | CONNECT_RIGHT ) n1= net_instance_name ;
 */
static void
simple_connect_statement(psitarParser ctx)
{
    sitarParser_port_instance_name_return id1;
    #undef	RETURN_TYPE_id1
    #define	RETURN_TYPE_id1 sitarParser_port_instance_name_return

    sitarParser_port_instance_name_return id2;
    #undef	RETURN_TYPE_id2
    #define	RETURN_TYPE_id2 sitarParser_port_instance_name_return

    sitarParser_net_instance_name_return n1;
    #undef	RETURN_TYPE_n1
    #define	RETURN_TYPE_n1 sitarParser_net_instance_name_return

    /* Initialize rule variables
     */


    	//Declare a list of identifiers
    	std::list<std::string> list1;
    	std::string s;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1307:2: (id1= port_instance_name ( ',' id2= port_instance_name )* ( CONNECT_LEFT | CONNECT_RIGHT ) n1= net_instance_name )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1307:4: id1= port_instance_name ( ',' id2= port_instance_name )* ( CONNECT_LEFT | CONNECT_RIGHT ) n1= net_instance_name
        {
            FOLLOWPUSH(FOLLOW_port_instance_name_in_simple_connect_statement2225);
            id1=port_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimple_connect_statementEx;
            }


            {

                			s=std::string((const char*)((STRSTREAM->toStringTT(STRSTREAM, id1.start, id1.stop))
                ->chars));  
                			list1.push_back(s);
                		
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1313:3: ( ',' id2= port_instance_name )*

            for (;;)
            {
                int alt45=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt45=1;
                	}
                    break;

                }

                switch (alt45)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1313:4: ',' id2= port_instance_name
            	    {
            	         MATCHT(75, &FOLLOW_75_in_simple_connect_statement2239);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_connect_statementEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_port_instance_name_in_simple_connect_statement2243);
            	        id2=port_instance_name(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_connect_statementEx;
            	        }


            	        {

            	            			s=std::string((const char*)((STRSTREAM->toStringTT(STRSTREAM, id2.start, id2.stop))
            	            ->chars)); 
            	            			list1.push_back(s);
            	            		
            	        }


            	    }
            	    break;

            	default:
            	    goto loop45;	/* break out of the loop */
            	    break;
                }
            }
            loop45: ; /* Jump out to here if this rule does not match */


            if ( ((LA(1) >= CONNECT_LEFT) && (LA(1) <= CONNECT_RIGHT)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulesimple_connect_statementEx;
            }


            FOLLOWPUSH(FOLLOW_net_instance_name_in_simple_connect_statement2270);
            n1=net_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimple_connect_statementEx;
            }


            {

                	        	while(!list1.empty())
                	 	 	{
                	 		s = list1.front();
                	 		list1.pop_front();
                			
                			//Connect port to net, inside the constructor.
                			C_file<<"\n"<<s<<".setNet(&";
                			C_file<<((STRSTREAM->toStringTT(STRSTREAM, n1.start, n1.stop))
                ->chars)<<");";
                	 	 	};
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimple_connect_statementEx; /* Prevent compiler warnings */
    rulesimple_connect_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//cmpty the list
                    	list1.clear();

                }
            }


    return ;
}
/* $ANTLR end simple_connect_statement */

/**
 * $ANTLR start port_instance_name
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1336:1: port_instance_name : hierarchical_instance_name ;
 */
static sitarParser_port_instance_name_return
port_instance_name(psitarParser ctx)
{
    sitarParser_port_instance_name_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1337:2: ( hierarchical_instance_name )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1337:5: hierarchical_instance_name
        {
            FOLLOWPUSH(FOLLOW_hierarchical_instance_name_in_port_instance_name2292);
            hierarchical_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleport_instance_nameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleport_instance_nameEx; /* Prevent compiler warnings */
    ruleport_instance_nameEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end port_instance_name */

/**
 * $ANTLR start net_instance_name
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1339:1: net_instance_name : hierarchical_instance_name ;
 */
static sitarParser_net_instance_name_return
net_instance_name(psitarParser ctx)
{
    sitarParser_net_instance_name_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1340:2: ( hierarchical_instance_name )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1340:5: hierarchical_instance_name
        {
            FOLLOWPUSH(FOLLOW_hierarchical_instance_name_in_net_instance_name2307);
            hierarchical_instance_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenet_instance_nameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenet_instance_nameEx; /* Prevent compiler warnings */
    rulenet_instance_nameEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end net_instance_name */

/**
 * $ANTLR start hierarchical_instance_name
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1343:1: hierarchical_instance_name : object_name ( ( DOT | SCOPE | POINTER ) object_name )* ;
 */
static void
hierarchical_instance_name(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1344:2: ( object_name ( ( DOT | SCOPE | POINTER ) object_name )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1344:4: object_name ( ( DOT | SCOPE | POINTER ) object_name )*
        {
            FOLLOWPUSH(FOLLOW_object_name_in_hierarchical_instance_name2320);
            object_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehierarchical_instance_nameEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1344:15: ( ( DOT | SCOPE | POINTER ) object_name )*

            for (;;)
            {
                int alt46=2;
                switch ( LA(1) )
                {
                case DOT:
                case POINTER:
                case SCOPE:
                	{
                		alt46=1;
                	}
                    break;

                }

                switch (alt46)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1344:16: ( DOT | SCOPE | POINTER ) object_name
            	    {
            	        if ( LA(1) == DOT || LA(1) == POINTER || LA(1) == SCOPE )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto rulehierarchical_instance_nameEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_object_name_in_hierarchical_instance_name2330);
            	        object_name(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehierarchical_instance_nameEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop46;	/* break out of the loop */
            	    break;
                }
            }
            loop46: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulehierarchical_instance_nameEx; /* Prevent compiler warnings */
    rulehierarchical_instance_nameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end hierarchical_instance_name */

/**
 * $ANTLR start object_name
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1346:1: object_name : IDENTIFIER ( '[' expression ']' ( '[' expression ']' )? )? ;
 */
static void
object_name(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1347:2: ( IDENTIFIER ( '[' expression ']' ( '[' expression ']' )? )? )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1347:4: IDENTIFIER ( '[' expression ']' ( '[' expression ']' )? )?
        {
             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_object_name2344);
            if  (HASEXCEPTION())
            {
                goto ruleobject_nameEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1347:15: ( '[' expression ']' ( '[' expression ']' )? )?
            {
                int alt48=2;
                switch ( LA(1) )
                {
                    case 82:
                    	{
                    		alt48=1;
                    	}
                        break;
                }

                switch (alt48)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1347:16: '[' expression ']' ( '[' expression ']' )?
            	    {
            	         MATCHT(82, &FOLLOW_82_in_object_name2347);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobject_nameEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_object_name2348);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobject_nameEx;
            	        }


            	         MATCHT(83, &FOLLOW_83_in_object_name2350);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobject_nameEx;
            	        }


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1347:34: ( '[' expression ']' )?
            	        {
            	            int alt47=2;
            	            switch ( LA(1) )
            	            {
            	                case 82:
            	                	{
            	                		alt47=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt47)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1347:35: '[' expression ']'
            	        	    {
            	        	         MATCHT(82, &FOLLOW_82_in_object_name2353);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleobject_nameEx;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_expression_in_object_name2354);
            	        	        expression(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleobject_nameEx;
            	        	        }


            	        	         MATCHT(83, &FOLLOW_83_in_object_name2356);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleobject_nameEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleobject_nameEx; /* Prevent compiler warnings */
    ruleobject_nameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end object_name */

/**
 * $ANTLR start for_loop_for_connections
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1358:1: for_loop_for_connections : FOR id= IDENTIFIER IN e1= expression TO e2= expression ( connection )+ END FOR ;
 */
static void
for_loop_for_connections(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    id;
    sitarParser_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 sitarParser_expression_return

    sitarParser_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 sitarParser_expression_return

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1359:2: ( FOR id= IDENTIFIER IN e1= expression TO e2= expression ( connection )+ END FOR )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1359:4: FOR id= IDENTIFIER IN e1= expression TO e2= expression ( connection )+ END FOR
        {
             MATCHT(FOR, &FOLLOW_FOR_in_for_loop_for_connections2388);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_for_loop_for_connections2392);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


             MATCHT(IN, &FOLLOW_IN_in_for_loop_for_connections2394);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_for_loop_for_connections2398);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


             MATCHT(TO, &FOLLOW_TO_in_for_loop_for_connections2400);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_for_loop_for_connections2404);
            e2=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            {

                	C_file<<"\n//---connecting ports to nets----";
                	C_file<<"\nfor(int "<<((id->getText(id))->chars)<<"=("<<(
                (STRSTREAM->toStringTT(STRSTREAM, e1.start, e1.stop))
                ->chars)<<");";
                	C_file<<((id->getText(id))->chars)<<"<=("<<
                (STRSTREAM->toStringTT(STRSTREAM, e2.start, e2.stop))
                ->chars<<");";
                	C_file<<((id->getText(id))->chars)<<"++)\n{\n\n";
                	
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1366:3: ( connection )+
            {
                int cnt49=0;

                for (;;)
                {
                    int alt49=2;
            	switch ( LA(1) )
            	{
            	case FOR:
            	case IDENTIFIER:
            		{
            			alt49=1;
            		}
            	    break;

            	}

            	switch (alt49)
            	{
            	    case 1:
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1366:3: connection
            	        {
            	            FOLLOWPUSH(FOLLOW_connection_in_for_loop_for_connections2411);
            	            connection(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulefor_loop_for_connectionsEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt49 >= 1 )
            		{
            		    goto loop49;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulefor_loop_for_connectionsEx;
            	}
            	cnt49++;
                }
                loop49: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(END, &FOLLOW_END_in_for_loop_for_connections2418);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


             MATCHT(FOR, &FOLLOW_FOR_in_for_loop_for_connections2420);
            if  (HASEXCEPTION())
            {
                goto rulefor_loop_for_connectionsEx;
            }


            {

                	C_file<<"\n\n};\n";
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefor_loop_for_connectionsEx; /* Prevent compiler warnings */
    rulefor_loop_for_connectionsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end for_loop_for_connections */

/**
 * $ANTLR start expression
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1401:1: expression : term ( ( PLUS | MINUS ) term )* ;
 */
static sitarParser_expression_return
expression(psitarParser ctx)
{
    sitarParser_expression_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1401:13: ( term ( ( PLUS | MINUS ) term )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1401:16: term ( ( PLUS | MINUS ) term )*
        {
            FOLLOWPUSH(FOLLOW_term_in_expression2463);
            term(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1401:21: ( ( PLUS | MINUS ) term )*

            for (;;)
            {
                int alt50=2;
                switch ( LA(1) )
                {
                case MINUS:
                case PLUS:
                	{
                		alt50=1;
                	}
                    break;

                }

                switch (alt50)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1401:22: ( PLUS | MINUS ) term
            	    {
            	        if ( LA(1) == MINUS || LA(1) == PLUS )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleexpressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_term_in_expression2472);
            	        term(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop50;	/* break out of the loop */
            	    break;
                }
            }
            loop50: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end expression */

/**
 * $ANTLR start term
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1403:1: term : signed_expression ( ( '*' | '/' | '%' ) signed_expression )* ;
 */
static void
term(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1403:7: ( signed_expression ( ( '*' | '/' | '%' ) signed_expression )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1403:9: signed_expression ( ( '*' | '/' | '%' ) signed_expression )*
        {
            FOLLOWPUSH(FOLLOW_signed_expression_in_term2483);
            signed_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletermEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1403:27: ( ( '*' | '/' | '%' ) signed_expression )*

            for (;;)
            {
                int alt51=2;
                switch ( LA(1) )
                {
                case 71:
                case 74:
                case 76:
                	{
                		alt51=1;
                	}
                    break;

                }

                switch (alt51)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1403:28: ( '*' | '/' | '%' ) signed_expression
            	    {
            	        if ( LA(1) == 71 || LA(1) == 74 || LA(1) == 76 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruletermEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_signed_expression_in_term2494);
            	        signed_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletermEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop51;	/* break out of the loop */
            	    break;
                }
            }
            loop51: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start signed_expression
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1405:1: signed_expression : ( MINUS )? atomic_expression ;
 */
static void
signed_expression(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1406:2: ( ( MINUS )? atomic_expression )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1406:4: ( MINUS )? atomic_expression
        {
            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1406:4: ( MINUS )?
            {
                int alt52=2;
                switch ( LA(1) )
                {
                    case MINUS:
                    	{
                    		alt52=1;
                    	}
                        break;
                }

                switch (alt52)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1406:4: MINUS
            	    {
            	         MATCHT(MINUS, &FOLLOW_MINUS_in_signed_expression2506);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesigned_expressionEx;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_atomic_expression_in_signed_expression2509);
            atomic_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesigned_expressionEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesigned_expressionEx; /* Prevent compiler warnings */
    rulesigned_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end signed_expression */

/**
 * $ANTLR start atomic_expression
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1413:1: atomic_expression : ( '(' expression ')' | INTEGER | IDENTIFIER );
 */
static void
atomic_expression(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1414:2: ( '(' expression ')' | INTEGER | IDENTIFIER )

            ANTLR3_UINT32 alt53;

            alt53=3;

            switch ( LA(1) )
            {
            case 72:
            	{
            		alt53=1;
            	}
                break;
            case INTEGER:
            	{
            		alt53=2;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt53=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 53;
                EXCEPTION->state        = 0;


                goto ruleatomic_expressionEx;

            }

            switch (alt53)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1415:2: '(' expression ')'
        	    {
        	         MATCHT(72, &FOLLOW_72_in_atomic_expression2526);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_atomic_expression2527);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	         MATCHT(73, &FOLLOW_73_in_atomic_expression2528);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1416:4: INTEGER
        	    {
        	         MATCHT(INTEGER, &FOLLOW_INTEGER_in_atomic_expression2533);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1417:4: IDENTIFIER
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_atomic_expression2538);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expressionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomic_expressionEx; /* Prevent compiler warnings */
    ruleatomic_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end atomic_expression */

/**
 * $ANTLR start behavior_block
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1431:1: behavior_block : cf ;
 */
static void
behavior_block(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1432:2: ( cf )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1433:3: cf
        {
            FOLLOWPUSH(FOLLOW_cf_in_behavior_block2564);
            cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebehavior_blockEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebehavior_blockEx; /* Prevent compiler warnings */
    rulebehavior_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end behavior_block */

/**
 * $ANTLR start cf
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1437:1: cf : BEHAVIOR sequence[0] END BEHAVIOR ;
 */
static void
cf(psitarParser ctx)
{
    /* Initialize rule variables
     */
    ctx->psitarParser_cfTop = psitarParser_cfPush(ctx);


    	

    	//initialize counts
    	(SCOPE_TOP(cf))->pointer_count=0;
    	(SCOPE_TOP(cf))->timer_count=0;
    	(SCOPE_TOP(cf))->if_flag_count=0;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1469:2: ( BEHAVIOR sequence[0] END BEHAVIOR )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1470:2: BEHAVIOR sequence[0] END BEHAVIOR
        {
             MATCHT(BEHAVIOR, &FOLLOW_BEHAVIOR_in_cf2593);
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


            {
                ++(SCOPE_TOP(cf))->pointer_count;
            }


            FOLLOWPUSH(FOLLOW_sequence_in_cf2603);
            sequence(ctx, 0);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


             MATCHT(END, &FOLLOW_END_in_cf2607);
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


             MATCHT(BEHAVIOR, &FOLLOW_BEHAVIOR_in_cf2609);
            if  (HASEXCEPTION())
            {
                goto rulecfEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecfEx; /* Prevent compiler warnings */
    rulecfEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {


                    	//add declarations for pointers, timers and flags
                    	//used by the  behavior block 
                    	(SCOPE_TOP(du))->num_pointers=(SCOPE_TOP(cf))->pointer_count;
                    	(SCOPE_TOP(du))->num_timers=(SCOPE_TOP(cf))->timer_count;
                    	(SCOPE_TOP(du))->num_if_flags=(SCOPE_TOP(cf))->if_flag_count;


                }
            }


    psitarParser_cfPop(ctx);

    return ;
}
/* $ANTLR end cf */

/**
 * $ANTLR start sequence
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1498:1: sequence[int p] returns [int last_case] : (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' ) ;
 */
static int
sequence(psitarParser ctx, int p)
{
    int last_case;


    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    int s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 int

    int s3;
    #undef	RETURN_TYPE_s3
    #define	RETURN_TYPE_s3 int

    int s4;
    #undef	RETURN_TYPE_s4
    #define	RETURN_TYPE_s4 int

    /* Initialize rule variables
     */

     int k=0;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1515:1: ( (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' ) )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1516:1: (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' )
        {
            {
                	
                	//Add some text at the start of the sequence
                	E_file<<"\nswitch(_pointer["<<p<<"])\n{\n";

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1522:14: (s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )? | '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')' )
            {
                int alt58=2;
                switch ( LA(1) )
                {
                case CODE_BLOCK:
                case DECL:
                case DO:
                case IF:
                case INCLUDE:
                case INIT:
                case NOTHING:
                case RUN:
                case STOP:
                case WAIT:
                case 82:
                	{
                		alt58=1;
                	}
                    break;
                case 72:
                	{
                		alt58=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 58;
                    EXCEPTION->state        = 0;


                    goto rulesequenceEx;

                }

                switch (alt58)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1524:14: s1= statement[p,k] ( ';' s2= statement[p,k] )* ( ';' )?
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_sequence2690);
            	        s1=statement(ctx, p, k);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	        {
            	            k=s1
            	            +1;
            	        }


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1525:2: ( ';' s2= statement[p,k] )*

            	        for (;;)
            	        {
            	            int alt54=2;
            	            switch ( LA(1) )
            	            {
            	            case 77:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case CODE_BLOCK:
            	            		case DECL:
            	            		case DO:
            	            		case IF:
            	            		case INCLUDE:
            	            		case INIT:
            	            		case NOTHING:
            	            		case RUN:
            	            		case STOP:
            	            		case WAIT:
            	            		case 82:
            	            			{
            	            				alt54=1;
            	            			}
            	            		    break;

            	            		}

            	            	}
            	                break;

            	            }

            	            switch (alt54)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1525:3: ';' s2= statement[p,k]
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2697);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_statement_in_sequence2701);
            	        	        s2=statement(ctx, p, k);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        {
            	        	            k=(s2
            	        	            +1);
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop54;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop54: ; /* Jump out to here if this rule does not match */


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1525:51: ( ';' )?
            	        {
            	            int alt55=2;
            	            switch ( LA(1) )
            	            {
            	                case 77:
            	                	{
            	                		alt55=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt55)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1525:51: ';'
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2708);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1526:3: '(' s3= statement[p,k] ( ';' s4= statement[p,k] )* ( ';' )? ')'
            	    {
            	         MATCHT(72, &FOLLOW_72_in_sequence2713);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_statement_in_sequence2718);
            	        s3=statement(ctx, p, k);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	        {
            	            k=(s3
            	            +1);
            	        }


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1527:9: ( ';' s4= statement[p,k] )*

            	        for (;;)
            	        {
            	            int alt56=2;
            	            switch ( LA(1) )
            	            {
            	            case 77:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case CODE_BLOCK:
            	            		case DECL:
            	            		case DO:
            	            		case IF:
            	            		case INCLUDE:
            	            		case INIT:
            	            		case NOTHING:
            	            		case RUN:
            	            		case STOP:
            	            		case WAIT:
            	            		case 82:
            	            			{
            	            				alt56=1;
            	            			}
            	            		    break;

            	            		}

            	            	}
            	                break;

            	            }

            	            switch (alt56)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1527:10: ';' s4= statement[p,k]
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2732);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_statement_in_sequence2736);
            	        	        s4=statement(ctx, p, k);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	        {
            	        	            k=(s4
            	        	            +1);
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop56;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop56: ; /* Jump out to here if this rule does not match */


            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1527:59: ( ';' )?
            	        {
            	            int alt57=2;
            	            switch ( LA(1) )
            	            {
            	                case 77:
            	                	{
            	                		alt57=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt57)
            	            {
            	        	case 1:
            	        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1527:59: ';'
            	        	    {
            	        	         MATCHT(77, &FOLLOW_77_in_sequence2744);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         MATCHT(73, &FOLLOW_73_in_sequence2747);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesequenceEx; /* Prevent compiler warnings */
    rulesequenceEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//add the last case that indicates the sequence has terminated
                    	E_file<<"\ncase "<<k<<": break;\n}\n";
                    	last_case=k;

                    	C_file<<"\n_pointer_last_value["<<p<<"]="<<k<<";";

                }
            }


    return last_case;
}
/* $ANTLR end sequence */

/**
 * $ANTLR start statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1536:1: statement[int p_, int k_] returns [int last_case_] : ( atomic_statement | compound_statement );
 */
static int
statement(psitarParser ctx, int p_, int k_)
{
    int last_case_;


    /* Initialize rule variables
     */
    ctx->psitarParser_statementTop = psitarParser_statementPush(ctx);

    	//Initialize variables
    	(SCOPE_TOP(statement))->p=p_;
    	(SCOPE_TOP(statement))->k=k_;
    	(SCOPE_TOP(statement))->last_case=k_;
    	
    	

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1562:2: ( atomic_statement | compound_statement )

            ANTLR3_UINT32 alt59;

            alt59=2;

            switch ( LA(1) )
            {
            case CODE_BLOCK:
            case DECL:
            case INCLUDE:
            case INIT:
            case NOTHING:
            case RUN:
            case STOP:
            case WAIT:
            	{
            		alt59=1;
            	}
                break;
            case DO:
            case IF:
            case 82:
            	{
            		alt59=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 59;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt59)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1563:1: atomic_statement
        	    {
        	        {

        	            	//Initialize variables
        	            	(SCOPE_TOP(statement))->p=p_;
        	            	(SCOPE_TOP(statement))->k=k_;
        	            	(SCOPE_TOP(statement))->last_case=k_;
        	            	
        	            	

        	        }


        	        FOLLOWPUSH(FOLLOW_atomic_statement_in_statement2793);
        	        atomic_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1573:4: compound_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_compound_statement_in_statement2799);
        	        compound_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	//return the last case label used by this statement
                    	last_case_=(SCOPE_TOP(statement))->last_case;

                    	
                    	

                }
            }


    psitarParser_statementPop(ctx);

    return last_case_;
}
/* $ANTLR end statement */

/**
 * $ANTLR start atomic_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1578:1: atomic_statement : ( nothing_statement | wait_statement | stop_statement | run_procedure_statement | code_block_statement );
 */
static void
atomic_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1579:2: ( nothing_statement | wait_statement | stop_statement | run_procedure_statement | code_block_statement )

            ANTLR3_UINT32 alt60;

            alt60=5;

            switch ( LA(1) )
            {
            case NOTHING:
            	{
            		alt60=1;
            	}
                break;
            case WAIT:
            	{
            		alt60=2;
            	}
                break;
            case STOP:
            	{
            		alt60=3;
            	}
                break;
            case RUN:
            	{
            		alt60=4;
            	}
                break;
            case CODE_BLOCK:
            case DECL:
            case INCLUDE:
            case INIT:
            	{
            		alt60=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 60;
                EXCEPTION->state        = 0;


                goto ruleatomic_statementEx;

            }

            switch (alt60)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1579:4: nothing_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_nothing_statement_in_atomic_statement2814);
        	        nothing_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1580:4: wait_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_wait_statement_in_atomic_statement2819);
        	        wait_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1581:4: stop_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_stop_statement_in_atomic_statement2824);
        	        stop_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1582:4: run_procedure_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_run_procedure_statement_in_atomic_statement2829);
        	        run_procedure_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1583:4: code_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_code_block_statement_in_atomic_statement2834);
        	        code_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomic_statementEx; /* Prevent compiler warnings */
    ruleatomic_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end atomic_statement */

/**
 * $ANTLR start code_block_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1591:1: code_block_statement : ( behavior_code_block_statement | declaration_block_statement | initialization_block_statement | includes_block_statement );
 */
static void
code_block_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1592:2: ( behavior_code_block_statement | declaration_block_statement | initialization_block_statement | includes_block_statement )

            ANTLR3_UINT32 alt61;

            alt61=4;

            switch ( LA(1) )
            {
            case CODE_BLOCK:
            	{
            		alt61=1;
            	}
                break;
            case DECL:
            	{
            		alt61=2;
            	}
                break;
            case INIT:
            	{
            		alt61=3;
            	}
                break;
            case INCLUDE:
            	{
            		alt61=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 61;
                EXCEPTION->state        = 0;


                goto rulecode_block_statementEx;

            }

            switch (alt61)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1592:4: behavior_code_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_behavior_code_block_statement_in_code_block_statement2860);
        	        behavior_code_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1593:4: declaration_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_declaration_block_statement_in_code_block_statement2865);
        	        declaration_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1594:4: initialization_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_initialization_block_statement_in_code_block_statement2870);
        	        initialization_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1595:4: includes_block_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_includes_block_statement_in_code_block_statement2875);
        	        includes_block_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecode_block_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecode_block_statementEx; /* Prevent compiler warnings */
    rulecode_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end code_block_statement */

/**
 * $ANTLR start behavior_code_block_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1602:1: behavior_code_block_statement : c= code_block_with_info ;
 */
static void
behavior_code_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1603:2: (c= code_block_with_info )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1603:5: c= code_block_with_info
        {
            FOLLOWPUSH(FOLLOW_code_block_with_info_in_behavior_code_block_statement2894);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebehavior_code_block_statementEx;
            }


            {

                               	
                        E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//code_block_statement ";
                	E_file<<
                c.text
                ;
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebehavior_code_block_statementEx; /* Prevent compiler warnings */
    rulebehavior_code_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end behavior_code_block_statement */

/**
 * $ANTLR start declaration_block_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1617:1: declaration_block_statement : DECL c= code_block_with_info ;
 */
static void
declaration_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1618:2: ( DECL c= code_block_with_info )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1619:2: DECL c= code_block_with_info
        {
             MATCHT(DECL, &FOLLOW_DECL_in_declaration_block_statement2914);
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_block_statementEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_declaration_block_statement2918);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_block_statementEx;
            }


            {

                               	
                               	
                        E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//declaration_block_statement ";
                	
                	D_file<<
                c.text
                ;
                	

                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_block_statementEx; /* Prevent compiler warnings */
    ruledeclaration_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration_block_statement */

/**
 * $ANTLR start initialization_block_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1637:1: initialization_block_statement : INIT c= code_block_with_info ;
 */
static void
initialization_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1638:2: ( INIT c= code_block_with_info )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1639:2: INIT c= code_block_with_info
        {
             MATCHT(INIT, &FOLLOW_INIT_in_initialization_block_statement2938);
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_block_statementEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_initialization_block_statement2942);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinitialization_block_statementEx;
            }


            {

                               	
                       	E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//initialization_block_statement";
                	C_file<<
                c.text
                ;
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinitialization_block_statementEx; /* Prevent compiler warnings */
    ruleinitialization_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end initialization_block_statement */

/**
 * $ANTLR start includes_block_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1652:1: includes_block_statement : INCLUDE c= code_block_with_info ;
 */
static void
includes_block_statement(psitarParser ctx)
{
    sitarParser_code_block_with_info_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_with_info_return

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1653:2: ( INCLUDE c= code_block_with_info )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1654:2: INCLUDE c= code_block_with_info
        {
             MATCHT(INCLUDE, &FOLLOW_INCLUDE_in_includes_block_statement2960);
            if  (HASEXCEPTION())
            {
                goto ruleincludes_block_statementEx;
            }


            FOLLOWPUSH(FOLLOW_code_block_with_info_in_includes_block_statement2964);
            c=code_block_with_info(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleincludes_block_statementEx;
            }


            {

                               	
                       	E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                	E_file<<"\n{ \n ";
                	E_file<<"\n//includes_block_statement";

                	I_file<<
                c.text
                ;
                	
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                	E_file<<"\n}\n";
                	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleincludes_block_statementEx; /* Prevent compiler warnings */
    ruleincludes_block_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end includes_block_statement */

/**
 * $ANTLR start nothing_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1669:1: nothing_statement : n1= NOTHING ;
 */
static void
nothing_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    n1;

    /* Initialize rule variables
     */

    n1       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1670:3: (n1= NOTHING )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1670:5: n1= NOTHING
        {
            n1 = (pANTLR3_COMMON_TOKEN) MATCHT(NOTHING, &FOLLOW_NOTHING_in_nothing_statement2983);
            if  (HASEXCEPTION())
            {
                goto rulenothing_statementEx;
            }


            {

                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{ \n ";
                		E_file<<"\n//nothing statement , line:"<<(n1->getLine(n1));
                		E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\n}\n";
                		(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenothing_statementEx; /* Prevent compiler warnings */
    rulenothing_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nothing_statement */

/**
 * $ANTLR start wait_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1755:1: wait_statement : ( wait_until | wait_for_time | single_wait );
 */
static void
wait_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1756:2: ( wait_until | wait_for_time | single_wait )

            ANTLR3_UINT32 alt62;

            alt62=3;

            switch ( LA(1) )
            {
            case WAIT:
            	{
            		switch ( LA(2) )
            		{
            		case UNTIL:
            			{
            				alt62=1;
            			}
            		    break;
            		case 72:
            			{
            				alt62=2;
            			}
            		    break;
            		case ELSE:
            		case END:
            		case WHILE:
            		case 73:
            		case 77:
            		case 83:
            		case 84:
            			{
            				alt62=3;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 62;
            		    EXCEPTION->state        = 1;


            		    goto rulewait_statementEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 62;
                EXCEPTION->state        = 0;


                goto rulewait_statementEx;

            }

            switch (alt62)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1756:4: wait_until
        	    {
        	        FOLLOWPUSH(FOLLOW_wait_until_in_wait_statement3010);
        	        wait_until(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewait_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1757:3: wait_for_time
        	    {
        	        FOLLOWPUSH(FOLLOW_wait_for_time_in_wait_statement3018);
        	        wait_for_time(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewait_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1758:3: single_wait
        	    {
        	        FOLLOWPUSH(FOLLOW_single_wait_in_wait_statement3026);
        	        single_wait(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewait_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulewait_statementEx; /* Prevent compiler warnings */
    rulewait_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end wait_statement */

/**
 * $ANTLR start wait_until
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1762:1: wait_until : s= WAIT UNTIL e= expression_cf ;
 */
static void
wait_until(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    std::string e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e std::string

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1763:9: (s= WAIT UNTIL e= expression_cf )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1763:11: s= WAIT UNTIL e= expression_cf
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(WAIT, &FOLLOW_WAIT_in_wait_until3051);
            if  (HASEXCEPTION())
            {
                goto rulewait_untilEx;
            }


             MATCHT(UNTIL, &FOLLOW_UNTIL_in_wait_until3053);
            if  (HASEXCEPTION())
            {
                goto rulewait_untilEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_wait_until3057);
            e=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewait_untilEx;
            }


            {

                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{\n";
                		E_file<<"\n//wait-until statement , line:"<<(s->getLine(s));
                		E_file<<"\nif("<<
                e
                <<")";
                		E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\nelse\n break;\n }";
                		(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewait_untilEx; /* Prevent compiler warnings */
    rulewait_untilEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end wait_until */

/**
 * $ANTLR start wait_for_time
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1775:1: wait_for_time : s= WAIT '(' e1= expression_cf ',' e2= expression_cf ')' ;
 */
static void
wait_for_time(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1776:9: (s= WAIT '(' e1= expression_cf ',' e2= expression_cf ')' )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1776:11: s= WAIT '(' e1= expression_cf ',' e2= expression_cf ')'
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(WAIT, &FOLLOW_WAIT_in_wait_for_time3094);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


             MATCHT(72, &FOLLOW_72_in_wait_for_time3097);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_wait_for_time3101);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


             MATCHT(75, &FOLLOW_75_in_wait_for_time3103);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_wait_for_time3107);
            e2=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


             MATCHT(73, &FOLLOW_73_in_wait_for_time3109);
            if  (HASEXCEPTION())
            {
                goto rulewait_for_timeEx;
            }


            {

                                 E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                                 E_file<<"\n{\n";


                		 E_file<<"\n//wait-for -time statement , line:"<<(s->getLine(s));
                                 E_file<<"\n_timer["<<(SCOPE_TOP(cf))->timer_count<<"] = sitar::time(current_time)+sitar::time(";
                                 E_file<<
                e1
                <<","<<e2
                <<");";
                		 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\n}\n";


                                 E_file<<"\ncase "<<((SCOPE_TOP(statement))->k+1)<<":";
                                 E_file<<"\n{\n";
                                 E_file<<"if(current_time>=_timer["<<(SCOPE_TOP(cf))->timer_count<<"])";
                                 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\nelse\n break; \n}";

                                //a unique timer has been used to implement this delay.
                                //increment the timer count
                                 ++(SCOPE_TOP(cf))->timer_count;

                                 (SCOPE_TOP(statement))->last_case=((SCOPE_TOP(statement))->k+1);

                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewait_for_timeEx; /* Prevent compiler warnings */
    rulewait_for_timeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end wait_for_time */

/**
 * $ANTLR start single_wait
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1805:1: single_wait : s= WAIT ;
 */
static void
single_wait(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1806:2: (s= WAIT )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1806:4: s= WAIT
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(WAIT, &FOLLOW_WAIT_in_single_wait3140);
            if  (HASEXCEPTION())
            {
                goto rulesingle_waitEx;
            }


            {

                                 E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                                 E_file<<"\n{\n";


                                 E_file<<"\n//wait statement , line:"<<(s->getLine(s));
                                 E_file<<"\n_timer["<<(SCOPE_TOP(cf))->timer_count<<"] = sitar::time(current_time)+sitar::time(0,1);";
                		 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\n}\n";


                                 E_file<<"\ncase "<<((SCOPE_TOP(statement))->k+1)<<":";
                                 E_file<<"\n{\n";
                                 E_file<<"if(current_time>=_timer["<<(SCOPE_TOP(cf))->timer_count<<"])";
                		 E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                 E_file<<"\nelse\n break; \n}";

                                //a unique timer has been used to implement this delay.
                                //increment the timer count
                                 ++(SCOPE_TOP(cf))->timer_count;

                                 (SCOPE_TOP(statement))->last_case=((SCOPE_TOP(statement))->k+1);
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesingle_waitEx; /* Prevent compiler warnings */
    rulesingle_waitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end single_wait */

/**
 * $ANTLR start stop_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1833:1: stop_statement : ( stop_behavior | stop_simulation );
 */
static void
stop_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1834:2: ( stop_behavior | stop_simulation )

            ANTLR3_UINT32 alt63;

            alt63=2;

            switch ( LA(1) )
            {
            case STOP:
            	{
            		switch ( LA(2) )
            		{
            		case BEHAVIOR:
            			{
            				alt63=1;
            			}
            		    break;
            		case SIMULATION:
            			{
            				alt63=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 63;
            		    EXCEPTION->state        = 1;


            		    goto rulestop_statementEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 63;
                EXCEPTION->state        = 0;


                goto rulestop_statementEx;

            }

            switch (alt63)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1834:4: stop_behavior
        	    {
        	        FOLLOWPUSH(FOLLOW_stop_behavior_in_stop_statement3166);
        	        stop_behavior(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestop_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1835:5: stop_simulation
        	    {
        	        FOLLOWPUSH(FOLLOW_stop_simulation_in_stop_statement3172);
        	        stop_simulation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestop_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestop_statementEx; /* Prevent compiler warnings */
    rulestop_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stop_statement */

/**
 * $ANTLR start stop_behavior
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1837:1: stop_behavior : s= STOP BEHAVIOR ;
 */
static void
stop_behavior(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1838:3: (s= STOP BEHAVIOR )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1838:5: s= STOP BEHAVIOR
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(STOP, &FOLLOW_STOP_in_stop_behavior3185);
            if  (HASEXCEPTION())
            {
                goto rulestop_behaviorEx;
            }


             MATCHT(BEHAVIOR, &FOLLOW_BEHAVIOR_in_stop_behavior3187);
            if  (HASEXCEPTION())
            {
                goto rulestop_behaviorEx;
            }


            {

                			
                			
                			E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                			E_file<<"\n{ \n ";
                			E_file<<"\n//stop module statement , line:"<<(s->getLine(s));
                			E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                			E_file<<"\n _terminated=1;";
                			E_file<<"\n}\n";
                			(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestop_behaviorEx; /* Prevent compiler warnings */
    rulestop_behaviorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stop_behavior */

/**
 * $ANTLR start stop_simulation
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1852:1: stop_simulation : s= STOP SIMULATION ;
 */
static void
stop_simulation(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1853:3: (s= STOP SIMULATION )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1853:5: s= STOP SIMULATION
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(STOP, &FOLLOW_STOP_in_stop_simulation3207);
            if  (HASEXCEPTION())
            {
                goto rulestop_simulationEx;
            }


             MATCHT(SIMULATION, &FOLLOW_SIMULATION_in_stop_simulation3209);
            if  (HASEXCEPTION())
            {
                goto rulestop_simulationEx;
            }


            {

                			
                			
                			E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                			E_file<<"\n{ \n ";
                			E_file<<"\n//stop simulation statement , line:"<<(s->getLine(s));
                			E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                			E_file<<"\n stop_simulation();";
                			E_file<<"\n}\n";
                			(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestop_simulationEx; /* Prevent compiler warnings */
    rulestop_simulationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stop_simulation */

/**
 * $ANTLR start run_procedure_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1867:1: run_procedure_statement : s= RUN id= IDENTIFIER ;
 */
static void
run_procedure_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    s       = NULL;
    id       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1868:3: (s= RUN id= IDENTIFIER )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1868:5: s= RUN id= IDENTIFIER
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(RUN, &FOLLOW_RUN_in_run_procedure_statement3229);
            if  (HASEXCEPTION())
            {
                goto rulerun_procedure_statementEx;
            }


            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_run_procedure_statement3233);
            if  (HASEXCEPTION())
            {
                goto rulerun_procedure_statementEx;
            }


            {

                		std::string name =(const char *)((id->getText(id))->chars);
                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{ \n ";
                		
                		E_file<<"\n//run procedure statement , line:"<<(s->getLine(s));
                		E_file<<"\n"<<name<<".runBehavior(current_time);";
                		E_file<<"\nif("<<name<<"._terminated==1)";
                		E_file<<"\n{";
                		E_file<<"\n"<<name<<"._resetBehavior();";
                		E_file<<"\n_incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\n}";
                		E_file<<"\nelse";
                		E_file<<"\n{";
                		E_file<<"\n//procedure has converged, and might";
                		E_file<<"\n//need to be re-executed";
                		E_file<<"\nif("<<name<<"._reexecute==true)";
                		E_file<<"\n_reexecute=true;";
                		E_file<<"\nbreak;";
                		E_file<<"\n}";
                		
                		E_file<<"\n}\n";
                		(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulerun_procedure_statementEx; /* Prevent compiler warnings */
    rulerun_procedure_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end run_procedure_statement */

/**
 * $ANTLR start compound_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1899:1: compound_statement : ( if_statement | do_while_statement | parallel_statement );
 */
static void
compound_statement(psitarParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:1900:2: ( if_statement | do_while_statement | parallel_statement )

            ANTLR3_UINT32 alt64;

            alt64=3;

            switch ( LA(1) )
            {
            case IF:
            	{
            		alt64=1;
            	}
                break;
            case DO:
            	{
            		alt64=2;
            	}
                break;
            case 82:
            	{
            		alt64=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 64;
                EXCEPTION->state        = 0;


                goto rulecompound_statementEx;

            }

            switch (alt64)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1900:4: if_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_if_statement_in_compound_statement3254);
        	        if_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompound_statementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1901:4: do_while_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_do_while_statement_in_compound_statement3259);
        	        do_while_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompound_statementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1902:4: parallel_statement
        	    {
        	        FOLLOWPUSH(FOLLOW_parallel_statement_in_compound_statement3264);
        	        parallel_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompound_statementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecompound_statementEx; /* Prevent compiler warnings */
    rulecompound_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end compound_statement */

/**
 * $ANTLR start if_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1909:1: if_statement : s= IF e1= expression_cf THEN s1= sequence[true_branch] (else_clause= ELSE s2= sequence[false_branch] )? END IF ;
 */
static void
if_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    pANTLR3_COMMON_TOKEN    else_clause;
    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    int s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 int

    /* Initialize rule variables
     */


            //pointers used by the two sequences
            //within this statement
            int true_branch=0;
            int false_branch=0;
            int flag;

    s       = NULL;
    else_clause       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1922:2: (s= IF e1= expression_cf THEN s1= sequence[true_branch] (else_clause= ELSE s2= sequence[false_branch] )? END IF )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1922:4: s= IF e1= expression_cf THEN s1= sequence[true_branch] (else_clause= ELSE s2= sequence[false_branch] )? END IF
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(IF, &FOLLOW_IF_in_if_statement3291);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_if_statement3297);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


             MATCHT(THEN, &FOLLOW_THEN_in_if_statement3301);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            {

                                true_branch=(SCOPE_TOP(cf))->pointer_count;
                                ++(SCOPE_TOP(cf))->pointer_count;
                                flag=(SCOPE_TOP(cf))->if_flag_count;
                                ++(SCOPE_TOP(cf))->if_flag_count;

                		E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                		E_file<<"\n{\n";
                		E_file<<"\n//if statement , line:"<<(s->getLine(s));

                		E_file<<"\nif("<<
                e1
                <<")";
                		E_file<<"\n_if_flag["<<flag<<"]=true;";
                		E_file<<"\nelse";
                		E_file<<"\n_if_flag["<<flag<<"]=false;";
                		E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                		E_file<<"\n}\n";

                		E_file<<"\ncase "<<((SCOPE_TOP(statement))->k+1)<<":";
                		E_file<<"\n{\n";

                		E_file<<"\nif(_if_flag["<<flag<<"]==true)";
                		E_file<<"\n{\n";

                        
            }


            FOLLOWPUSH(FOLLOW_sequence_in_if_statement3311);
            s1=sequence(ctx, true_branch);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            {


                                 E_file<<"\n}\n";
                                 E_file<<"\nelse\n{\n";
                        
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1953:2: (else_clause= ELSE s2= sequence[false_branch] )?
            {
                int alt65=2;
                switch ( LA(1) )
                {
                    case ELSE:
                    	{
                    		alt65=1;
                    	}
                        break;
                }

                switch (alt65)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:1953:4: else_clause= ELSE s2= sequence[false_branch]
            	    {
            	        else_clause = (pANTLR3_COMMON_TOKEN) MATCHT(ELSE, &FOLLOW_ELSE_in_if_statement3329);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_statementEx;
            	        }


            	        {

            	            				false_branch=(SCOPE_TOP(cf))->pointer_count; 
            	            				++(SCOPE_TOP(cf))->pointer_count;
            	            			
            	        }


            	        FOLLOWPUSH(FOLLOW_sequence_in_if_statement3353);
            	        s2=sequence(ctx, false_branch);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_statementEx;
            	        }


            	    }
            	    break;

                }
            }

            {


                                 E_file<<"\n}\n";
                        
            }


             MATCHT(END, &FOLLOW_END_in_if_statement3385);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


             MATCHT(IF, &FOLLOW_IF_in_if_statement3387);
            if  (HASEXCEPTION())
            {
                goto ruleif_statementEx;
            }


            {

                                E_file<<"\nif(";
                                E_file<<"(_if_flag["<<flag<<"]==true && _pointer["<<true_branch<<"]>=_pointer_last_value["<<true_branch<<"])";
                                E_file<<" || (_if_flag["<<flag<<"]==false";
                                if(else_clause!=NULL) 
                		{	E_file<<"&& _pointer["<<false_branch<<"]>= _pointer_last_value["<<false_branch<<"]"; }
                		E_file<<"))\n";
                                E_file<<"\n{";
                                E_file<<"\n //if-statement has terminated";
                                E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");";
                                E_file<<"\n _pointer["<<true_branch<<"]=0;\n";
                                if(else_clause!=NULL)   E_file<<"\n _pointer["<<false_branch<<"]=0;\n";
                                E_file<<"\n}\n";

                                E_file<<"\n else ";
                                E_file<<"\n //if-statement has converged";
                                E_file<<"\n break;";
                                E_file<<"\n}\n";
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleif_statementEx; /* Prevent compiler warnings */
    ruleif_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                     (SCOPE_TOP(statement))->last_case=((SCOPE_TOP(statement))->k+1);

                }
            }


    return ;
}
/* $ANTLR end if_statement */

/**
 * $ANTLR start do_while_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:1996:1: do_while_statement : s= DO s1= sequence[Q] WHILE e1= expression_cf END DO ;
 */
static void
do_while_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    /* Initialize rule variables
     */


    	int Q=0; //pointer used by child sequence
    	int m=0; //last case in child sequence

    s       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2005:2: (s= DO s1= sequence[Q] WHILE e1= expression_cf END DO )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2005:4: s= DO s1= sequence[Q] WHILE e1= expression_cf END DO
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(DO, &FOLLOW_DO_in_do_while_statement3427);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


            {

                	Q=(SCOPE_TOP(cf))->pointer_count;
                	(SCOPE_TOP(cf))->pointer_count++;
                	
            }


            {


                	E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<" :";
                	E_file<<"\n{";
                	E_file<<"\n//do-while statement , line:"<<(s->getLine(s));
                	E_file<<"\n int _dowhile_iteration;";
                	E_file<<"\nfor(_dowhile_iteration=1; _dowhile_iteration<=SITAR_ITERATION_LIMIT; _dowhile_iteration++)";
                	E_file<<"\n{";
                	E_file<<"\n//execute the sequence  ";
                	
            }


            FOLLOWPUSH(FOLLOW_sequence_in_do_while_statement3517);
            s1=sequence(ctx, Q);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


             MATCHT(WHILE, &FOLLOW_WHILE_in_do_while_statement3581);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


            FOLLOWPUSH(FOLLOW_expression_cf_in_do_while_statement3585);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


             MATCHT(END, &FOLLOW_END_in_do_while_statement3587);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


             MATCHT(DO, &FOLLOW_DO_in_do_while_statement3589);
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statementEx;
            }


            {

                	m=s1
                ;
                	E_file<<"\nif(_pointer["<<Q<<"]< _pointer_last_value["<<Q<<"])  ";
                	E_file<<"\nbreak; //sequence has converged  ";
                	E_file<<"\n else ";
                	E_file<<"\n if(_pointer["<<Q<<"]==_pointer_last_value["<<Q<<"] && ("<<e1
                <<"==true))";
                	E_file<<"\n {";
                	E_file<<"\n//re-activate the sequence	"; 
                	E_file<<"\n_pointer["<<Q<<"]=0;	";
                	E_file<<"\n_reexecute=1;       	";
                	E_file<<"\n}				";
                	E_file<<"\nelse break; //sequence has terminated			";
                	E_file<<"\n };";

                		

                	E_file<<"\n	//For loop will finish if									";	
                	E_file<<"\n	//the sequence inside do-while loop converges                                                   ";
                	E_file<<"\n	//OR the expression becomes false at the end of some execution of while loop                    ";
                	E_file<<"\n	//OR  if the iteration limit is exceeded.                                                       ";
                	
                	E_file<<"\n	if (_dowhile_iteration>SITAR_ITERATION_LIMIT)   ";
                	E_file<<"\n	{                                                                                               ";
                	E_file<<"\n		//iteration limit exceeded. Throw error and                                             ";
                	E_file<<"\n		//terminate the do-while statement                                                      ";
                	E_file<<"\n 		std::cerr<<\"\\nERROR:Iteration limit exceeded for do-while loop on line:"<<(s->getLine(s))<<" in file "<<GDATA->getAttribute("INPUT_FILE")<<"\";";
                	E_file<<"\n		_pointer["<<Q<<"]=0;                                                               ";
                	E_file<<"\n		_incrementPointer("<<(SCOPE_TOP(statement))->p<<");                                                                    ";
                	E_file<<"\n	}                                                                                              ";
                	
                	E_file<<"\n	else if(_pointer["<<Q<<"]<_pointer_last_value["<<Q<<"])                                    ";
                	E_file<<"\n	{                                                                                               ";
                	E_file<<"\n		//sequence just converged;                                                              ";
                	E_file<<"\n		break;                                                                                  ";
                	E_file<<"\n	}                                                                                               ";
                	E_file<<"\n	else if (_pointer["<<Q<<"]==_pointer_last_value["<<Q<<"] && ("<<
                e1
                <<"==false))  ";
                	E_file<<"\n	{                                                                                               ";
                	E_file<<"\n		//terminate the do-while statement                                                      ";
                	E_file<<"\n		_pointer["<<Q<<"]=0;                                                               ";
                	E_file<<"\n		_incrementPointer("<<(SCOPE_TOP(statement))->p<<");                                                                    ";
                	E_file<<"\n	} ;                                                                                              ";
                	
                	E_file<<"\n};                                                                                                   ";
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledo_while_statementEx; /* Prevent compiler warnings */
    ruledo_while_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end do_while_statement */

/**
 * $ANTLR start parallel_statement
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2073:1: parallel_statement : s= '[' s1= sequence[ptr] ( '||' s2= sequence[ptr] )+ ']' ;
 */
static void
parallel_statement(psitarParser ctx)
{
    pANTLR3_COMMON_TOKEN    s;
    int s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 int

    int s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 int

    /* Initialize rule variables
     */


            //list that stores pointers and last
            //states of each of the sequences contained in the
            //parallel region.
            std::list<std::pair<int,int> > ptr_list;
            std::list<std::pair<int,int> >::iterator it;
            std::pair<int,int> pair;

            int branches=0; //number of branches
            int ptr=0;      //pointer for each branch
    	ptr_list.clear();

    s       = NULL;

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2094:9: (s= '[' s1= sequence[ptr] ( '||' s2= sequence[ptr] )+ ']' )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2094:11: s= '[' s1= sequence[ptr] ( '||' s2= sequence[ptr] )+ ']'
        {
            s = (pANTLR3_COMMON_TOKEN) MATCHT(82, &FOLLOW_82_in_parallel_statement3633);
            if  (HASEXCEPTION())
            {
                goto ruleparallel_statementEx;
            }


            {
                	//write some text
                			E_file<<"\ncase "<<(SCOPE_TOP(statement))->k<<":";
                			E_file<<" {\n";
                			E_file<<"\n//parallel statement begins, line "<<(s->getLine(s));
                			
                			//generate a pointer for the child sequence
                			ptr=(SCOPE_TOP(cf))->pointer_count;
                			++(SCOPE_TOP(cf))->pointer_count;

                                	
            }


            {
                E_file<<"\n//one branch of parallel statement, using pointer "<<ptr;
            }


            FOLLOWPUSH(FOLLOW_sequence_in_parallel_statement3693);
            s1=sequence(ctx, ptr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparallel_statementEx;
            }


            {

                	pair=std::make_pair(ptr, s1
                );
                        	ptr_list.push_back(pair);
                        
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2115:9: ( '||' s2= sequence[ptr] )+
            {
                int cnt66=0;

                for (;;)
                {
                    int alt66=2;
            	switch ( LA(1) )
            	{
            	case 84:
            		{
            			alt66=1;
            		}
            	    break;

            	}

            	switch (alt66)
            	{
            	    case 1:
            	        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2115:10: '||' s2= sequence[ptr]
            	        {
            	             MATCHT(84, &FOLLOW_84_in_parallel_statement3736);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparallel_statementEx;
            	            }


            	            {

            	                                        //generate a pointer for the child sequence
            	                                        ptr=(SCOPE_TOP(cf))->pointer_count;
            	                                        ++(SCOPE_TOP(cf))->pointer_count;
            	                                
            	            }


            	            {
            	                E_file<<"\n//another branch of parallel statement, using pointer "<<ptr;
            	            }


            	            FOLLOWPUSH(FOLLOW_sequence_in_parallel_statement3793);
            	            s2=sequence(ctx, ptr);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparallel_statementEx;
            	            }


            	            {
            	                 
            	                	pair=std::make_pair(ptr, s2
            	                );
            	                        	ptr_list.push_back(pair);
            	                        
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt66 >= 1 )
            		{
            		    goto loop66;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleparallel_statementEx;
            	}
            	cnt66++;
                }
                loop66: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(83, &FOLLOW_83_in_parallel_statement3827);
            if  (HASEXCEPTION())
            {
                goto ruleparallel_statementEx;
            }


            {

                                //write some code at the end of the parallel block:
                                //to check if all parallel branches have terminated
                                E_file<<"\n//if all parallel branches have terminated,";
                                E_file<<"\n//exit the parallel statement.";
                                E_file<<"\nif(";

                                for(it=ptr_list.begin(); it!=ptr_list.end();it++)
                                {
                                        if(!(it==ptr_list.begin()))
                                              E_file<<" &&";
                                        pair=*it;
                                        int P=pair.first;
                                        int Q=pair.second;
                                        E_file<<" _pointer["<<P<<"]=="<<Q;
                                }
                                E_file<<") \n{\n";
                                E_file<<"\n //reset pointers of parallel branches";
                                for(it=ptr_list.begin(); it!=ptr_list.end();it++)
                                         {
                                              pair=*it;
                                               int P=pair.first;
                                                E_file<<"\n_pointer["<<P<<"]=0;";
                	}
                	E_file<<"\n_reexecute=1;";
                	E_file<<"\n//terminate the parallel statement";
                	E_file<<"\n _incrementPointer("<<(SCOPE_TOP(statement))->p<<");\n}";
                	
                                E_file<<"\nelse \n break;";
                                E_file<<"\n//parallel statement ends";
                                E_file<<"\n}\n";
                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparallel_statementEx; /* Prevent compiler warnings */
    ruleparallel_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                     	(SCOPE_TOP(statement))->last_case=(SCOPE_TOP(statement))->k;

                }
            }


    return ;
}
/* $ANTLR end parallel_statement */

/**
 * $ANTLR start expression_cf
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2250:1: expression_cf returns [std::string text] : e1= exp1 ( OR e2= exp1 )* ;
 */
static std::string
expression_cf(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2251:9: (e1= exp1 ( OR e2= exp1 )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2254:9: e1= exp1 ( OR e2= exp1 )*
        {
            FOLLOWPUSH(FOLLOW_exp1_in_expression_cf3986);
            e1=exp1(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpression_cfEx;
            }


            {
                text=
                e1
                ;

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2255:9: ( OR e2= exp1 )*

            for (;;)
            {
                int alt67=2;
                switch ( LA(1) )
                {
                case OR:
                	{
                		alt67=1;
                	}
                    break;

                }

                switch (alt67)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2255:11: OR e2= exp1
            	    {
            	         MATCHT(OR, &FOLLOW_OR_in_expression_cf3999);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpression_cfEx;
            	        }


            	        {
            	            text
            	            .append("||");
            	        }


            	        FOLLOWPUSH(FOLLOW_exp1_in_expression_cf4004);
            	        e2=exp1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpression_cfEx;
            	        }


            	        {
            	            text
            	            .append(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop67;	/* break out of the loop */
            	    break;
                }
            }
            loop67: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpression_cfEx; /* Prevent compiler warnings */
    ruleexpression_cfEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end expression_cf */

/**
 * $ANTLR start exp1
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2259:1: exp1 returns [std::string text] : e1= exp2 ( AND e2= exp2 )* ;
 */
static std::string
exp1(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2260:9: (e1= exp2 ( AND e2= exp2 )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2261:9: e1= exp2 ( AND e2= exp2 )*
        {
            FOLLOWPUSH(FOLLOW_exp2_in_exp14048);
            e1=exp2(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp1Ex;
            }


            {
                text=
                e1
                ;

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2262:9: ( AND e2= exp2 )*

            for (;;)
            {
                int alt68=2;
                switch ( LA(1) )
                {
                case AND:
                	{
                		alt68=1;
                	}
                    break;

                }

                switch (alt68)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2262:10: AND e2= exp2
            	    {
            	         MATCHT(AND, &FOLLOW_AND_in_exp14060);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp1Ex;
            	        }


            	        {
            	            text
            	            .append("&&");
            	        }


            	        FOLLOWPUSH(FOLLOW_exp2_in_exp14068);
            	        e2=exp2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp1Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            );  
            	        }


            	    }
            	    break;

            	default:
            	    goto loop68;	/* break out of the loop */
            	    break;
                }
            }
            loop68: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp1Ex; /* Prevent compiler warnings */
    ruleexp1Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp1 */

/**
 * $ANTLR start exp2
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2266:1: exp2 returns [std::string text] : ( NOT )? exp3 ;
 */
static std::string
exp2(psitarParser ctx)
{
    std::string text;


    std::string exp33;
    #undef	RETURN_TYPE_exp33
    #define	RETURN_TYPE_exp33 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2267:9: ( ( NOT )? exp3 )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2267:10: ( NOT )? exp3
        {
            {
                text="";

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2268:9: ( NOT )?
            {
                int alt69=2;
                switch ( LA(1) )
                {
                    case NOT:
                    	{
                    		alt69=1;
                    	}
                        break;
                }

                switch (alt69)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2268:10: NOT
            	    {
            	         MATCHT(NOT, &FOLLOW_NOT_in_exp24118);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp2Ex;
            	        }


            	        {
            	            text
            	            .append("!");
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_exp3_in_exp24133);
            exp33=exp3(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp2Ex;
            }


            {
                text
                .append("(");text
                .append(exp33
                ); text
                .append(")");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp2Ex; /* Prevent compiler warnings */
    ruleexp2Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp2 */

/**
 * $ANTLR start exp3
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2272:1: exp3 returns [std::string text] : e1= exp4 (c1= comparison_operator e2= exp4 )* ;
 */
static std::string
exp3(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    sitarParser_comparison_operator_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 sitarParser_comparison_operator_return

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2273:9: (e1= exp4 (c1= comparison_operator e2= exp4 )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2273:10: e1= exp4 (c1= comparison_operator e2= exp4 )*
        {
            FOLLOWPUSH(FOLLOW_exp4_in_exp34163);
            e1=exp4(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp3Ex;
            }


            {
                text=
                e1
                ;

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2274:10: (c1= comparison_operator e2= exp4 )*

            for (;;)
            {
                int alt70=2;
                switch ( LA(1) )
                {
                case CONNECT_LEFT:
                case 70:
                case 78:
                case 79:
                case 80:
                case 81:
                	{
                		alt70=1;
                	}
                    break;

                }

                switch (alt70)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2274:11: c1= comparison_operator e2= exp4
            	    {
            	        FOLLOWPUSH(FOLLOW_comparison_operator_in_exp34178);
            	        c1=comparison_operator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp3Ex;
            	        }


            	        {
            	            text
            	            .append( (const char*)((STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
            	            ->chars));
            	        }


            	        FOLLOWPUSH(FOLLOW_exp4_in_exp34194);
            	        e2=exp4(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp3Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop70;	/* break out of the loop */
            	    break;
                }
            }
            loop70: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp3Ex; /* Prevent compiler warnings */
    ruleexp3Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp3 */

/**
 * $ANTLR start exp4
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2281:1: exp4 returns [std::string text] : e1= exp5 (c1= add_operator e2= exp5 )* ;
 */
static std::string
exp4(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    sitarParser_add_operator_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 sitarParser_add_operator_return

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2282:9: (e1= exp5 (c1= add_operator e2= exp5 )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2282:11: e1= exp5 (c1= add_operator e2= exp5 )*
        {
            FOLLOWPUSH(FOLLOW_exp5_in_exp44239);
            e1=exp5(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp4Ex;
            }


            {
                text=
                e1
                ;

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2283:10: (c1= add_operator e2= exp5 )*

            for (;;)
            {
                int alt71=2;
                switch ( LA(1) )
                {
                case MINUS:
                case PLUS:
                	{
                		alt71=1;
                	}
                    break;

                }

                switch (alt71)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2283:11: c1= add_operator e2= exp5
            	    {
            	        FOLLOWPUSH(FOLLOW_add_operator_in_exp44254);
            	        c1=add_operator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp4Ex;
            	        }


            	        {
            	            text
            	            .append((const char*)((STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
            	            ->chars));
            	        }


            	        FOLLOWPUSH(FOLLOW_exp5_in_exp44270);
            	        e2=exp5(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp4Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop71;	/* break out of the loop */
            	    break;
                }
            }
            loop71: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp4Ex; /* Prevent compiler warnings */
    ruleexp4Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp4 */

/**
 * $ANTLR start exp5
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2289:1: exp5 returns [std::string text] : e1= exp6 (c1= mul_operator e2= exp6 )* ;
 */
static std::string
exp5(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    sitarParser_mul_operator_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 sitarParser_mul_operator_return

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2290:9: (e1= exp6 (c1= mul_operator e2= exp6 )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2290:11: e1= exp6 (c1= mul_operator e2= exp6 )*
        {
            FOLLOWPUSH(FOLLOW_exp6_in_exp54314);
            e1=exp6(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp5Ex;
            }


            {
                text=
                e1
                ;
                 
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2291:9: (c1= mul_operator e2= exp6 )*

            for (;;)
            {
                int alt72=2;
                switch ( LA(1) )
                {
                case 71:
                case 74:
                case 76:
                	{
                		alt72=1;
                	}
                    break;

                }

                switch (alt72)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2291:11: c1= mul_operator e2= exp6
            	    {
            	        FOLLOWPUSH(FOLLOW_mul_operator_in_exp54329);
            	        c1=mul_operator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp5Ex;
            	        }


            	        {
            	            text
            	            .append((const char*)((STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
            	            ->chars));
            	        }


            	        FOLLOWPUSH(FOLLOW_exp6_in_exp54345);
            	        e2=exp6(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp5Ex;
            	        }


            	        {
            	            text
            	            .append(e2
            	            );  
            	        }


            	    }
            	    break;

            	default:
            	    goto loop72;	/* break out of the loop */
            	    break;
                }
            }
            loop72: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp5Ex; /* Prevent compiler warnings */
    ruleexp5Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp5 */

/**
 * $ANTLR start exp6
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2296:1: exp6 returns [std::string text] : ( '-' )? a1= atomic_expression_cf ;
 */
static std::string
exp6(psitarParser ctx)
{
    std::string text;


    std::string a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2297:9: ( ( '-' )? a1= atomic_expression_cf )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2297:10: ( '-' )? a1= atomic_expression_cf
        {
            {
                text="(";

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2298:9: ( '-' )?
            {
                int alt73=2;
                switch ( LA(1) )
                {
                    case MINUS:
                    	{
                    		alt73=1;
                    	}
                        break;
                }

                switch (alt73)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2298:10: '-'
            	    {
            	         MATCHT(MINUS, &FOLLOW_MINUS_in_exp64395);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexp6Ex;
            	        }


            	        {
            	            text
            	            .append("-");
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_atomic_expression_cf_in_exp64413);
            a1=atomic_expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexp6Ex;
            }


            {
                text
                .append(a1
                ); text
                .append(")");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexp6Ex; /* Prevent compiler warnings */
    ruleexp6Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end exp6 */

/**
 * $ANTLR start comparison_operator
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2306:1: comparison_operator : ( '==' | '!=' | '>=' | '<=' | '<' | '>' );
 */
static sitarParser_comparison_operator_return
comparison_operator(psitarParser ctx)
{
    sitarParser_comparison_operator_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2307:9: ( '==' | '!=' | '>=' | '<=' | '<' | '>' )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:
        {
            if ( LA(1) == CONNECT_LEFT || LA(1) == 70 || ((LA(1) >= 78) && (LA(1) <= 81)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulecomparison_operatorEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparison_operatorEx; /* Prevent compiler warnings */
    rulecomparison_operatorEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end comparison_operator */

/**
 * $ANTLR start add_operator
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2309:1: add_operator : ( '+' | '-' );
 */
static sitarParser_add_operator_return
add_operator(psitarParser ctx)
{
    sitarParser_add_operator_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2310:9: ( '+' | '-' )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:
        {
            if ( LA(1) == MINUS || LA(1) == PLUS )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleadd_operatorEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadd_operatorEx; /* Prevent compiler warnings */
    ruleadd_operatorEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end add_operator */

/**
 * $ANTLR start mul_operator
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2312:1: mul_operator : ( '*' | '/' | '%' );
 */
static sitarParser_mul_operator_return
mul_operator(psitarParser ctx)
{
    sitarParser_mul_operator_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2313:9: ( '*' | '/' | '%' )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:
        {
            if ( LA(1) == 71 || LA(1) == 74 || LA(1) == 76 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulemul_operatorEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemul_operatorEx; /* Prevent compiler warnings */
    rulemul_operatorEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end mul_operator */

/**
 * $ANTLR start atomic_expression_cf
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2318:1: atomic_expression_cf returns [std::string text] : ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block );
 */
static std::string
atomic_expression_cf(psitarParser ctx)
{
    std::string text;


    pANTLR3_COMMON_TOKEN    int1;
    pANTLR3_COMMON_TOKEN    str1;
    std::string e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e std::string

    sitarParser_function_call_return f;
    #undef	RETURN_TYPE_f
    #define	RETURN_TYPE_f sitarParser_function_call_return

    std::string tc;
    #undef	RETURN_TYPE_tc
    #define	RETURN_TYPE_tc std::string

    std::string tp;
    #undef	RETURN_TYPE_tp
    #define	RETURN_TYPE_tp std::string

    sitarParser_identifier_return id1;
    #undef	RETURN_TYPE_id1
    #define	RETURN_TYPE_id1 sitarParser_identifier_return

    sitarParser_expression_code_block_return exp;
    #undef	RETURN_TYPE_exp
    #define	RETURN_TYPE_exp sitarParser_expression_code_block_return

    /* Initialize rule variables
     */

    int1       = NULL;
    str1       = NULL;

    {
        {
            //  /home/nehak/Projects/sitar/translator/grammar/sitar.g:2319:9: ( '(' e= expression_cf ')' |f= function_call |tc= this_cycle |tp= this_phase |int1= INTEGER |str1= STRING |id1= identifier |exp= expression_code_block )

            ANTLR3_UINT32 alt74;

            alt74=8;

            alt74 = cdfa74.predict(ctx, RECOGNIZER, ISTREAM, &cdfa74);
            if  (HASEXCEPTION())
            {
                goto ruleatomic_expression_cfEx;
            }

            switch (alt74)
            {
        	case 1:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2320:9: '(' e= expression_cf ')'
        	    {
        	         MATCHT(72, &FOLLOW_72_in_atomic_expression_cf4546);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_cf_in_atomic_expression_cf4549);
        	        e=expression_cf(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	         MATCHT(73, &FOLLOW_73_in_atomic_expression_cf4550);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text="("+
        	            e
        	            +")";

        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2322:10: f= function_call
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_atomic_expression_cf4575);
        	        f=function_call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            f.text
        	            ;

        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2323:10: tc= this_cycle
        	    {
        	        FOLLOWPUSH(FOLLOW_this_cycle_in_atomic_expression_cf4592);
        	        tc=this_cycle(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            tc
        	            ;

        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2324:10: tp= this_phase
        	    {
        	        FOLLOWPUSH(FOLLOW_this_phase_in_atomic_expression_cf4611);
        	        tp=this_phase(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            tp
        	            ;

        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2325:10: int1= INTEGER
        	    {
        	        int1 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_atomic_expression_cf4630);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=((const char*)(int1->getText(int1))->chars);

        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2326:10: str1= STRING
        	    {
        	        str1 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_atomic_expression_cf4650);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=((const char*)(str1->getText(str1))->chars);

        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2327:10: id1= identifier
        	    {
        	        FOLLOWPUSH(FOLLOW_identifier_in_atomic_expression_cf4673);
        	        id1=identifier(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=((const char*)
        	            (STRSTREAM->toStringTT(STRSTREAM, id1.start, id1.stop))
        	            ->chars);

        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2328:11: exp= expression_code_block
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_code_block_in_atomic_expression_cf4692);
        	        exp=expression_code_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomic_expression_cfEx;
        	        }


        	        {
        	            text=
        	            exp.text
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomic_expression_cfEx; /* Prevent compiler warnings */
    ruleatomic_expression_cfEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end atomic_expression_cf */

/**
 * $ANTLR start expression_code_block
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2333:1: expression_code_block returns [std::string text, int line] : c= code_block ;
 */
static sitarParser_expression_code_block_return
expression_code_block(psitarParser ctx)
{
    sitarParser_expression_code_block_return retval;


    sitarParser_code_block_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c sitarParser_code_block_return

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2334:9: (c= code_block )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2334:11: c= code_block
        {
            FOLLOWPUSH(FOLLOW_code_block_in_expression_code_block4755);
            c=code_block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpression_code_blockEx;
            }


            {
                retval.line=
                c.line
                ;
                 
                             retval.text=
                c.text
                ;

                            
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpression_code_blockEx; /* Prevent compiler warnings */
    ruleexpression_code_blockEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end expression_code_block */

/**
 * $ANTLR start function_call
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2343:1: function_call returns [std::string text, int line] : id1= identifier '(' (a1= argument_list )? ')' ;
 */
static sitarParser_function_call_return
function_call(psitarParser ctx)
{
    sitarParser_function_call_return retval;


    sitarParser_identifier_return id1;
    #undef	RETURN_TYPE_id1
    #define	RETURN_TYPE_id1 sitarParser_identifier_return

    std::string a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 std::string

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2344:9: (id1= identifier '(' (a1= argument_list )? ')' )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2345:9: id1= identifier '(' (a1= argument_list )? ')'
        {
            FOLLOWPUSH(FOLLOW_identifier_in_function_call4840);
            id1=identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunction_callEx;
            }


             MATCHT(72, &FOLLOW_72_in_function_call4842);
            if  (HASEXCEPTION())
            {
                goto rulefunction_callEx;
            }


            {
                retval.line=
                id1.line
                ;
                 
                             retval.text=((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, id1.start, id1.stop))
                ->chars);

                             retval.text
                .append("(");
                            
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2350:10: (a1= argument_list )?
            {
                int alt75=2;
                switch ( LA(1) )
                {
                    case CODE_BLOCK:
                    case IDENTIFIER:
                    case INTEGER:
                    case MINUS:
                    case NOT:
                    case STRING:
                    case THIS_CYCLE:
                    case THIS_PHASE:
                    case 72:
                    	{
                    		alt75=1;
                    	}
                        break;
                }

                switch (alt75)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2350:12: a1= argument_list
            	    {
            	        FOLLOWPUSH(FOLLOW_argument_list_in_function_call4871);
            	        a1=argument_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunction_callEx;
            	        }


            	        {
            	             retval.text
            	            .append(a1
            	            ); 
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(73, &FOLLOW_73_in_function_call4895);
            if  (HASEXCEPTION())
            {
                goto rulefunction_callEx;
            }


            {
                retval.text
                .append(")");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end function_call */

/**
 * $ANTLR start argument_list
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2357:1: argument_list returns [std::string text] : e1= expression_cf ( ',' e2= expression_cf )* ;
 */
static std::string
argument_list(psitarParser ctx)
{
    std::string text;


    std::string e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 std::string

    std::string e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 std::string

    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2358:9: (e1= expression_cf ( ',' e2= expression_cf )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2358:12: e1= expression_cf ( ',' e2= expression_cf )*
        {
            FOLLOWPUSH(FOLLOW_expression_cf_in_argument_list4930);
            e1=expression_cf(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleargument_listEx;
            }


            {
                text=
                e1
                ;

            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2359:9: ( ',' e2= expression_cf )*

            for (;;)
            {
                int alt76=2;
                switch ( LA(1) )
                {
                case 75:
                	{
                		alt76=1;
                	}
                    break;

                }

                switch (alt76)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2359:11: ',' e2= expression_cf
            	    {
            	         MATCHT(75, &FOLLOW_75_in_argument_list4951);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargument_listEx;
            	        }


            	        {
            	            text
            	            .append(",");
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_cf_in_argument_list4986);
            	        e2=expression_cf(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargument_listEx;
            	        }


            	        {
            	            text
            	            .append(e2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop76;	/* break out of the loop */
            	    break;
                }
            }
            loop76: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleargument_listEx; /* Prevent compiler warnings */
    ruleargument_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end argument_list */

/**
 * $ANTLR start this_cycle
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2367:1: this_cycle returns [std::string text] : THIS_CYCLE ;
 */
static std::string
this_cycle(psitarParser ctx)
{
    std::string text;


    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2368:9: ( THIS_CYCLE )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2368:17: THIS_CYCLE
        {
             MATCHT(THIS_CYCLE, &FOLLOW_THIS_CYCLE_in_this_cycle5040);
            if  (HASEXCEPTION())
            {
                goto rulethis_cycleEx;
            }


            {
                text="(current_time.cycle())";

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulethis_cycleEx; /* Prevent compiler warnings */
    rulethis_cycleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end this_cycle */

/**
 * $ANTLR start this_phase
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2372:1: this_phase returns [std::string text] : THIS_PHASE ;
 */
static std::string
this_phase(psitarParser ctx)
{
    std::string text;


    /* Initialize rule variables
     */

    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2373:9: ( THIS_PHASE )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2373:17: THIS_PHASE
        {
             MATCHT(THIS_PHASE, &FOLLOW_THIS_PHASE_in_this_phase5093);
            if  (HASEXCEPTION())
            {
                goto rulethis_phaseEx;
            }


            {
                text="(current_time.phase())";

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulethis_phaseEx; /* Prevent compiler warnings */
    rulethis_phaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return text;
}
/* $ANTLR end this_phase */

/**
 * $ANTLR start code_block_with_info
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2379:1: code_block_with_info returns [std::string text, int line] : code_block ;
 */
static sitarParser_code_block_with_info_return
code_block_with_info(psitarParser ctx)
{
    sitarParser_code_block_with_info_return retval;


    sitarParser_code_block_return code_block4;
    #undef	RETURN_TYPE_code_block4
    #define	RETURN_TYPE_code_block4 sitarParser_code_block_return

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2380:9: ( code_block )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2380:19: code_block
        {
            FOLLOWPUSH(FOLLOW_code_block_in_code_block_with_info5151);
            code_block4=code_block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecode_block_with_infoEx;
            }


            {


                                //Delete the delimeters of the code block,
                                //and return the entire code as a string
                                //to the parent rule
                                retval.line=
                code_block4.line
                ;

                                retval.text= 
                code_block4.text
                ;

                                 std::stringstream ss;
                                ss.str(std::string());  //clear the string stream
                                ss<<"\n//----code block from file "<<(GDATA->getAttribute("INPUT_FILE"))<<", line:"<<code_block4.line
                <<" ----\n";
                                ss<<retval.text
                ;
                                ss<<"\n//----end code block-------\n";
                                retval.text=ss.str();

                        
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecode_block_with_infoEx; /* Prevent compiler warnings */
    rulecode_block_with_infoEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end code_block_with_info */

/**
 * $ANTLR start code_block
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2404:1: code_block returns [std::string text, int line] : CODE_BLOCK ;
 */
static sitarParser_code_block_return
code_block(psitarParser ctx)
{
    sitarParser_code_block_return retval;


    pANTLR3_COMMON_TOKEN    CODE_BLOCK5;

    /* Initialize rule variables
     */

    CODE_BLOCK5       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2405:9: ( CODE_BLOCK )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2405:20: CODE_BLOCK
        {
            CODE_BLOCK5 = (pANTLR3_COMMON_TOKEN) MATCHT(CODE_BLOCK, &FOLLOW_CODE_BLOCK_in_code_block5218);
            if  (HASEXCEPTION())
            {
                goto rulecode_blockEx;
            }


            {


                                //Delete the delimeters of the code block,
                                //and return the entire code as a string
                                //to the parent rule
                                retval.line=(CODE_BLOCK5->getLine(CODE_BLOCK5));

                                retval.text= std::string((const char*)((CODE_BLOCK5->getText(CODE_BLOCK5))->chars));

                                std::string &s = retval.text
                ;
                                //erase the first '$'
                                s.erase(0,1);
                                //erase the last '$'
                                if(s.size() > 0)
                                   s.resize(s.size() - 1);
                                //s.erase(s.find("$"),1);
                                
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecode_blockEx; /* Prevent compiler warnings */
    rulecode_blockEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end code_block */

/**
 * $ANTLR start identifier
 * /home/nehak/Projects/sitar/translator/grammar/sitar.g:2425:1: identifier returns [int line] : id= IDENTIFIER ( ( DOT | SCOPE | POINTER ) IDENTIFIER )* ;
 */
static sitarParser_identifier_return
identifier(psitarParser ctx)
{
    sitarParser_identifier_return retval;


    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    id       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2426:2: (id= IDENTIFIER ( ( DOT | SCOPE | POINTER ) IDENTIFIER )* )
        // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2426:5: id= IDENTIFIER ( ( DOT | SCOPE | POINTER ) IDENTIFIER )*
        {
            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_identifier5274);
            if  (HASEXCEPTION())
            {
                goto ruleidentifierEx;
            }


            // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2426:18: ( ( DOT | SCOPE | POINTER ) IDENTIFIER )*

            for (;;)
            {
                int alt77=2;
                switch ( LA(1) )
                {
                case DOT:
                case POINTER:
                case SCOPE:
                	{
                		alt77=1;
                	}
                    break;

                }

                switch (alt77)
                {
            	case 1:
            	    // /home/nehak/Projects/sitar/translator/grammar/sitar.g:2426:19: ( DOT | SCOPE | POINTER ) IDENTIFIER
            	    {
            	        if ( LA(1) == DOT || LA(1) == POINTER || LA(1) == SCOPE )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleidentifierEx;
            	        }


            	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_identifier5283);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifierEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop77;	/* break out of the loop */
            	    break;
                }
            }
            loop77: ; /* Jump out to here if this rule does not match */


            {
                retval.line=(id->getLine(id));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end identifier */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
